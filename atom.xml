<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇航员不会飞</title>
  
  <subtitle>里面的人想出去，外面的人想进来</subtitle>
  <link href="https://codeyg.top/atom.xml" rel="self"/>
  
  <link href="https://codeyg.top/"/>
  <updated>2021-07-27T18:46:57.591Z</updated>
  <id>https://codeyg.top/</id>
  
  <author>
    <name>白日梦想家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一面--Thread Pool</title>
    <link href="https://codeyg.top/2021/07/27/%E9%9D%A2%E8%AF%95--%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://codeyg.top/2021/07/27/%E9%9D%A2%E8%AF%95--%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-07-27T13:58:58.000Z</published>
    <updated>2021-07-27T18:46:57.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Thread Pool</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_00-48-33.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>什么是线程池？</font></p><p>线程池是用来放置线程的池子。嗯，大概是这么回事吧！</p><a id="more"></a><h4 id="关于线程池"><a href="#关于线程池" class="headerlink" title="关于线程池"></a>关于线程池</h4><p>线程池（ThreadPool）是一种基于池化思想管理和使用线程的机制。它是将多个线程预先存储在一个“池子”内，当有任务出现时可以避免重新创建和销毁线程所带来性能开销，只需要从“池子”内取出相应的线程执行对应的任务即可。</p><p><strong>里巴巴在其《Java开发手册》中也强制规定：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</strong></p><h4 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h4><ol><li><p>降低资源消耗【通过重复利用已创建的线程去降低线程的创建和销毁】</p></li><li><p>提高响应速度【当任务达到时，任务可以不需要等到线程创建就能立即执行，重复利用线程】</p></li></ol><h4 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h4><ul><li>线程池是为突然大量爆发的线程设计的，通过有限的几个固定线程为大量的操作服务，减少了创建和销毁线程所需的时间，从而提高效率。</li><li>如果一个线程的时间非常长，就没必要使用线程池了，况且我们还不能控制线程池中线程的开始、挂起、和中止。</li></ul><h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>线程池的创建方法总共有 7 种，但总体来说可分为 2 类：</p><ul><li>一类是通过 <code>ThreadPoolExecutor</code> 创建的线程池；</li><li>另一个类是通过 <code>Executors</code> 创建的线程池。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_01-02-50.png" alt=""></p><p>线程池的创建方式总共包含以下 7 种（其中 6 种是通过 <code>Executors</code> 创建的，1 种是通过 <code>ThreadPoolExecutor</code> 创建的）：</p><ol><li><code>Executors.newFixedThreadPool</code>：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待；</li><li><code>Executors.newCachedThreadPool</code>：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程；</li><li><code>Executors.newSingleThreadExecutor</code>：创建单个线程数的线程池，它可以保证先进先出的执行顺序；</li><li><code>Executors.newScheduledThreadPool</code>：创建一个可以执行延迟任务的线程池；</li><li><code>Executors.newSingleThreadScheduledExecutor</code>：创建一个单线程的可以执行延迟任务的线程池；</li><li><code>Executors.newWorkStealingPool</code>：创建一个抢占式执行的线程池（任务执行顺序不确定）【JDK 1.8 添加】。</li><li><strong><code>ThreadPoolExecutor</code>：最原始的创建线程池的方式，它包含了 7 个参数可供设置，重点介绍</strong>。</li></ol><h4 id="线程池内部原理"><a href="#线程池内部原理" class="headerlink" title="线程池内部原理"></a>线程池内部原理</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_01-40-35.png" alt=""></p><hr><h4 id="线程池工作流程"><a href="#线程池工作流程" class="headerlink" title="线程池工作流程"></a>线程池工作流程</h4><p><strong>1、当execute方法提交一个任务时，如果线程池中线程数小于corePoolSize,那么不管线程池中是否有空闲的线程，都会创建一个新的线程来执行任务。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-03-32.png" alt=""></p><p><strong>2、当execute方法提交一个任务时，线程池中的线程数已经达到了corePoolSize,且此时没有空闲的线程，那么则会将任务存储到workQueue中。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-19-18.png" alt=""></p><p><strong>3、如果execute提交任务时线程池中的线程数已经到达了corePoolSize,并且workQueue已满，那么则会创建新的线程来执行任务，但总线程数应该小于maximumPoolSize。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-21-20.png" alt=""></p><p><strong>4、如果线程池中的线程执行完了当前的任务，则会尝试从workQueue中取出第一个任务来执行。如果workQueue为空则会阻塞线程。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-23-56.png" alt=""></p><p><strong>5、如果execute提交任务时，线程池中的线程数达到了maximumPoolSize，且workQueue已满，此时会执行拒绝策略来拒绝接受任务。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-30-14.png" alt=""></p><p><strong>6、如果线程池中的线程数超过了corePoolSize，那么空闲时间超过keepAliveTime的线程会被销毁，但程池中线程个数会保持为corePoolSize。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-41-49.png" alt=""></p><p><strong>7、如果线程池存在空闲的线程，并且设置了allowCoreThreadTimeOut为true。那么空闲时间超过keepAliveTime的线程都会被销毁。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_02-41-33.png" alt=""></p><hr><h4 id="线程池七个参数"><a href="#线程池七个参数" class="headerlink" title="线程池七个参数"></a>线程池七个参数</h4><p><strong>分别为：</strong></p><ol><li><p><strong>corePoolSize【核心线程数】</strong></p><p>线程池维护的最小线程数量，核心线程创建后不会被回收。</p></li><li><p><strong>maximumPoolSize【最大线程数】</strong></p><p>线程池允许创建的最大线程数量。</p></li><li><p><strong>keepAliveTime【空闲线程存活时间】</strong></p><p>当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。</p><p>可被回收的线程：</p><ol><li>设置 allowCoreThreadTimeout=true 的核心线程。</li><li>大于核心线程数的线程（非核心线程）。</li></ol></li><li><p><strong>unit【时间单位】</strong></p><p>keepAliveTime的时间单位，常用【 TimeUnit.MILLISECONDS  毫秒 】</p></li><li><p><strong>workQueue【工作队列】</strong></p><p>存放待执行任务的队列。核心线程数 &lt; 提交的任务数 &lt; 最大线程数</p><p>它仅仅用来存放被execute()方法提交的 Runnable 任务。</p></li><li><p><strong>threadFactory【线程工厂】</strong></p><p>创建线程的工厂，可以设定线程名、线程编号。</p></li><li><p><strong>handler【拒绝策略】</strong></p><p>当线程池线程数已满，并且工作队列达到限制。需要实现 RejectedExecutionHandler 接口。</p></li></ol><h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myThreadPoolExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(index + <span class="string">" 被执行,线程名:"</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Thread Pool&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-28_00-48-33.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是线程池？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;线程池是用来放置线程的池子。嗯，大概是这么回事吧！&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="java" scheme="https://codeyg.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--MyBatis</title>
    <link href="https://codeyg.top/2021/07/23/%E9%9D%A2%E8%AF%95--MyBatis/"/>
    <id>https://codeyg.top/2021/07/23/%E9%9D%A2%E8%AF%95--MyBatis/</id>
    <published>2021-07-23T00:58:58.000Z</published>
    <updated>2021-07-23T11:17:18.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 MyBatis</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/mybatis-logo.png" alt=""></p><p><strong>写在前面</strong></p><p>用久了 MyBatis 的逆向工程，原生的写法有点生疏了，趁着想起来赶紧复习一下！</p><a id="more"></a><h2 id="关于-MyBatis"><a href="#关于-MyBatis" class="headerlink" title="关于 MyBatis"></a>关于 MyBatis</h2><h3 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h3><p>Mybatis是一个半自动化的持久层框架，一般我们都分为三层，控制层，业务层，持久层，所谓的持久层就是专门负责写入数据库的层次。</p><h3 id="MyBatis-为什么说他是半自动化？"><a href="#MyBatis-为什么说他是半自动化？" class="headerlink" title="MyBatis 为什么说他是半自动化？"></a>MyBatis 为什么说他是半自动化？</h3><p>Hibernate 和 JPA 我们可以称为全自动化，所谓的全自动化就是他给我们直接省去了大量的 jdbc 代码，就连sql 语句我们都不用写，所以我们称他为全自动化，而Mybatis之所以称为半自动化就是虽然帮我省去了 jdbc 的一些重复代码，但是 sql 语句仍然需要我们自己写。</p><h3 id="MyBatis-的优点是什么？"><a href="#MyBatis-的优点是什么？" class="headerlink" title="MyBatis 的优点是什么？"></a>MyBatis 的优点是什么？</h3><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架；</p><p><strong>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集；</strong></p><p>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和 Java 的 POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录；</p><p><strong>并且mybatis还给我们提供了很多第三方插件（分页插件 / 逆向工程）；</strong></p><h3 id="MyBatis有哪些缺点？"><a href="#MyBatis有哪些缺点？" class="headerlink" title="MyBatis有哪些缺点？"></a>MyBatis有哪些缺点？</h3><ol><li>编写 SQL 语句时工作量很大，尤其是字段多、关联表多时，更是如此。</li><li>SQL 语句依赖于数据库，导致数据库移植性差，不能更换数据库。</li><li>框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。</li><li>二级缓存机制不佳。</li></ol><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>面对这些持久化框架我们应该如何来进行选择呢？</p><p>选型上都会拿 MyBatis 和 JPA 两个持久层框架一起使用，JPA 用来简单查询和新增修改是非常方便的，并且支持一对多关系。然后复杂的查询语句用 MyBatis 来完成。、</p><br/><h2 id="MyBatis-常用标签和注解"><a href="#MyBatis-常用标签和注解" class="headerlink" title="MyBatis 常用标签和注解"></a>MyBatis 常用标签和注解</h2><h3 id="了解一下"><a href="#了解一下" class="headerlink" title="了解一下"></a>了解一下</h3><p>MyBatis的常用标签有很多，比如</p><p><code>&lt;sql id=&quot;&quot;&gt;</code>：预定义可以复用的sql语句</p><p><code>&lt;include refid=&quot;&quot;&gt;</code>：根据id引用定义的sql语句</p><p><code>&lt;trim&gt;</code>：空白补全，配合<code>&lt;if&gt;</code>标签使用</p><p><code>&lt;if test=&quot;&quot;&gt;</code>：条件判断，该语句返回的true，则该标签内的语句就生效</p><p><code>&lt;bind name=&quot;&quot; value=&quot;&quot;&gt;</code>：创建一个变量，并且可以绑定到上下文</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.entity.User"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="顶级标签"><a href="#顶级标签" class="headerlink" title="顶级标签"></a>顶级标签</h3><h4 id="1、sql"><a href="#1、sql" class="headerlink" title="1、sql"></a>1、sql</h4><p><strong>作用：【可被其他语句引用的可重用语句块】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"valid"</span>&gt;</span> where id = 1 <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 引用 sql --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span> = <span class="string">'queryUser'</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">    select * from user </span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span> = <span class="string">'valid'</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、insert"><a href="#2、insert" class="headerlink" title="2、insert"></a>2、insert</h4><p><strong>作用：【映射插入语句】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.entity.User"</span> &gt;</span></span><br><span class="line">    insert into user (id, name)</span><br><span class="line">    values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、update"><a href="#3、update" class="headerlink" title="3、update"></a>3、update</h4><p><strong>作用：【映射更新语句】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">  update User set</span><br><span class="line">    name = #&#123;name&#125;,</span><br><span class="line">    sex= #&#123;sex&#125;</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4、delete"><a href="#4、delete" class="headerlink" title="4、delete"></a>4、delete</h4><p><strong>作用：【映射删除语句】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span>&gt;</span></span><br><span class="line">  delete from User where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态sql标签"><a href="#动态sql标签" class="headerlink" title="动态sql标签"></a>动态sql标签</h3><p><font color=#008000><strong>常用标签：&lt; if &gt;、&lt; where &gt;、&lt; trim &gt;、&lt; foreach &gt;</strong></font></p><h4 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h4><p><strong>作用：【where 语句的条件动态拼接】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserByName"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  SELECT * FROM User</span><br><span class="line">  WHERE valid = 1</span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!= null"</span>&gt;</span></span><br><span class="line">    AND name like #&#123;name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、choose-when-otherwise"><a href="#2、choose-when-otherwise" class="headerlink" title="2、choose (when, otherwise)"></a>2、choose (when, otherwise)</h4><p><strong>作用：【多条件分支，相当于Java中的switch语句】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  SELECT * FROM User WHERE age = 26</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"name!= null"</span>&gt;</span></span><br><span class="line">      AND name like #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"sex!= null "</span>&gt;</span></span><br><span class="line">      AND sex like #&#123;sex&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND valid = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>choose 有点像 Java 中的 switch 语句。choose执行过程中按顺序判断 when 中的条件出否成立，如果有一个成立，则 choose 结束。当 choose 中所有 when 的条件都不满则时，则执行 otherwise 中的 sql。</p><h4 id="3、trim-where-set"><a href="#3、trim-where-set" class="headerlink" title="3、trim (where, set)"></a>3、trim (where, set)</h4><p><strong>作用：【用于添加 SQL 语句的前缀或者后缀】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"WHERE"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND | OR "</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- set 元素会动态前置 SET 关键字，同时也会删掉无关的逗号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"SET"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以可利用 &lt; trim &gt; 来代替 &lt; where &gt; 的功能</p><ul><li><p>prefix：指定sql语句拼接的前缀</p></li><li><p>subfix：指定sql语句拼接的后缀</p></li><li><p>prefixOverrides：指定sql语句前面要去除的关键字或字符，如AND 逗号 括号等</p></li><li><p>suffixOverrides：指定sql语句后面要去除的关键字或字符</p></li></ul><h4 id="4、foreach"><a href="#4、foreach" class="headerlink" title="4、foreach"></a>4、foreach</h4><p><strong>作用：【用于在 SQL 语句中迭代一个集合，可用在构建 in 条件中】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM User</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>collection=”要遍历的集合” </li><li>item = “可以在元素体内使用的集合项”</li><li>index = “索引”</li><li>open = “开始字符串”</li><li>separator = “分隔符”</li><li>close = “结束字符串”</li></ul><h4 id="5、bind"><a href="#5、bind" class="headerlink" title="5、bind"></a>5、bind</h4><p><strong>作用：【标签表示在表达式以外创建一个变量，并将其绑定到当前的上下文】</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter.getTitle() + '%'"</span> /&gt;</span></span><br><span class="line">  SELECT * FROM User</span><br><span class="line">  WHERE name LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br/><h2 id="MyBatis-使用"><a href="#MyBatis-使用" class="headerlink" title="MyBatis 使用"></a>MyBatis 使用</h2><h3 id="1、MyBatis-中的-resultType-和-resultMap"><a href="#1、MyBatis-中的-resultType-和-resultMap" class="headerlink" title="1、MyBatis 中的 resultType 和 resultMap"></a>1、MyBatis 中的 resultType 和 resultMap</h3><p>resultType 用于返回值只有一个字段的类型，resultMap 用于返回值有多个字段的类型。至于结果是 List 还是一个，则在 Mapper 中定义返回值是List还是单个。</p><p>使用 resultType：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"count"</span> <span class="attr">resultType</span>=<span class="string">"java.lang.Integer"</span>&gt;</span>  </span><br><span class="line">        SELECT count(*) FROM USER  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 resultMap：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.entity.Blog"</span> <span class="attr">id</span>=<span class="string">"BlogResult"</span>&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"title"</span> <span class="attr">property</span>=<span class="string">"title"</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"content"</span> <span class="attr">property</span>=<span class="string">"content"</span>/&gt;</span>    </span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"owner"</span> <span class="attr">property</span>=<span class="string">"owner"</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span>   </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultMap</span>=<span class="string">"BlogResult"</span>&gt;</span>    </span><br><span class="line">   select * from t_blog where id = #&#123;id&#125;    </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2、xml中的timestamp比较"><a href="#2、xml中的timestamp比较" class="headerlink" title="2、xml中的timestamp比较"></a>2、xml中的timestamp比较</h3><p><strong>转义字符表</strong></p><table><thead><tr><th>转义</th><th>符号</th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td></tr><tr><td><code>&amp;apos;</code></td><td>’</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td></tr></tbody></table><h3 id="3、MyBatis-批量插入"><a href="#3、MyBatis-批量插入" class="headerlink" title="3、MyBatis 批量插入"></a>3、MyBatis 批量插入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertForeach"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">insert into user</span><br><span class="line">( id,name )</span><br><span class="line">values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">  (</span><br><span class="line">    #&#123;item.id&#125;,</span><br><span class="line">    #&#123;item.name&#125;</span><br><span class="line">  )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4、MyBatis-传递多个参数"><a href="#4、MyBatis-传递多个参数" class="headerlink" title="4、MyBatis 传递多个参数"></a>4、MyBatis 传递多个参数</h3><h4 id="方法一-使用map接口传递参数"><a href="#方法一-使用map接口传递参数" class="headerlink" title="方法一:使用map接口传递参数"></a>方法一:使用map接口传递参数</h4><p>map是一个键值对应的集合，使用者要通过阅读它的键，才能明了其作用；其次，使用map不能限定其传递的数据类型，因此业务性质不强，可读性差。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByMap</span><span class="params">(Map&lt;String, Object&gt; parameterMap)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByMap"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role where role_name like concat('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法二-使用注解传递多个参数"><a href="#方法二-使用注解传递多个参数" class="headerlink" title="方法二:使用注解传递多个参数"></a>方法二:使用注解传递多个参数</h4><p>注解 @Param 可以通过它去定义映射器的参数名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByAnnotation</span><span class="params">(@Param(<span class="string">"roleName"</span>)</span> String rolename, @<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByAnnotation"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role where role_name like concat('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法三-通过Java-Bean传递多个参数"><a href="#方法三-通过Java-Bean传递多个参数" class="headerlink" title="方法三:通过Java Bean传递多个参数"></a>方法三:通过Java Bean传递多个参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByBean</span><span class="params">(RoleParams roleParam)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByBean"</span> <span class="attr">parameterType</span>=<span class="string">"com.entity.RoleParams"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role where role_name like concat('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法四-混合使用"><a href="#方法四-混合使用" class="headerlink" title="方法四:混合使用　"></a>方法四:混合使用　</h4><p>不指定 parameterType ，需要指定具体的属性。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findByMix</span><span class="params">(@Param(<span class="string">"params"</span>)</span> RoleParams roleParams, @<span class="title">Param</span><span class="params">(<span class="string">"page"</span>)</span> PageParam PageParam)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByMix"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role</span><br><span class="line">    where role_name like concat('%', #&#123;params.roleName&#125;, '%') and note like concat('%', #&#123;params.note&#125;, '%') limit #&#123;page.start&#125;, #&#123;page.limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>当 n≤5 时，使用 @Param 注解传递多个参数；</li><li>当 n＞5 时，建议使用 Java Bean 方式；</li></ul><h3 id="5、数据库字段名和实体类属性名不一致的问题（驼峰匹配）"><a href="#5、数据库字段名和实体类属性名不一致的问题（驼峰匹配）" class="headerlink" title="5、数据库字段名和实体类属性名不一致的问题（驼峰匹配）"></a>5、数据库字段名和实体类属性名不一致的问题（驼峰匹配）</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>查询数据的时候，查不到 userName 的信息，原因：数据库的字段名是 user_name POJO中的属性名字是userName<br>两端不一致，造成mybatis无法填充对应的字段信息。修改方法：在sql语句中使用别名。</p><h4 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h4><p>开启驼峰匹配：相当于去掉数据库名字中的下划线，然后在与java中的属性名进行对应。</p><p>数据库中的 user_name 和 java 属性中的 userName 是一样的。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mybatis.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h4 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h4><p>resultType 类指定返回值的类型，这样 Mybatis 会帮我们自动映射属性，即只有当类的属性名和字段名相同时，才存在映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserList"</span> <span class="attr">resultType</span>=<span class="string">"com.entity.User"</span>&gt;</span></span><br><span class="line">    select * from user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果我们属性名和字段名不同那么我们就需要用 resultMap 来重新映射。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMapper"</span> <span class="attr">type</span>=<span class="string">"com.ariverh.pojo.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserList"</span> <span class="attr">resultMap</span>=<span class="string">"UserMapper"</span>&gt;</span></span><br><span class="line">    select id,name as userName from user;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br/><h2 id="MyBatis缓存机制"><a href="#MyBatis缓存机制" class="headerlink" title="MyBatis缓存机制"></a>MyBatis缓存机制</h2><h3 id="了解一下-1"><a href="#了解一下-1" class="headerlink" title="了解一下"></a>了解一下</h3><p>缓存机制减轻数据库压力，提高数据库性能</p><p>mybatis 的缓存分为两级：一级缓存、二级缓存</p><p>namespace 指定的是对应的 mapper 接口</p><h3 id="一级缓存："><a href="#一级缓存：" class="headerlink" title="一级缓存："></a>一级缓存：</h3><p>一级缓存为 <code>sqlsesson</code> 缓存，缓存的数据只在 SqlSession 内有效。在操作数据库的时候需要先创建 SqlSession 会话对象，在对象中有一个 HashMap 用于存储缓存数据，此 HashMap 是当前会话对象私有的，别的 SqlSession 会话对象无法访问。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/mybatis-sql-session-01.jpg" style="zoom: 50%;" /><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><p>第一次执行 select 完毕会将查到的数据写入 SqlSession 内的 HashMap 中缓存起来</p><p>第二次执行 select 会从缓存中查数据，如果 select 同传参数一样，那么就能从缓存中返回数据，不用去数据库了，从而提高了效率。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1、如果 SqlSession 执行了 DML 操作（insert、update、delete），并 commit 了，那么 mybatis 就会清空当前 SqlSession 缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现差异</p><p>2、当一个 SqlSession 结束后那么他里面的一级缓存也就不存在了， mybatis 默认是开启一级缓存，不需要配置</p><p>3、 mybatis 的缓存是基于 [namespace:sql语句:参数] 来进行缓存的，意思就是， SqlSession 的 HashMap 存储缓存数据时，是使用 [namespace:sql:参数] 作为 key ，查询返回的语句作为 value 保存的</p><p><strong>4、一级缓存只在数据库会话内部共享。</strong></p><h3 id="二级缓存："><a href="#二级缓存：" class="headerlink" title="二级缓存："></a>二级缓存：</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>在上文中提到的一级缓存中，其最大的共享范围就是一个 SqlSession 内部，如果多个 SqlSession 之间需要共享缓存，则需要使用到二级缓存。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/mybatis-sql-session-02.png" style="zoom: 80%;" /><h4 id="具体流程-1"><a href="#具体流程-1" class="headerlink" title="具体流程"></a>具体流程</h4><p>二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。</p><p>当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>MyBatis的二级缓存相对于一级缓存来说，实现了<code>SqlSession</code>之间缓存数据的共享，同时粒度更加的细，能够到<code>namespace</code>级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。</li><li>MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。</li><li>在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。</li></ol><br/><h2 id="MyBatis-面试一下"><a href="#MyBatis-面试一下" class="headerlink" title="MyBatis 面试一下"></a>MyBatis 面试一下</h2><h3 id="MyBatis-中-和-区别"><a href="#MyBatis-中-和-区别" class="headerlink" title="MyBatis 中#{}和${}区别"></a>MyBatis 中#{}和${}区别</h3><p><strong>#{}</strong> 是预编译处理，像传进来的数据会加个” “（#将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号）</p><p><strong>${}</strong> 就是字符串替换。直接替换掉占位符。$方式一般用于传入数据库对象。</p><p>所以为了防止 SQL 注入，能用 <strong>#{}</strong> 的不要去用 <strong>${}</strong></p><p>如果非要用 ${} 的话，那要注意防止 SQL 注入问题，可以手动判定传入的变量，进行过滤，一般 SQL 注入会输入很长的一条 SQL 语句</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 MyBatis&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/mybatis-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用久了 MyBatis 的逆向工程，原生的写法有点生疏了，趁着想起来赶紧复习一下！&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="MyBatis" scheme="https://codeyg.top/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--CurrentHashMap</title>
    <link href="https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--currentHashMap/"/>
    <id>https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--currentHashMap/</id>
    <published>2021-07-22T02:58:58.000Z</published>
    <updated>2021-07-22T04:20:44.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下  CurrentHashMap</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_09-35-56.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>使用 HashMap 如何保证线程安全？</font></p><p>答：1、使用锁（Synchronize）</p><p>​        2、使用 CurrentHashMap</p><p><font color=#008000>详细的说一下 CurrentHashMap 吧</font></p><p>好嘞~</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_10-10-25.png" alt=""></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><p>哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。</p><p>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</p><h4 id="2-链式哈希表"><a href="#2-链式哈希表" class="headerlink" title="2.链式哈希表"></a>2.链式哈希表</h4><p>链式哈希表从根本上说是由一组链表构成。每个链表都可以看做是一个“桶”，我们将所有的元素通过散列的方式放到具体的不同的桶中。</p><p>插入元素时，首先将其键传入一个哈希函数（该过程称为哈希键），函数通过散列的方式告知元素属于哪个“桶”，然后在相应的链表头插入元素。查找或删除元素时，用同们的方式先找到元素的“桶”，然后遍历相应的链表，直到发现我们想要的元素。因为每个“桶”都是一个链表，所以链式哈希表并不限制包含元素的个数。然而，如果表变得太大，它的性能将会降低。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_10-21-53.png" alt=""></p><center>哈希表的链表式结构</center><p><strong>3.应用场景</strong></p><p>缓存技术（比如redis、memcached）的核心其实就是在内存中维护一张巨大的哈希表，还有HashMap、CurrentHashMap… … </p><h3 id="ConcurrentHashMap与HashMap等的区别"><a href="#ConcurrentHashMap与HashMap等的区别" class="headerlink" title="ConcurrentHashMap与HashMap等的区别"></a>ConcurrentHashMap与HashMap等的区别</h3><h4 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h4><p>HashMap 是线程不安全的，在多线程环境下，使用 HasHmap 进行 put 操作会引起死循环，导致 CPU 利用率接近 100%，<strong>所以在并发情况下不能使用 HashMap。</strong></p><h4 id="2-HashTable"><a href="#2-HashTable" class="headerlink" title="2.HashTable"></a>2.HashTable</h4><p>HashTable和HashMap的实现原理几乎一样，差别无非是</p><ul><li><p>HashTable 不允许 key 和 value 为 null</p></li><li><p>HashTable 是线程安全的</p></li></ul><p>但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put 所有相关操作都是s ynchronized 的，这相当于<strong>给整个哈希表加了一把大锁。</strong></p><p>多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p><h4 id="3-ConcurrentHashMap"><a href="#3-ConcurrentHashMap" class="headerlink" title="3.ConcurrentHashMap"></a>3.ConcurrentHashMap</h4><p>ConcurrentHashMap 是为了解决 HashMap 在并发环境下不安全而诞生的。其大量的利用了 volatile，final，CAS 等 lock-free 技术来减少锁竞争对于性能的影响。</p><p><strong>ConcurrentHashMap 避免了对全局加锁改成了局部加锁操作</strong></p><h3 id="JDK1-7-版本的-CurrentHashMap-的实现原理"><a href="#JDK1-7-版本的-CurrentHashMap-的实现原理" class="headerlink" title="JDK1.7 版本的 CurrentHashMap 的实现原理"></a>JDK1.7 版本的 CurrentHashMap 的实现原理</h3><p>在JDK1.7中ConcurrentHashMap采用了<strong>数组+Segment+分段锁</strong>的方式实现。</p><h4 id="1-Segment-分段锁"><a href="#1-Segment-分段锁" class="headerlink" title="1.Segment(分段锁)"></a>1.Segment(分段锁)</h4><p>ConcurrentHashMap 中的<strong>分段锁称为 Segment</strong>，它即类似于 HashMap 的结构，即内部拥有一个 Entry 数组，数组中的每个元素又是一个链表,同时又是一个 ReentrantLock（Segment继承了ReentrantLock）。</p><h4 id="2-内部结构"><a href="#2-内部结构" class="headerlink" title="2.内部结构"></a>2.内部结构</h4><p>ConcurrentHashMap 使用分段锁技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，能够实现真正的并发访问。如下图是ConcurrentHashMap的内部结构图：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_10-50-44.png" alt=""></p><p>Segment 默认是<strong>16</strong>，按理说最多同时支持<strong>16</strong>个线程并发读写，但是是操作不同的 Segment，初始化时也可以指定 Segment 数量，每一个 Segment 都会有一把锁，保证线程安全。</p><h4 id="该结构的优劣势"><a href="#该结构的优劣势" class="headerlink" title="该结构的优劣势"></a>该结构的优劣势</h4><p><strong>坏处</strong>：是这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长。</p><p><strong>好处</strong>：是写操作的时候可以只对元素所在的 Segment 进行加锁即可，不会影响到其他的 Segment，在最理想的情况下，ConcurrentHashMap 可以最高同时支持 Segment 数量大小的写操作(刚好这些写操作都非常平均地分布在所有的Segment上)。</p><h3 id="JDK1-8-版本的-CurrentHashMap-的实现原理"><a href="#JDK1-8-版本的-CurrentHashMap-的实现原理" class="headerlink" title="JDK1.8 版本的 CurrentHashMap 的实现原理"></a>JDK1.8 版本的 CurrentHashMap 的实现原理</h3><h4 id="1-Node"><a href="#1-Node" class="headerlink" title="1.Node"></a>1.Node</h4><p><strong>Node</strong>：保存 key，value 及 key 的 hash 值的数据结构。其中 value 和 next 都用 volatile 修饰，保证并发的可见性。</p><h4 id="2-Table"><a href="#2-Table" class="headerlink" title="2.Table"></a>2.Table</h4><p><strong>Table</strong>：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储 Node 节点数据，扩容时大小总是 2 的幂次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2.实现方式"></a>2.实现方式</h4><p>JDK1.8 的 currentHashMap参考了 1.8HashMap 的实现方式,采用了<strong>数组+链表+红黑树</strong>的实现方式。其中大量的使用CAS操作。CAS (compare and swap)</p><p>JDK8 中彻底放弃了 Segment 转而采用的是 Node，其设计思想也不再是  JDK1.7 中的分段锁思想。</p><p>红黑树是一种性能非常好的二叉查找树，其查找性能为 <strong>O(logN)</strong>，早期完全采用链表结构时 Map 的查找时间复杂度为 <strong>O(N)</strong>。</p><h4 id="3-原理图"><a href="#3-原理图" class="headerlink" title="3.原理图"></a>3.原理图</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_11-41-51.png" alt=""></p><center>JDK8 中 currentHashMap 原理图</center><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="版本对比"><a href="#版本对比" class="headerlink" title="版本对比"></a>版本对比</h4><p><strong>JDK1.7版本</strong>：ReentrantLock + Segment + HashEntry，</p><p><strong>JDK1.8版本</strong>：Synchronized + CAS + Node + 红黑树</p><h4 id="原理对比（1-8-于-1-7）"><a href="#原理对比（1-8-于-1-7）" class="headerlink" title="原理对比（1.8 于 1.7）"></a>原理对比（1.8 于 1.7）</h4><p><strong>1.数据结构：</strong>取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p><strong>2.保证线程安全机制：</strong>JDK1.7 采用 segment 的分段锁机制实现线程安全，其中 segment 继承自 ReentrantLock。JDK1.8 采用 CAS + Synchronized 保证线程安全。</p><p><strong>3.锁的粒度：</strong>原来是对需要进行数据操作的 Segment 加锁，现调整为对每个数组元素加锁（Node）。</p><p><strong>4.链表转化为红黑树：</strong>定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p><p><strong>5.查询时间复杂度：</strong>从原来的遍历链表 O(n)，变成遍历红黑树 O(logN)。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下  CurrentHashMap&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_09-35-56.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;使用 HashMap 如何保证线程安全？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;答：1、使用锁（Synchronize）&lt;/p&gt;
&lt;p&gt;​        2、使用 CurrentHashMap&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;详细的说一下 CurrentHashMap 吧&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;好嘞~&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="currentHashMap" scheme="https://codeyg.top/tags/currentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Redis和MySQL数据一致性问题</title>
    <link href="https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-22T00:58:58.000Z</published>
    <updated>2021-07-24T17:52:51.995Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis 和 MySQL 数据一致性问题</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-53-11.png" alt=""></p><p><strong>写在前面</strong></p><p>对于Web来说，用户量和访问量增一定程度上推动项目技术和架构的更迭和进步。</p><p>当页面并发量和访问量并不多，MySQL<code>足以支撑</code>自己逻辑业务的发展。其实可以不加缓存，最多对静态页面进行缓存即可。</p><p><font color=#008000>什么时候需要缓存？</font></p><p>页面的并发量显著增多，数据库有些压力，并且有些数据更新频率较低<code>反复被查询</code>或者查询速度<code>较慢</code>。</p><p>对高命中的对象存到 Key-Value 形式的 Redis 中，那么，如果数据被命中，那么可以不经过效率很低的 DB。从高效的 Redis 中查找到数据。</p><p>虽然还能通过静态页面缓存页面、cdn加速、甚至负载均衡这些方法提高系统并发量，但是本片博客只是针对 Redis 缓存做讨论</p><a id="more"></a><h3 id="Redis-缓存的应用"><a href="#Redis-缓存的应用" class="headerlink" title="Redis 缓存的应用"></a>Redis 缓存的应用</h3><h4 id="不使用缓存的时候"><a href="#不使用缓存的时候" class="headerlink" title="不使用缓存的时候"></a>不使用缓存的时候</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-08-41.png"  /><hr><h4 id="缓存适用的高并发场景"><a href="#缓存适用的高并发场景" class="headerlink" title="缓存适用的高并发场景"></a>缓存适用的高并发场景</h4><p>缓存适用于高并发的场景，提升服务容量。</p><p>主要是将从经常被访问的数据或者查询成本较高从慢的介质中存到比较快的介质中，比如从硬盘—&gt;内存。</p><p>大多数关系数据库是基于硬盘读写的，其效率和资源有限，而 redis 是基于内存的，其读写速度差别差别很大。当并发过高关系数据库性能达到瓶颈时候，就可以策略性将常访问数据放到 redis 提高系统吞吐和并发量。</p><h5 id="常用网站为什么会响应慢？"><a href="#常用网站为什么会响应慢？" class="headerlink" title="常用网站为什么会响应慢？"></a>常用网站为什么会响应慢？</h5><p>对于常用网站和场景，关系数据库主要可能慢在两个地方：</p><ul><li>读写IO性能较差</li><li>一个数据可能通过较大量计算得到</li></ul><blockquote><p>所以使用缓存能够减少磁盘IO次数和关系数据库的计算次数</p></blockquote><p><strong>体现：</strong></p><ul><li>基于内存，读写较快</li><li>使用哈希算法直接定位结果不需要计算</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-24-18.png"  /><hr><h3 id="Redis-缓存需要注意的问题"><a href="#Redis-缓存需要注意的问题" class="headerlink" title="Redis 缓存需要注意的问题"></a>Redis 缓存需要注意的问题</h3><p>缓存使用不当会带来很多问题，所以需要对一些细节进行认真考量和设计。</p><p><font color=#FF8C00>最难的数据一致性！</font></p><h4 id="是否用缓存"><a href="#是否用缓存" class="headerlink" title="是否用缓存"></a>是否用缓存</h4><p>项目不能为了用缓存而用缓存，缓存并一定适合所有场景！</p><p>如果对<strong>数据一致性要求极高</strong>，又或者<strong>数据频繁更改而查询并不多</strong>，又或者根本没并发量的、查询简单的不一定需要缓存，还可能浪费资源使得项目变得臃肿难维护。</p><h4 id="过期策略选择"><a href="#过期策略选择" class="headerlink" title="过期策略选择"></a>过期策略选择</h4><p>缓存装的是相对热点和常用的数据，redis 资源也是有限，需要选择一个合理的策略让缓存过期删除，根据时间来的 FIFO 是最好实现的。且 redis 在全局 key 支持过期策略。</p><p>并且过期时间也要根据系统情况合理设置，如果硬件好点当前可以稍微久一点，但是过期时间过久或者过短可能都不太好，过短可能缓存命中率不高，而过久很可能造成很多冷门数据存储在Redis中不释放。</p><h3 id="Redis-缓存数据一致性问题"><a href="#Redis-缓存数据一致性问题" class="headerlink" title="Redis 缓存数据一致性问题"></a>Redis 缓存数据一致性问题</h3><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p><code>read</code>：从 redis 中读取，如果 redis 中没有，那么就从 MySQL 中获取更新 redis 缓存。 </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-37-06.png" alt=""></p><hr><h4 id="写数据-【先更新数据库，再更新缓存-普通低并发-】"><a href="#写数据-【先更新数据库，再更新缓存-普通低并发-】" class="headerlink" title="写数据 【先更新数据库，再更新缓存(普通低并发)】"></a>写数据 【先更新数据库，再更新缓存(普通低并发)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-49-00.png" alt=""></p><p>先更新数据库信息，再更新Redis缓存。这是常规做法，缓存基于数据库，取自数据库。</p><p>但是其中可能遇到一些问题，例如上述如果更新缓存失败(宕机等其他状况)，将会使得数据库和 redis 数据不一致。<font color=#FF0000>造成 DB 新数据，缓存旧数据</font></p><hr><h4 id="写数据-【先删除缓存，再写入数据库-低并发优化-】"><a href="#写数据-【先删除缓存，再写入数据库-低并发优化-】" class="headerlink" title="写数据 【先删除缓存，再写入数据库(低并发优化)】"></a>写数据 【先删除缓存，再写入数据库(低并发优化)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-04-31.png" alt=""></p><p>这种情况能够有效避免【先更新数据库，再更新缓存】中防止写入 redis 失败的问题。将缓存删除进行更新。理想是让下次访问 redis 为空去 mysql 取得最新值到缓存中。但是这种情况仅限于低并发的场景中而不适用高并发场景!</p><p><strong>存在的问题</strong></p><p>我们在【先更新数据库，再更新缓存】讨论过如果更新库成功，缓存更新失败会导致脏数据。我们理想是删除缓存让下一个线程访问适合更新缓存。问题是：如果这下一个线程来的太早呢？</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-11-16.png" alt=""></p><p>因为在多线的情况下，无法保证那条线程优先执行。</p><p>将会出现 redis 缓存数据和 mysql 不一致</p><p><font color=#FF0000>高并发下依然会造成缓存是旧数据，DB 是新数据</font></p><hr><h4 id="写数据【延时双删策略】"><a href="#写数据【延时双删策略】" class="headerlink" title="写数据【延时双删策略】"></a>写数据【延时双删策略】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-23-14.png" alt=""></p><p>能过缓解在【先删除缓存，再写入数据库】中在更新MySQL过程中有读的线程进入造成Redis缓存与MySQL数据不一致。</p><p>方法就是 <font color=#FF0000>删除缓存</font>-&gt;<font color=#008000>更新缓存</font>-&gt;<font color=#FF0000>延时【几百ms，可异步】再次删除缓存</font></p><p><strong>存在的问题</strong></p><p>第二次删除错误、多写多读高并发情况下对MySQL访问的压力等等，当然你可以选择用MQ等消息队列异步解决。</p><hr><h4 id="写数据【直接操作缓存，定期写入sql-适合高并发-】"><a href="#写数据【直接操作缓存，定期写入sql-适合高并发-】" class="headerlink" title="写数据【直接操作缓存，定期写入sql(适合高并发)】"></a>写数据【直接操作缓存，定期写入sql(适合高并发)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-34-36.png" alt=""></p><p>直接操作缓存，将缓存定期写入sql。</p><p>因为 redis 这种非关系数据库又基于内存操作 KV 相比传统关系型要快很多！</p><p><strong>异步更新缓存(基于订阅 binlog 的同步机制)</strong></p><p><strong>技术整体思路：</strong></p><p>MySQL binlog 增量订阅消费 + 消息队列 + 增量数据更新到 redis</p><ul><li><strong>读Redis</strong>：热数据基本都在 redis</li><li><strong>写MySQL</strong>：增删改都是操作 mysql</li><li><strong>更新Redis数据</strong>：mysql 的数据操作 binlog，来更新到 redis</li></ul><p><strong>数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到 redis)</li><li>一个是增量（实时更新）</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis 和 MySQL 数据一致性问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-53-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于Web来说，用户量和访问量增一定程度上推动项目技术和架构的更迭和进步。&lt;/p&gt;
&lt;p&gt;当页面并发量和访问量并不多，MySQL&lt;code&gt;足以支撑&lt;/code&gt;自己逻辑业务的发展。其实可以不加缓存，最多对静态页面进行缓存即可。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么时候需要缓存？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;页面的并发量显著增多，数据库有些压力，并且有些数据更新频率较低&lt;code&gt;反复被查询&lt;/code&gt;或者查询速度&lt;code&gt;较慢&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对高命中的对象存到 Key-Value 形式的 Redis 中，那么，如果数据被命中，那么可以不经过效率很低的 DB。从高效的 Redis 中查找到数据。&lt;/p&gt;
&lt;p&gt;虽然还能通过静态页面缓存页面、cdn加速、甚至负载均衡这些方法提高系统并发量，但是本片博客只是针对 Redis 缓存做讨论&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Spring 循环依赖以及三级缓存</title>
    <link href="https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2021-07-21T01:00:00.000Z</published>
    <updated>2021-07-22T01:38:31.599Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Spring 循环依赖以及三级缓存</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-45-33.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>什么是循环依赖？</font></p><p>简单的说就是 A 依赖 B，B 依赖 A 这样就构成了循环依赖。</p><p><font color=#008000>具体说一说 spring 是如何解决循环依赖的吧</font></p><p>让我好好想一想……</p><a id="more"></a><h3 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h3><p>所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。</p><p>举个图解荔枝：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_22-16-10.png" style="zoom:90%;" /><p>举个代码荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanA"</span> <span class="attr">class</span>=<span class="string">"com.ase.BeanA"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanB"</span> <span class="attr">ref</span>=<span class="string">"beanB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanB"</span> <span class="attr">class</span>=<span class="string">"com.ase.BeanB"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanA"</span> <span class="attr">ref</span>=<span class="string">"beanA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照上面的例子，Spring 启动后，读取如上的配置文件，会按顺序先实例化 A，但是创建的时候又发现它依赖了 B，接着就去实例化 B ，同样又发现它依赖了 A ，从而导致了无限循环，淦！</p><p><strong>尝试思考</strong></p><p>Spring 实例化对象分两步：</p><p>第一步，会先创建一个原始对象，只是没有设置属性，可以理解为”半成品”—— 官方叫 A 对象的早期引用（EarlyBeanReference）；</p><p>第二步，当实例化 B 的时候发现依赖了 A， B 就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了，这其实就是 Spring 解决循环依赖的思想；</p><hr><h3 id="循环依赖发生的时机"><a href="#循环依赖发生的时机" class="headerlink" title="循环依赖发生的时机"></a>循环依赖发生的时机</h3><h4 id="Bean-实例化"><a href="#Bean-实例化" class="headerlink" title="Bean 实例化"></a>Bean 实例化</h4><p>主要分为三步，如图：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_22-33-22.png" style="zoom:80%;" /><p>问题出现在：第一步和第二步的过程中，也就是填充属性 / 方法的过程中</p><h4 id="Spring-如何解决的"><a href="#Spring-如何解决的" class="headerlink" title="Spring 如何解决的"></a>Spring 如何解决的</h4><ul><li>Spring 为了解决单例的循环依赖问题，使用了 <strong>三级缓存</strong> ，递归调用时发现 Bean 还在创建中即为循环依赖</li><li>单例模式的 Bean 保存在如下的数据结构中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 二级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 三级级缓存：存放 bean 工厂对象，用于解决循环依赖 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">bean 的获取过程：先从一级获取，失败再从二级、三级里面获取</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">创建中状态：是指对象已经 new 出来了但是所有的属性均为 null 等待被 init</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的 Bean，直接可以使用。</li><li>二级缓存：earlySingletonObjects，存放早期 Bean 的引用，尚未属性装配的 Bean</li><li>三级缓存：singletonFactories，三级缓存，存放实例化完成的 Bean工厂。</li></ul><h4 id="循环依赖的解决流程图"><a href="#循环依赖的解决流程图" class="headerlink" title="循环依赖的解决流程图"></a>循环依赖的解决流程图</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-13-55.png" alt=""></p><hr><h4 id="A、B-相互依赖"><a href="#A、B-相互依赖" class="headerlink" title="A、B 相互依赖"></a>A、B 相互依赖</h4><p>检测循环依赖的过程如下：</p><ul><li><p>A 创建过程中需要 B，于是 <strong>A 将自己放到三级缓里面</strong> ，去实例化 B</p></li><li><p>B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了</p><ul><li><strong>然后把三级缓存里面的这个 A 放到二级缓存里面，并删除三级缓存里面的 A</strong></li><li>B 顺利初始化完毕，<strong>将自己放到一级缓存里面</strong>（此时B里面的A依然是创建中状态）</li></ul></li><li><p>然后回来接着创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B ，然后完成创建，<strong>并将自己放到一级缓存里面</strong></p></li><li><p>如此一来便解决了循环依赖的问题</p></li></ul><p><strong>总结</strong></p><p>先让最底层对象完成初始化，通过三级缓存与二级缓存提前曝光创建中的 Bean，让其他 Bean 率先完成初始化。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><font color=#FF8C00>Spring 还是有一些无法解决的循环依赖！</font></p><p>使用构造器注入其他 Bean 的实例，这个就没办法了，要手动改代码。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Spring 循环依赖以及三级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-45-33.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是循环依赖？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;简单的说就是 A 依赖 B，B 依赖 A 这样就构成了循环依赖。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;具体说一说 spring 是如何解决循环依赖的吧&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;让我好好想一想……&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="Spring" scheme="https://codeyg.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Redis 五种数据结构详解</title>
    <link href="https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Redis%205%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Redis%205%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-07-21T00:08:08.000Z</published>
    <updated>2021-07-22T01:38:50.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis 的五种数据结构</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-42-43.png" alt=""></p><p><strong>写在前面</strong></p><p>Redis 是基于 C 语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件。</p><p>Redis 的五种数据结构详解，包括这五种的数据结构的底层原理实现。</p><a id="more"></a><h4 id="Redis的五种数据结构"><a href="#Redis的五种数据结构" class="headerlink" title="Redis的五种数据结构"></a>Redis的五种数据结构</h4><ol><li><code>String</code>：字符串类型</li><li><code>List</code>：列表类型</li><li><code>Set</code>：无序集合类型</li><li><code>ZSet</code>：有序集合类型</li><li><code>Hash</code>：哈希表类型</li></ol><h4 id="Redis核心对象"><a href="#Redis核心对象" class="headerlink" title="Redis核心对象"></a>Redis核心对象</h4><p>在Redis中有一个<strong>「核心的对象」</strong>叫做 <code>redisObject</code> ，是用来表示所有的 key 和 value 的，用 redisObject 结构体来表示<code>String、Hash、List、Set、ZSet</code>五种数据类型。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_09-28-52.png" alt=""></p><p>在redisObject中<strong>「type表示属于哪种数据类型，encoding表示该数据的存储方式」</strong>，也就是底层的实现的该数据类型的数据结构。</p><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>redis 中的字符串和 c 语言中的字符串类型却是有明显的区别。</p><p>string 类型的数据结构存储方式有三种<code>int、raw、embstr</code>。</p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis 的五种数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-42-43.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 是基于 C 语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件。&lt;/p&gt;
&lt;p&gt;Redis 的五种数据结构详解，包括这五种的数据结构的底层原理实现。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--MySQL 存储引擎</title>
    <link href="https://codeyg.top/2021/07/19/%E9%9D%A2%E8%AF%95--MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://codeyg.top/2021/07/19/%E9%9D%A2%E8%AF%95--MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-07-19T13:58:58.000Z</published>
    <updated>2021-07-22T01:38:18.330Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 MySQL 存储引擎</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_00-12-04.png" alt=""></p><p><strong>写在前面</strong></p><p>本文依照数据库 5.7 来描述滴~</p><p><font color=#008000>明确一点：</font></p><p>数据库实例（instance）才是真正用于操作数据库文件的。</p><p>MySQL 是一个单进程、多线程架构的数据库；</p><p>在集群的情况下，一个数据库对应对个数据库实例。</p><a id="more"></a><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>数据库：由一个个文件组成（二进制）</p><p>数据库实例：执行类似于（Insert、Update、Delete）来更改数据库的内容</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>Atomicity（原子性）</li><li>Consistency（一致性）</li><li>Isolation（隔离性）</li><li>Durability（持久性）</li></ul><br/><h3 id="MySQL-存储引擎对比"><a href="#MySQL-存储引擎对比" class="headerlink" title="MySQL 存储引擎对比"></a>MySQL 存储引擎对比</h3><table><thead><tr><th align="center">特点</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">批量插入的速度</td><td align="center">高</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center"><font color=#008000>事务安全</font></td><td align="center">-</td><td align="center"><font color=#008000>支持</font></td><td align="center">-</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td><td align="center">不支持</td></tr><tr><td align="center"><font color=#008000>锁机制</font></td><td align="center"><font color=#008000>表锁</font></td><td align="center"><font color=#008000>行锁</font></td><td align="center"><font color=#008000>表锁</font></td></tr><tr><td align="center">存储限制</td><td align="center">256 TB</td><td align="center">64 T</td><td align="center">RAM</td></tr><tr><td align="center">B 树索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">哈希索引</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">集群索引</td><td align="center">-</td><td align="center">支持</td><td align="center">-</td></tr><tr><td align="center">数据缓存</td><td align="center">-</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">索引缓存</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">数据可压缩</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">空间使用</td><td align="center">低</td><td align="center">高</td><td align="center">N/A</td></tr><tr><td align="center"><font color=#008000>内存使用</font></td><td align="center"><font color=#008000>低</font></td><td align="center"><font color=#008000>高</font></td><td align="center"><font color=#008000>中</font></td></tr><tr><td align="center"><font color=#008000>支持外键</font></td><td align="center"><font color=#008000>不支持</font></td><td align="center"><font color=#008000>支持</font></td><td align="center"><font color=#008000>不支持</font></td></tr></tbody></table><hr><h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><h4 id="MySQL-插件式存储引擎概念"><a href="#MySQL-插件式存储引擎概念" class="headerlink" title="MySQL 插件式存储引擎概念"></a>MySQL 插件式存储引擎概念</h4><p><strong>MySQL 存储引擎（核心）</strong></p><p><font color=#FF8C00>存储引擎是基于表的，而不是数据库</font></p><p><strong>MySQL 默认存储引擎</strong></p><p>使用下面的语句可以修改数据库临时的默认存储引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET default_storage_engine &#x3D; &lt;存储引擎名&gt;</span><br></pre></td></tr></table></figure><p>但是当再次重启客户端时，默认存储引擎仍然是 InnoDB</p><h3 id="表锁概念"><a href="#表锁概念" class="headerlink" title="表锁概念"></a>表锁概念</h3><h4 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h4><p>在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，</p><p>行锁则无法实现，取而代之的是表锁。</p><p><strong>表锁</strong>：不会出现死锁，发生锁冲突几率高，并发低。</p><p><strong>行锁：</strong>会出现死锁，发生锁冲突几率低，并发高。</p><p><strong>锁冲突：</strong>例如说事务A将某几行上锁后，事务B又对其上锁，锁不能共存否则会出现锁冲突。<strong>（但是共享锁可以共存，共享锁和排它锁不能共存，排它锁和排他锁也不可以）</strong></p><p><strong>死锁：</strong>例如说两个事务，事务A锁住了1-5行，同时事务B锁住了6-10行，此时事务A请求锁住6-10行，就会阻塞直到事务B施放6-10行的锁，而随后事务B又请求锁住1-5行，事务B也阻塞直到事务A释放1-5行的锁。死锁发生时，会产生 Deadlock 错误。</p><p><font color=#FF8C00>锁是对表操作的，所以自然锁住全表的表锁就不会出现死锁</font></p><h4 id="行锁的类型"><a href="#行锁的类型" class="headerlink" title="行锁的类型"></a>行锁的类型</h4><p>行锁分 共享锁 和 排它锁</p><p>共享锁：</p><p>又称读锁，当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁。</p><p>排它锁：</p><p>又称写锁，当一个事务对某几个上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁。包括写锁。</p><p>举个荔枝：</p><p>上共享锁的写法：<font color=#008000>lock in share mode</font> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  math from results where math &gt; 60 lock in share mode；</span><br></pre></td></tr></table></figure><p>上排它锁的写法：<font color=#008000>for update</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select math from results where math &gt; 60 for update</span><br></pre></td></tr></table></figure><h4 id="行锁的实现"><a href="#行锁的实现" class="headerlink" title="行锁的实现"></a>行锁的实现</h4><ol><li><p>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</p></li><li><p>两个事务不能锁同一个索引，例如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 事务A先执行：</span><br><span class="line">select math from results where math &gt; 60 for update;</span><br><span class="line"> </span><br><span class="line"># 事务B再执行：</span><br><span class="line">select math from results where math &lt; 60 for update；</span><br><span class="line"># 这样的话，事务 B 是会阻塞的。如果事务 B 把 math 索引换成其他索引就不会阻塞，</span><br><span class="line"># 但注意，换成其他索引锁住的行不能和 math 索引锁住的行有重复。</span><br></pre></td></tr></table></figure><br/><h3 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h3><p><font color=#FF8C00>5.8版本后的默认存储引擎</font></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>支持事务的安装</li><li>灾难恢复型好</li><li>使用行级锁</li><li>实现了缓冲处理</li><li>支持外键</li><li>适合大型的数据库网站</li></ol><br/><h3 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h3><p><font color=#FF8C00>5.8版本的默认存储引擎</font></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li>支持全文索引</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li><p>不支持事务</p></li><li><p>不支持行锁</p></li></ol><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>MYD 和 MYI</p><p>其缓冲池中只存索引文件，而不是缓冲数据文件；</p><ul><li>MYD：用来存放数据文件（Date）</li><li>MYI：用来存放索引文件（Index）</li></ul><p>5.0 版本前：默认支持表的大小为 4 GB；</p><p>5.0 版本时：默认支持表的大小为 256 TB；</p><br/><h3 id="Memory-存储引擎"><a href="#Memory-存储引擎" class="headerlink" title="Memory 存储引擎"></a>Memory 存储引擎</h3><p>将表中的数据存放在内存当中，一旦数据库重新启动或者崩溃，则表中的数据都将消失。</p><p>适合用于存储临时数据的临时表。</p><p>默认使用的是哈希索引而不是 B+ 树索引；</p><p>只支持表锁，不支持 text 和 blob 列类型。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 MySQL 存储引擎&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_00-12-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文依照数据库 5.7 来描述滴~&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;明确一点：&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;数据库实例（instance）才是真正用于操作数据库文件的。&lt;/p&gt;
&lt;p&gt;MySQL 是一个单进程、多线程架构的数据库；&lt;/p&gt;
&lt;p&gt;在集群的情况下，一个数据库对应对个数据库实例。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="MySQL 存储引擎" scheme="https://codeyg.top/tags/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>jdk8新特性--stream</title>
    <link href="https://codeyg.top/2021/07/17/jdk8%E6%96%B0%E7%89%B9%E6%80%A7--stream/"/>
    <id>https://codeyg.top/2021/07/17/jdk8%E6%96%B0%E7%89%B9%E6%80%A7--stream/</id>
    <published>2021-07-17T14:58:58.000Z</published>
    <updated>2021-07-18T21:29:24.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p>jdk1.8新特性知识点：</p><p><strong>Lambda 表达式、函数式接口、方法引用和构造器调用、Stream API、接口中的默认方法和静态方法、新时间日期 API</strong></p><p><strong>本篇着重介绍一下 stream 流</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-29-30.png" alt=""></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><font color=#008000>什么是 stream 流？</font></p><p>Java8 中，Collection 新增了两个流方法，分别是 Stream() 和 parallelStream()</p><p>Java8 中添加了一个新的接口类 Stream，相当于高级版的 Iterator，它可以通过 Lambda 表达式对集合进行大批量数据操作，或 者各种非常便利、高效的聚合数据操作。</p><p>Stream 将要处理的元素集合看作一种流，在流的过程中，借助 Stream API 对流中的元素进行操作，比如：筛选、排序、聚合等。</p><p><font color=#008000>jdk8 为什么要引入 stream 流？</font></p><p>在 Java8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。</p><p><font color=#6AAFE6>流不存储数据</font></p><a id="more"></a><h3 id="stream-概述"><a href="#stream-概述" class="headerlink" title="stream 概述"></a>stream 概述</h3><p>Stream可以由数组或集合创建，对流的操作分为两种：</p><ol><li>中间操作，每次返回一个新的流，可以有多个。</li><li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li></ol><p>另外，Stream有几个特性：</p><ol><li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ol><p>stream 是元素的集合，这点让 stream 看起来用些类似 Iterator</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_00-46-42.png" alt=""></p><br/><h3 id="stream-的创建"><a href="#stream-的创建" class="headerlink" title="stream 的创建"></a>stream 的创建</h3><h4 id="通过集合数组创建"><a href="#通过集合数组创建" class="headerlink" title="通过集合数组创建"></a>通过集合数组创建</h4><ol><li><p>通过 java.util.Collection.stream() 方法用集合创建流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// 创建一个顺序流</span></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">// 创建一个并行流</span></span><br><span class="line">        Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>使用 java.util.Arrays.stream(T[] array) 方法用数组创建流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        IntStream stream = Arrays.stream(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>使用 Stream 的静态方法：of()、iterate()、generate()</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">        stream3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><br/><h4 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream 和 parallelStream"></a>stream 和 parallelStream</h4><p><font color=#008000>stream</font> 是顺序流，由主线程按顺序对流执行操作</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_23-56-01.png" style="zoom:70%;" /><p><font color=#008000>parallelStream</font> 并行流就是一个把内容分成多个数据块，并用不不同的线程分别处理每个数据块的流。最后合并每个数据块的计算结果</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_23-56-15.png" style="zoom:70%;" /><p>如果流中的数据量足够大，并行流可以加快处速度。</p><p>除了直接创建并行流，还可以通过<code>parallel()</code>把顺序流转换成并行流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parallelSum = "</span> + parallelSum(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>).limit(n).parallel().reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="stream-的使用"><a href="#stream-的使用" class="headerlink" title="stream 的使用"></a>stream 的使用</h3><p>在使用 stream 之前，先看一下：<code>Optional</code></p><p><code>Optional</code>类是一个可以为<code>null</code>的容器对象。如果值存在则<code>isPresent()</code>方法会返回<code>true</code>，调用<code>get()</code>方法会返回该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+        +--------+     +--------+     +-----+     +---------+</span><br><span class="line">| stream of elements + -----&gt; | filter + --&gt; | sorted + --&gt; | map + --&gt; | collect |</span><br><span class="line">+--------------------+        +--------+     +--------+     +-----+     +---------+</span><br></pre></td></tr></table></figure><p><strong>stream（图示）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-23-04.png" alt=""></p><hr><p><strong>stream–collect（图示）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-23-39.png" alt=""></p><hr><h4 id="遍历-匹配（foreach-find-match）"><a href="#遍历-匹配（foreach-find-match）" class="headerlink" title="遍历/匹配（foreach/find/match）"></a>遍历/匹配（foreach/find/match）</h4><p><code>Stream</code>也是支持类似集合的遍历和匹配元素的，只是<code>Stream</code>中的元素是以<code>Optional</code>类型存在的。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-39-44.png" style="zoom:80%;" /><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输出符合条件的元素</span></span><br><span class="line">        list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 匹配第一个</span></span><br><span class="line">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">        <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">        <span class="comment">// 是否包含符合特定条件的元素</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(x -&gt; x &lt; <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"匹配第一个值："</span> + findFirst.get());</span><br><span class="line">        System.out.println(<span class="string">"匹配任意一个值："</span> + findAny.get());</span><br><span class="line">        System.out.println(<span class="string">"是否存在大于6的值："</span> + anyMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="筛选（filter）"><a href="#筛选（filter）" class="headerlink" title="筛选（filter）"></a>筛选（filter）</h4><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-40-26.png" style="zoom:80%;" /><p>举个荔枝：</p><p>筛选出<code>Integer</code>集合中大于7的元素，并打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.filter(x -&gt; x &gt; <span class="number">7</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a>聚合（max/min/count)</h4><p><code>max</code>、<code>min</code>、<code>count</code>这些字眼在 mysql 中我们常用它们进行数据统计。</p><p>java stream 中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-46-58.png" style="zoom:80%;" /><p>举个荔枝：</p><p>获取<code>String</code>集合中最长的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"adnm"</span>, <span class="string">"admmt"</span>, <span class="string">"pot"</span>, <span class="string">"xbangd"</span>, <span class="string">"weoujgsd"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">        System.out.println(<span class="string">"最长的字符串："</span> + max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个荔枝：</p><p>获取Integer集合中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自然排序</span></span><br><span class="line">        Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">        <span class="comment">// 自定义排序</span></span><br><span class="line">        Optional&lt;Integer&gt; max2 = list.stream().max((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">        System.out.println(<span class="string">"自然排序的最大值："</span> + max.get());</span><br><span class="line">        System.out.println(<span class="string">"自定义排序的最大值："</span> + max2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="映射（map-flatMap）"><a href="#映射（map-flatMap）" class="headerlink" title="映射（map / flatMap）"></a>映射（map / flatMap）</h4><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中</p><p>分为<code>map</code>和<code>flatMap</code>：</p><ul><li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-29-38.png" style="zoom:80%;" /><ul><li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-30-15.png" style="zoom:80%;" /><p>举个荔枝：</p><p>英文字符串数组的元素全部改为大写、整数数组每个元素+3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] strArr = &#123; <span class="string">"abcd"</span>, <span class="string">"bcdd"</span>, <span class="string">"defde"</span>, <span class="string">"fTr"</span> &#125;;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">        List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每个元素大写："</span> + strList);</span><br><span class="line">        System.out.println(<span class="string">"每个元素+3："</span> + intListNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个荔枝：</p><p>将两个字符数组合并成一个新的字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"m,k,l,a"</span>, <span class="string">"1,3,5,7"</span>);</span><br><span class="line">        List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">            String[] split = s.split(<span class="string">","</span>);</span><br><span class="line">            Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">            <span class="keyword">return</span> s2;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"处理前的集合："</span> + list);</span><br><span class="line">        System.out.println(<span class="string">"处理后的集合："</span> + listNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="归约（reduce）"><a href="#归约（reduce）" class="headerlink" title="归约（reduce）"></a>归约（reduce）</h4><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-52-43.png" style="zoom:80%;" /><p>举个荔枝：</p><p>求<code>Integer</code>集合的元素之和、乘积和最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 求和方式1</span></span><br><span class="line">        Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">        <span class="comment">// 求和方式2</span></span><br><span class="line">        Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class="line">        <span class="comment">// 求和方式3</span></span><br><span class="line">        Integer sum3 = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求乘积</span></span><br><span class="line">        Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大值方式1</span></span><br><span class="line">        Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">        <span class="comment">// 求最大值写法2</span></span><br><span class="line">        Integer max2 = list.stream().reduce(<span class="number">1</span>, Integer::max);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list求和："</span> + sum.get() + <span class="string">","</span> + sum2.get() + <span class="string">","</span> + sum3);</span><br><span class="line">        System.out.println(<span class="string">"list求积："</span> + product.get());</span><br><span class="line">        System.out.println(<span class="string">"list求和："</span> + max.get() + <span class="string">","</span> + max2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="收集（collect）"><a href="#收集（collect）" class="headerlink" title="收集（collect）"></a>收集（collect）</h4><p><code>collect</code>，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合</p><blockquote><p><code>collect</code>主要依赖<code>java.util.stream.Collectors</code>类内置的静态方法</p></blockquote><h5 id="归集（toList-toSet-toMap）"><a href="#归集（toList-toSet-toMap）" class="headerlink" title="归集（toList/toSet/toMap）"></a>归集（toList/toSet/toMap）</h5><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里</p><p><code>toList</code>、<code>toSet</code>和<code>toMap</code>：</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">        List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">        Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Anni"</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="number">8000</span>)</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">        System.out.println(<span class="string">"toList:"</span> + listNew);</span><br><span class="line">        System.out.println(<span class="string">"toSet:"</span> + set);</span><br><span class="line">        System.out.println(<span class="string">"toMap:"</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toList:[<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line">toSet:[<span class="number">4</span>, <span class="number">20</span>, <span class="number">6</span>]</span><br><span class="line">toMap:&#123;Tom=Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">23</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Anni=Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">24</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="统计（count-averaging）"><a href="#统计（count-averaging）" class="headerlink" title="统计（count/averaging）"></a>统计（count/averaging）</h5><p>Collectors提供了一系列用于数据统计的静态方法：</p><ul><li>计数：count</li><li>平均值：averagingInt、averagingLong、averagingDouble</li><li>最值：maxBy、minBy</li><li>求和：summingInt、summingLong、summingDouble</li><li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li></ul><p>举个荔枝：</p><p>统计员工人数、平均工资、工资总额、最高工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求总数</span></span><br><span class="line">        Long count = personList.stream().collect(Collectors.counting());</span><br><span class="line">        <span class="comment">// 求平均工资</span></span><br><span class="line">        Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line">        <span class="comment">// 求最高工资</span></span><br><span class="line">        Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">        <span class="comment">// 求工资之和</span></span><br><span class="line">        Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">        <span class="comment">// 一次性统计所有信息</span></span><br><span class="line">        DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"员工总数："</span> + count);</span><br><span class="line">        System.out.println(<span class="string">"员工平均工资："</span> + average);</span><br><span class="line">        System.out.println(<span class="string">"员工工资总和："</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">"员工工资所有统计："</span> + collect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">员工总数：<span class="number">3</span></span><br><span class="line">员工平均工资：<span class="number">7900.0</span></span><br><span class="line">员工工资总和：<span class="number">23700</span></span><br><span class="line">员工工资所有统计：DoubleSummaryStatistics&#123;count=<span class="number">3</span>, sum=<span class="number">23700.000000</span>, min=<span class="number">7000.000000</span>, average=<span class="number">7900.000000</span>, max=<span class="number">8900.000000</span>&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="分组（partitioningBy-groupingBy）"><a href="#分组（partitioningBy-groupingBy）" class="headerlink" title="分组（partitioningBy/groupingBy）"></a>分组（partitioningBy/groupingBy）</h5><ul><li>分区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li><li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_03-54-51.png" alt=""></p><p>举个荔枝：</p><p>将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Anni"</span>, <span class="number">8200</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Owen"</span>, <span class="number">9500</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Alisa"</span>, <span class="number">7900</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将员工按薪资是否高于8000分组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="number">8000</span>));</span><br><span class="line">        <span class="comment">// 将员工按性别分组</span></span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line">        <span class="comment">// 将员工先按性别分组，再按地区分组</span></span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class="line">        System.out.println(<span class="string">"员工按薪资是否大于8000分组情况："</span> + part);</span><br><span class="line">        System.out.println(<span class="string">"员工按性别分组情况："</span> + group);</span><br><span class="line">        System.out.println(<span class="string">"员工按性别、地区："</span> + group2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">员工按薪资是否大于<span class="number">8000</span>分组情况：&#123;<span class="keyword">false</span>=[Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], <span class="keyword">true</span>=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;]&#125;</span><br><span class="line">员工按性别分组情况：&#123;female=[Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], male=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;]&#125;</span><br><span class="line">员工按性别、地区：&#123;female=&#123;New York=[Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], Washington=[Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;]&#125;, male=&#123;New York=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;], Washington=[Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="接合（joining）"><a href="#接合（joining）" class="headerlink" title="接合（joining）"></a>接合（joining）</h5><p><code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        String names = personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">        System.out.println(<span class="string">"所有员工的姓名："</span> + names);</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        String string = list.stream().collect(Collectors.joining(<span class="string">"-"</span>));</span><br><span class="line">        System.out.println(<span class="string">"拼接后的字符串："</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有员工的姓名：Tom,Jack,Lily</span><br><span class="line">拼接后的字符串：A-B-C</span><br></pre></td></tr></table></figure><hr><h5 id="归约（reduce）-1"><a href="#归约（reduce）-1" class="headerlink" title="归约（reduce）"></a>归约（reduce）</h5><p><code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个员工减去起征点后的薪资之和</span></span><br><span class="line">        Integer sum = personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; (i + j - <span class="number">5000</span>)));</span><br><span class="line">        System.out.println(<span class="string">"员工扣税薪资总和："</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stream的reduce</span></span><br><span class="line">        Optional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">"员工薪资总和："</span> + sum2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">员工扣税薪资总和：<span class="number">8700</span></span><br><span class="line">员工薪资总和：<span class="number">23700</span></span><br></pre></td></tr></table></figure><hr><h4 id="排序（sorted）"><a href="#排序（sorted）" class="headerlink" title="排序（sorted）"></a>排序（sorted）</h4><p>有两种排序：</p><ul><li>sorted()：自然排序，流中元素需实现 Comparable 接口</li><li>sorted (Comparator com)：Comparator 排序器自定义排序</li></ul><p>举个荔枝：</p><p>将员工按工资由高到低（工资一样则按年龄由大到小）排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Sherry"</span>, <span class="number">9000</span>, <span class="number">24</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">22</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">9000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">8800</span>, <span class="number">26</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Alisa"</span>, <span class="number">9000</span>, <span class="number">26</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按工资升序排序（自然排序）</span></span><br><span class="line">        List&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 按工资倒序排序</span></span><br><span class="line">        List&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">                .map(Person::getName).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 先按工资再按年龄升序排序</span></span><br><span class="line">        List&lt;String&gt; newList3 = personList.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 先按工资再按年龄自定义排序（降序）</span></span><br><span class="line">        List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.getSalary() - p1.getSalary();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"按工资升序排序："</span> + newList);</span><br><span class="line">        System.out.println(<span class="string">"按工资降序排序："</span> + newList2);</span><br><span class="line">        System.out.println(<span class="string">"先按工资再按年龄升序排序："</span> + newList3);</span><br><span class="line">        System.out.println(<span class="string">"先按工资再按年龄自定义降序排序："</span> + newList4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</span><br><span class="line">先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</span><br></pre></td></tr></table></figure><hr><h4 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h4><p>流也可以进行合并、去重、限制、跳过等操作</p><p><strong>去重</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-39-03.png" style="zoom:80%;" /><p><strong>限制</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-40-11.png" style="zoom:80%;" /><p><strong>跳过</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-39-31.png" style="zoom:80%;" /><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] arr1 = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span> &#125;;</span><br><span class="line">        String[] arr2 = &#123; <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">        <span class="comment">// concat:合并两个流 distinct：去重</span></span><br><span class="line">        List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// limit：限制从流中获得前n个数据</span></span><br><span class="line">        List&lt;Integer&gt; collect = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// skip：跳过前n个数据</span></span><br><span class="line">        List&lt;Integer&gt; collect2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">1</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"流合并："</span> + newList);</span><br><span class="line">        System.out.println(<span class="string">"limit："</span> + collect);</span><br><span class="line">        System.out.println(<span class="string">"skip："</span> + collect2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</span><br><span class="line">先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jdk1.8新特性知识点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lambda 表达式、函数式接口、方法引用和构造器调用、Stream API、接口中的默认方法和静态方法、新时间日期 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 stream 流&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-29-30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;&lt;font color=#008000&gt;什么是 stream 流？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Java8 中，Collection 新增了两个流方法，分别是 Stream() 和 parallelStream()&lt;/p&gt;
&lt;p&gt;Java8 中添加了一个新的接口类 Stream，相当于高级版的 Iterator，它可以通过 Lambda 表达式对集合进行大批量数据操作，或 者各种非常便利、高效的聚合数据操作。&lt;/p&gt;
&lt;p&gt;Stream 将要处理的元素集合看作一种流，在流的过程中，借助 Stream API 对流中的元素进行操作，比如：筛选、排序、聚合等。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;jdk8 为什么要引入 stream 流？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;在 Java8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。&lt;/p&gt;
&lt;p&gt;&lt;font color=#6AAFE6&gt;流不存储数据&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jdk8新特性" scheme="https://codeyg.top/categories/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="stream" scheme="https://codeyg.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Maven依赖冲突</title>
    <link href="https://codeyg.top/2021/07/17/%E9%9D%A2%E8%AF%95--Maven/"/>
    <id>https://codeyg.top/2021/07/17/%E9%9D%A2%E8%AF%95--Maven/</id>
    <published>2021-07-17T13:58:58.000Z</published>
    <updated>2021-07-22T01:38:15.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下关于 Maven 的依赖冲突 ：</strong> </p><hr><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/maven.png" style="zoom: 67%;" /><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>之前在使用 maven 的时候还真的没有特意的留意过关于依赖冲突的问题。</p><p>这不，面试中被问到还有点猝不及防！</p><p>来吧，一起来回顾一遍~</p><a id="more"></a><h4 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a>Maven 是什么？</h4><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p><p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><h4 id="Maven-POM"><a href="#Maven-POM" class="headerlink" title="Maven POM"></a>Maven POM</h4><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖 （√）</li><li>插件（√）</li><li>执行目标（√）</li><li>项目构建 profile（√）</li><li>项目版本（√）</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>举个荔枝：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h4><h5 id="Maven-构建生命周期"><a href="#Maven-构建生命周期" class="headerlink" title="Maven 构建生命周期"></a>Maven 构建生命周期</h5><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_15-49-52.png" alt=""></p><table><thead><tr><th align="center">阶段</th><th align="center">处理</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">验证 validate</td><td align="center">验证项目</td><td align="center">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td align="center">编译 compile</td><td align="center">执行编译</td><td align="center">源代码编译在此阶段完成</td></tr><tr><td align="center">测试 test</td><td align="center">测试</td><td align="center">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td align="center">包装 package</td><td align="center">打包</td><td align="center">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td align="center">检查 verify</td><td align="center">检查</td><td align="center">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td align="center">安装 install</td><td align="center">安装</td><td align="center">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td align="center">部署 deploy</td><td align="center">部署</td><td align="center">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><h5 id="mvn-打包比较常用功能（重点）"><a href="#mvn-打包比较常用功能（重点）" class="headerlink" title="mvn 打包比较常用功能（重点）"></a>mvn 打包比较常用功能（重点）</h5><ul><li><p><code>clean</code>：执行该命令会删除项目路径下的 <font color=#FF8C00>target</font> 文件，但是不会删除本地的 maven 仓库已经生成的 jar 文件。</p></li><li><p><code>compile</code>：编译命令，会在项目路径下生成一个 <font color=#FF8C00>target</font> 目录，在该目录中包含一个classes文件夹，里面全是生成的class文件及字节码文件。</p></li><li><p><code>package</code>：这个命令会在你的项目路径下一个 <font color=#FF8C00>target</font> 目录，并且拥有 compile 命令的功能进行编译，同时会在 <font color=#FF8C00>target</font> 目录下生成项目的 jar/war 文件。</p></li><li><p><code>install</code>：该命令包含了 package 命令功能，不但会在项目路径下生成 class 文件和 jar 包，同时会在本地 maven 仓库生成 jar 文件，供其他项目使用。</p></li></ul><p>注意：</p><p><font color=#FF8C00>同时执行多次install或者package命令会每次都更新jar文件</font></p><h4 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h4><h5 id="Maven-仓库类型"><a href="#Maven-仓库类型" class="headerlink" title="Maven 仓库类型"></a>Maven 仓库类型</h5><p>Maven 仓库有三种类型：</p><ul><li>本地（local）：Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。</li><li>中央（central）：Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</li><li>远程（remote）：如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</li></ul><h5 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h5><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><h5 id="Maven-阿里云-Aliyun-仓库"><a href="#Maven-阿里云-Aliyun-仓库" class="headerlink" title="Maven 阿里云(Aliyun)仓库"></a>Maven 阿里云(Aliyun)仓库</h5><p>修改 <code>maven</code> 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven-的排除、归类和优化依赖"><a href="#Maven-的排除、归类和优化依赖" class="headerlink" title="Maven 的排除、归类和优化依赖"></a>Maven 的排除、归类和优化依赖</h4><h5 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h5><p>Maven 可能会自动引入快照版本的依赖，而快照版本的依赖是不稳定的，这时候就需要避免引入快照版本。这样的话需要用一种方式告知 Maven 排除快照版本的依赖引入，这种做法就是排除依赖。</p><p>直接依赖的配置里面添加 exclusions（除外） → exclusion（排除）元素，指定要排除依赖的 groupId 和 artifactId 就行。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h5><p>在引用依赖的时候，很多情况需要引入一个 Maven 项目的多个模块，这些模块都应该是相同的版本。</p><p>例如在下次升级，需要将 1.0 版本升级成 2.0 版本，这样就需要将 org.springframework 的每个模块的版本都统一更改，这样做很容易出现不一致的情况，就很容易出错。</p><p>为了避免出现这种情况，可以在 pom.xml 中定义一个属性名称描述版本的值。</p><p>举个荔枝：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2.16.RELEASE,3.1.4.RELEASE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.spring.version</span>&gt;</span>4.2.7.RELEASE<span class="tag">&lt;/<span class="name">project.build.spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h5><p> Maven 定位依赖的方式、传递依赖的规则以及怎么样排除依赖等。但是要实现这些动作，还必须对项目中的依赖有全面的了解，这样才能更有效地达到目的。</p><p>查看依赖的相关命令</p><p>列出所有的依赖列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:list</span><br></pre></td></tr></table></figure><p>以树形结构方式，列出依赖和层次关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:tree</span><br></pre></td></tr></table></figure><p>分析主代码、测试代码编译的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:analyze</span><br></pre></td></tr></table></figure><hr><h4 id="面试一下"><a href="#面试一下" class="headerlink" title="面试一下"></a>面试一下</h4><h5 id="什么是依赖冲突-版本冲突"><a href="#什么是依赖冲突-版本冲突" class="headerlink" title="什么是依赖冲突/版本冲突?"></a>什么是依赖冲突/版本冲突?</h5><p>Maven 的依赖机制会导致 jar 包的冲突</p><blockquote><p>举个例子，在项目中，使用了两个 jar 包，分别是 A 和 B。<br>现在 A 需要依赖另一个 jar 包 C，B 也需要依赖 C。<br>但是 A 依赖的 C 的版本是 1.0，B 依赖的C的版本是 2.0。<br>这时候，Maven 会将这 1.0 的 C 和 2.0 的 C 都下载到你的项目中，这样你的项目中就存在了不同版本的 C。</p></blockquote><p>这时Maven会采用<a href="#dependency"><font color=#FF8C00>最短路径优先原则</font></a>（即，根据寻找到的依赖路径中最短的），来决定使用哪个版本的 jar 包，而另一个无用的 jar 包则未被使用，这就是所谓的依赖冲突。</p><p>注意：</p><p>在大多数时候，依赖冲突可能并不会对系统造成什么异常，因为 Maven 始终选择了一个 jar 包来使用。<br>但是，不排除在某些特定条件下，会出现类似找不到类的异常。<br>所以，只要存在依赖冲突，最好还是解决掉，不要给系统留下隐患。</p><p>解决办法：</p><p>最经典的就是 log4j 的依赖排除，使用 Maven 提供的标签 exclusion</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>log4j-core 本身是依赖了 log4j-api 的，但是因为一些其他的模块也依赖了 log4j-api，并且两个 log4j-api 版本不同，所以我们使用标签排除掉 log4j-core 所依赖的 log4j-api，这样 Maven 就不会下载 log4j-core 所依赖的 log4j-api 了，也就保证了我们的项目中只有一个版本的 log4j-api。</p><h5 id="maven-的依赖原则"><a href="#maven-的依赖原则" class="headerlink" title="maven 的依赖原则"></a><span id="dependency">maven 的依赖原则</span></h5><p>maven 有三种原则依赖原则</p><p><font color=#008000>当一个项目中出现重复引用依赖 jar 包时，maven 一般有如下三种原则处理 jar</font></p><ol><li>最短路径原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D(v1)</span><br><span class="line">F -&gt; G -&gt; D(v2)</span><br></pre></td></tr></table></figure><p>这个时候项目中就出现了两个版本的 D，这时 maven 会采用最短路径原则，选择 v2 版本的 D，因为 v1 版本的 D 是由 A 包间接依赖的，整个依赖路径长度为 3，而 v2 版本的 D 是由 F 包间接依赖的，整个依赖路径长度为 2。</p><ol start="2"><li>优先声明原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; D(v1)</span><br><span class="line">F -&gt; G -&gt; D(v2)</span><br></pre></td></tr></table></figure><p>如果两个 jar 包版本路径深度相同，则使用优先声明的版本 v1</p><ol start="3"><li>多次直接引不同版本的 jar 时，使用最后声明的版本</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 pom 文件中，同时引用了如上两个版本，则会使用 4.3.20.RELEASE 版本（最后声明的版本）</p><h5 id="install-和-package-的区别"><a href="#install-和-package-的区别" class="headerlink" title="install 和 package 的区别"></a>install 和 package 的区别</h5><p>Maven install 安装指令，其实做了 2 件事情：</p><ol><li>将项目打包（jar/war），将打包结果放到项目下的 <font color=#FF8C00>target</font> 目录下；</li><li>同时将上述打包结果放到<font color=#FF8C00>本地仓库</font>的相应目录中，供其他项目或模块引用；</li></ol><p>Maven package 打包指令，其实就做了 1 件事：</p><ol><li>将项目打包（jar/war），将打包结果放到项目下的  <font color=#FF8C00>target</font> 目录下 （要先 clean）；</li></ol><p>注意：</p><p> clean 命令作用是：清理项目中 <font color=#FF8C00>target</font> 目录下文件；</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下关于 Maven 的依赖冲突 ：&lt;/strong&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/maven.png&quot; style=&quot;zoom: 67%;&quot; /&gt;



&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;之前在使用 maven 的时候还真的没有特意的留意过关于依赖冲突的问题。&lt;/p&gt;
&lt;p&gt;这不，面试中被问到还有点猝不及防！&lt;/p&gt;
&lt;p&gt;来吧，一起来回顾一遍~&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="maven" scheme="https://codeyg.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--布隆过滤器</title>
    <link href="https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2021-07-16T13:58:58.000Z</published>
    <updated>2021-07-22T01:39:29.257Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下布隆过滤器</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-11-56.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>为啥要写一篇关于布隆过滤器的博客？</font></p><p>还不是因为上集说到的 redis 中遇到缓存穿透的其中一个解决方案。</p><p>下面我们来详细的介绍一下 “ Bloom Filter ”</p><a id="more"></a><p>百度了一下：</p><p>布隆过滤器本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure）</p><p>特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在” 。</p><p> 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。 </p><p><font color=#008000>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？ </font></p><p>应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O (1) 的时间复杂度内返回结果，效率奇高。</p><p>了解布隆过滤器原理之前，先回顾下 Hash 函数原理。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数的概念是：将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为哈希值或哈希编码，也叫散列值。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-00-27.png" alt=""></p><p>所有散列函数都有如下基本特性：</p><ul><li>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为<strong>单向散列函数</strong>。</li><li>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“<strong>散列碰撞</strong>（collision）”。</li></ul><p>但是用 hash 表存储大数据量时，空间效率还是很低，当只有一个 hash 函数时，还很容易发生哈希碰撞。</p><h4 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h4><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-12-52.png" alt=""></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7（橙色部分）则上图转变为：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-13-24.png" alt=""></p><p>我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 （紫色部分）图继续变为：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-41-55.png" alt=""></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了（绿色部分）</p><p>现在我们如果想查询 “google” 这个值是否存在，哈希函数返回了 1、5、8 三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>;</p><p>因此我们可以很确定地说 “google” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1;</p><p>那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>这是为什么呢？</p><p>答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位，例如：1、3、8 都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-44-00.png" alt=""></p><h4 id="布隆过滤器优点"><a href="#布隆过滤器优点" class="headerlink" title="布隆过滤器优点"></a>布隆过滤器优点</h4><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。</p><p>布隆过滤器存储空间和插入/查询时间都是常数。</p><p>另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p>k 和 m 相同，使用同一组 Hash 函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><h4 id="布隆过滤器缺点"><a href="#布隆过滤器缺点" class="headerlink" title="布隆过滤器缺点"></a>布隆过滤器缺点</h4><p>布隆过滤器的缺点和优点一样明显。误算率（False Positive）是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。</p><p>然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><h4 id="布隆过滤器的使用场景："><a href="#布隆过滤器的使用场景：" class="headerlink" title="布隆过滤器的使用场景："></a>布隆过滤器的使用场景：</h4><p>在程序的世界中，布隆过滤器是程序员的一把利器，利用它可以快速地解决项目中一些比较棘手的问题。</p><p>如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。</p><p>布隆过滤器的典型应用有：</p><ul><li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li><li>业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li><li>缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li><li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li><li>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。</li><li>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。</li></ul><h4 id="布隆过滤器的使用（Java版）"><a href="#布隆过滤器的使用（Java版）" class="headerlink" title="布隆过滤器的使用（Java版）"></a>布隆过滤器的使用（Java版）</h4><ol><li>需要引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个布隆过滤器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"TestBloomFilterTest测试类"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===============测试开始==============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===============测试结束==============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"布隆过滤器"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BloomFilterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; filter = BloomFilter.create(</span><br><span class="line">                Funnels.stringFunnel(Charset.defaultCharset()),</span><br><span class="line">                <span class="number">1000</span>,</span><br><span class="line">                <span class="number">0.001</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        filter.put(<span class="string">"baidu.com"</span>);</span><br><span class="line">        filter.put(<span class="string">"tencent.com"</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"布隆过滤器中是否含有 baidu.com? &#123;&#125;"</span>,filter.mightContain(<span class="string">"baidu.com"</span>));</span><br><span class="line">        log.info(<span class="string">"布隆过滤器中是否含有 google.com? &#123;&#125;"</span>,filter.mightContain(<span class="string">"google.com"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-35-30.png" alt=""></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>本质上布隆过滤器是一种数据结构，特点是高效地插入和查询，可以用来确定<font color=#FF8C00>某个值一定不存在或者可能存在</font></p><p>回到 redis 中遇到缓存穿透的其中一个解决方案，布隆过滤器能够过滤掉一定不存在的值，也就是说，我们可以把数据库中所有的数据存储到布隆过滤器中，一旦有非法的值传进来，就能够轻而易举的判断出该值对于数据库来说是否有效，从而避免无谓的查询。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下布隆过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-11-56.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;为啥要写一篇关于布隆过滤器的博客？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;还不是因为上集说到的 redis 中遇到缓存穿透的其中一个解决方案。&lt;/p&gt;
&lt;p&gt;下面我们来详细的介绍一下 “ Bloom Filter ”&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Redis</title>
    <link href="https://codeyg.top/2021/07/15/%E9%9D%A2%E8%AF%95--Redis/"/>
    <id>https://codeyg.top/2021/07/15/%E9%9D%A2%E8%AF%95--Redis/</id>
    <published>2021-07-15T13:58:58.000Z</published>
    <updated>2021-07-22T01:38:24.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-16_21-42-34.png" alt=""></p><p><strong>写在前面</strong></p><h4 id="为什么不直接访问数据库？要在中间加一个Redis缓存？"><a href="#为什么不直接访问数据库？要在中间加一个Redis缓存？" class="headerlink" title="为什么不直接访问数据库？要在中间加一个Redis缓存？"></a><font color=#008000>为什么不直接访问数据库？要在中间加一个Redis缓存？</font></h4><p>其实我在了解redis之前一直有这样一个疑问，但是既然使用redis作为中间缓存一定是有道理的！</p><p>那么一起来看一下使用redis有哪些好处吧~</p><a id="more"></a><p><strong>原因：</strong></p><ol><li>Redis 可以用几十 G 内存来做缓存；</li><li>Redis 的缓存可以持久化 （RBD &amp; AOF）；</li><li>Redis 可以实现分布式的缓存；</li><li>Redis 可以处理每秒百万级的并发，是专业的缓存服务；</li><li>Redis 缓存有过期机制；</li><li>Redis 有丰富的 API。</li></ol><p>其中redis最典型的应用场景，当做缓存使用。</p><p>因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等……</p><ul><li>服务在处理请求时先从redis里获取结果，获取到了就可以直接返回，没有获取到的话再从数据库里获取，然后存到redis里以供下次使用。</li><li>用redis的好处是可以做到分布式，有状态的数据都存在redis里，使业务服务层无状态，以便业务层有很高的可扩展性。</li></ul><h4 id="先来说下redis是什么吧？"><a href="#先来说下redis是什么吧？" class="headerlink" title="先来说下redis是什么吧？"></a><font color=#008000>先来说下redis是什么吧？</font></h4><p>我：Redis是C语言开发的一个开源的高性能键值对（key-value）的内存数据库；</p><p>它是一种NoSQL（非关系型数据库）的数据库。</p><p>可以用作数据库、缓存、消息中间件等。</p><p>我接着说：Redis作为一个内存数据库。</p><ol><li>性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS；</li><li>单进程单线程，是线程安全的，采用IO多路复用机制；</li><li>丰富的数据类型；</li><li>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；</li><li>主从复制，哨兵，高可用；</li><li>可以用作分布式锁；</li><li>可以作为消息中间件使用，支持发布订阅。</li></ol><br/><h4 id="具体说一下Redis有哪些数据结构呀？"><a href="#具体说一下Redis有哪些数据结构呀？" class="headerlink" title="具体说一下Redis有哪些数据结构呀？"></a><font color=#008000>具体说一下Redis有哪些数据结构呀？</font></h4><p>答：字符串（String）、字典（Hash）、列表（List）、集合（Set）、有序集合（SortedSet）</p><p><font color=#FF8C00>后面了解到还有：HyperLogLog、Geo、Pub/Sub 【这是加分的内容】</font></p><br/><h4 id="使用过Redis分布式锁么，它是怎么回事？"><a href="#使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="使用过Redis分布式锁么，它是怎么回事？"></a><font color=#008000>使用过Redis分布式锁么，它是怎么回事？</font></h4><p>答：先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><br/><h4 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a><font color=#008000>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</font></h4><p>（这道题很经典啊，网上见过~）</p><p>答：使用<code>keys</code>指令可以扫出指定模式的key列表 【 key  keys xxx*】</p><br/><h4 id="那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a><font color=#008000>那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</font></h4><p>答：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p><p><font color=#FF8C00>后面了解到：这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</font></p><br/><h4 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a><font color=#008000>使用过Redis做异步队列么，你是怎么用的？</font></h4><p>答：一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><br/><h4 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a><font color=#008000>能不能生产一次消费多次呢？</font></h4><p>答：使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p><br/><h4 id="pub-su-b有什么缺点？"><a href="#pub-su-b有什么缺点？" class="headerlink" title="pub/su b有什么缺点？"></a><font color=#008000>pub/su b有什么缺点？</font></h4><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>RabbitMQ</code>等。</p><br/><h4 id="Redis是怎么持久化的？"><a href="#Redis是怎么持久化的？" class="headerlink" title="Redis是怎么持久化的？"></a><font color=#008000>Redis是怎么持久化的？</font></h4><p>（送分题~）</p><p>答：RBD 和 AOF </p><ul><li><p>RDB做镜像全量持久化，即将整个Redis内存数据持久化到一个文件。</p></li><li><p>AOF做增量持久化，AOF会将redis中每一步对数据修改的操作记录（日志）append到相应的文件中。</p></li></ul><br/><h4 id="那说一下-RBD-和-AOF-的优劣，及其原理吧"><a href="#那说一下-RBD-和-AOF-的优劣，及其原理吧" class="headerlink" title="那说一下 RBD 和 AOF 的优劣，及其原理吧"></a><font color=#008000>那说一下 RBD 和 AOF 的优劣，及其原理吧</font></h4><p>答：</p><p><strong>RDB</strong></p><p>优点：</p><ul><li>二进制压缩文件，恢复速度快</li></ul><p>缺点：</p><ul><li>可能丢失数据（服务器宕机的时候）</li></ul><p>原理：</p><p><strong>fork</strong> 和 <strong>cow</strong></p><ul><li>fork是指redis通过创建子进程来进行RDB操作；</li><li>cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><p><strong>AOF</strong></p><p>优点：</p><ul><li>不易丢失数据，数据完整性好</li></ul><p>缺点：</p><ul><li>每一步操作都记录，相对影响性能</li><li>数据恢复慢，文件较大</li></ul><p>原理：</p><p>为了降低 IO 消耗，AOF 写文件时，会先将数据写到缓冲区，然后再把缓冲区的内容 flush 到磁盘，这个过程叫做 fsync。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ appendfsync always  //每次写操作都flush，影响性能</span><br><span class="line">$ appendfsync everysec  //每秒flush</span><br><span class="line">$ appendfsync no  //消极等待OS刷新(一般30s),可能丢失数据</span><br></pre></td></tr></table></figure><p>相比于always的激进和no的消极，everysec在性能和数据完整性上取了一个折中。</p><br/><h4 id="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"></a><font color=#008000>是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？</font></h4><p>答：</p><ul><li><p>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p></li><li><p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</p></li></ul><br/><h4 id="Redis-会遇到的缓存雪崩，缓存穿透，缓存击穿吧"><a href="#Redis-会遇到的缓存雪崩，缓存穿透，缓存击穿吧" class="headerlink" title="Redis 会遇到的缓存雪崩，缓存穿透，缓存击穿吧"></a><font color=#008000>Redis 会遇到的缓存雪崩，缓存穿透，缓存击穿吧</font></h4><p>先来了解一下缓存雪崩，缓存穿透，缓存击穿是什么意思！</p><p>一、缓存雪崩</p><p><strong>含义：</strong></p><p>缓存雪崩表示在某一时间段，缓存集中失效，导致请求全部走数据库，有可能搞垮数据库，使整个服务瘫痪。</p><p>使缓存集中失效的原因：</p><ol><li><p>redis服务器挂掉了。</p></li><li><p>对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效。（√）</p></li></ol><p><strong>解决方案：</strong></p><ol><li><p>针对原因1，可以实现redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等方案。</p></li><li><p>针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期。</p></li></ol><p>举个荔枝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 设置过期时间加上一个随机值</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_1'</span>, <span class="string">'文章内容'</span>, 60 + mt_rand(1, 60));</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_2'</span>, <span class="string">'文章内容'</span>, 60 + mt_rand(1, 60));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用双缓存策略，设置两个缓存，原始缓存和备用缓存，原始缓存失效时，访问备用缓存，备用缓存失效时间设置长点。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 原始缓存</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_2'</span>, <span class="string">'文章内容'</span>, 60);</span><br><span class="line"><span class="comment">## 设置备用缓存，失效时间设置长点</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_backup_2'</span>, <span class="string">'文章内容'</span>, 1800);</span><br></pre></td></tr></table></figure><p>二、缓存穿透</p><p><strong>含义：</strong></p><p>缓存穿透表示查询一个一定不存在的数据，由于没有获取到缓存，所以没写入缓存，导致这个不存在的数据每次都需要去数据库查询，失去了缓存的意义。</p><p>请求的数据大量的没有获取到缓存，导致走数据库，有可能搞垮数据库，使整个服务瘫痪。</p><p>比如文章表，一般我们的主键ID都是无符号的自增类型，有些人想要搞垮你的数据库，每次请求都用负数ID，而ID为负数的记录在数据库根本就没有。</p><p><strong>解决方案：</strong></p><ol><li>对于像ID为负数的非法请求直接过滤掉，采用<a href="https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"><font color=#FF8C00>布隆过滤器 ( Bloom Filter )</font> </a>。</li><li>禁用IP 限制IP访问。</li><li><strong>限流</strong> 每秒最多访问3次。</li><li>针对在数据库中找不到记录的，我们仍然将该空数据存入缓存中，当然一般会设置一个较短的过期时间。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置文章ID为-10000的缓存为空</span><br><span class="line"><span class="variable">$id</span> = -10000;</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_'</span> . <span class="variable">$id</span>, <span class="string">''</span>, 60);</span><br><span class="line"> </span><br><span class="line">var_dump(<span class="variable">$redis</span>-&gt;get(<span class="string">'article_content_'</span> . <span class="variable">$id</span>));</span><br></pre></td></tr></table></figure><p>三、缓存击穿</p><p><strong>含义：</strong></p><p>缓存击穿表示某个key的缓存非常热门，有很高的并发一直在访问，如果该缓存失效，那同时会走数据库，压垮数据库。</p><p>缓存击穿与缓存雪崩的区别是这里针对的是某一热门 key 缓存，而雪崩针对的是大量缓存的集中失效。</p><p><strong>解决方案：</strong></p><ol><li>让该热门 key 的缓存永不过期。</li><li>使用互斥锁，通过 redis 的 setnx 实现互斥锁。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRedis</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = <span class="keyword">new</span> Redis();</span><br><span class="line">    $redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> $redis;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lock</span>(<span class="params">$key, $random</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    <span class="comment">//设置锁的超时时间，避免释放锁失败，del()操作失败，产生死锁。</span></span><br><span class="line">    $ret = $redis-&gt;<span class="keyword">set</span>($key, $random, ['nx', 'ex' =&gt; 3 * 60]);</span><br><span class="line">    return $ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//解锁</span><br><span class="line">function unLock($key, $random)</span><br><span class="line">&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    <span class="comment">//这里的随机数作用是，防止更新缓存操作时间过长，超过了锁的有效时间，导致其他请求拿到了锁。</span></span><br><span class="line">    <span class="comment">//但上一个请求更新缓存完毕后，如果不加判断直接删除锁，就会误删其他请求创建的锁。</span></span><br><span class="line">    <span class="keyword">if</span> ($redis-&gt;<span class="keyword">get</span>($key) == $random) &#123;</span><br><span class="line">        $redis-&gt;del($key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//从缓存中获取文章数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArticleInCache</span>(<span class="params">$id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    $key = <span class="string">'article_content_'</span> . $id;</span><br><span class="line">    $ret = $redis-&gt;<span class="keyword">get</span>($key);</span><br><span class="line">    if ($ret === false) &#123;</span><br><span class="line">        <span class="comment">//生成锁的key</span></span><br><span class="line">        $lockKey = $key . <span class="string">'_lock'</span>;</span><br><span class="line">        <span class="comment">//生成随机数，用于设置锁的值，后面释放锁时会用到</span></span><br><span class="line">        $random = mt_rand();</span><br><span class="line">        <span class="comment">//拿到互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock($lockKey, $random)) &#123;</span><br><span class="line">            <span class="comment">//这里是伪代码，表示从数据库中获取文章数据</span></span><br><span class="line">            $value = $db-&gt;getArticle($id);</span><br><span class="line">            <span class="comment">//更新缓存，过期时间可以根据情况自已调整</span></span><br><span class="line">            $redis-&gt;<span class="keyword">set</span>($key, $value, 2 * 60);</span><br><span class="line">            //释放锁</span><br><span class="line">            unLock($lockKey, $random);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="comment">//等待200毫秒，然后重新获取缓存值，让其他获取到锁的进程取得数据并设置缓存</span></span><br><span class="line">            usleep(<span class="number">200</span>);</span><br><span class="line">            getArticleInCache($id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-16_21-42-34.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么不直接访问数据库？要在中间加一个Redis缓存？&quot;&gt;&lt;a href=&quot;#为什么不直接访问数据库？要在中间加一个Redis缓存？&quot; class=&quot;headerlink&quot; title=&quot;为什么不直接访问数据库？要在中间加一个Redis缓存？&quot;&gt;&lt;/a&gt;&lt;font color=#008000&gt;为什么不直接访问数据库？要在中间加一个Redis缓存？&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;其实我在了解redis之前一直有这样一个疑问，但是既然使用redis作为中间缓存一定是有道理的！&lt;/p&gt;
&lt;p&gt;那么一起来看一下使用redis有哪些好处吧~&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>日积月累</title>
    <link href="https://codeyg.top/2021/07/01/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    <id>https://codeyg.top/2021/07/01/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/</id>
    <published>2021-06-30T23:07:07.000Z</published>
    <updated>2021-07-27T18:52:03.493Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-13-27.png" alt=""></p><a id="more"></a><h4 id="1、-Autowired和-Resource的区别是什么？"><a href="#1、-Autowired和-Resource的区别是什么？" class="headerlink" title="1、@Autowired和@Resource的区别是什么？"></a><font color=#008000>1、@Autowired和@Resource的区别是什么？</font></h4><p>联系：</p><ul><li>@Autowired和@Resource注解都是作为bean对象注入的时候使用的；</li><li>两者都可以声明在字段和setter方法上；</li></ul><p>区别：</p><ul><li>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的；</li><li>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入；</li><li>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错；</li></ul><hr><h4 id="2、HashMap与ConcurrentHashMap的区别？"><a href="#2、HashMap与ConcurrentHashMap的区别？" class="headerlink" title="2、HashMap与ConcurrentHashMap的区别？"></a><font color=#008000>2、HashMap与ConcurrentHashMap的区别？</font></h4><p>相同点：</p><ul><li>首先两者的相同点在于底层都是数组+链表实现实现的；</li></ul><p>区别：</p><ul><li>HashMap是线程非安全的，ConcurrentHashMap是线程安全的</li></ul><hr><h4 id="3、处理哈希冲突的方法？"><a href="#3、处理哈希冲突的方法？" class="headerlink" title="3、处理哈希冲突的方法？"></a><font color=#008000>3、处理哈希冲突的方法？</font></h4><ul><li>开放定址法</li><li>链地址法（√）</li><li>再散列法</li></ul><hr><h4 id="4、包装类和基本数据类型的区别？"><a href="#4、包装类和基本数据类型的区别？" class="headerlink" title="4、包装类和基本数据类型的区别？"></a><font color=#008000>4、包装类和基本数据类型的区别？</font></h4><p>包装类：</p><ul><li><p>优点：</p><ul><li>可以赋值为null</li><li>提供了一系列的方法常用的有：parseInt(String s)、tostring()、valueOf(String s)、equals( object object)、i.compareto(integer anotherIntger)</li><li><font color=#FF8C00>集合中不允许放基本数据类型，只能放包装类！</font></li></ul></li><li><p>缺点：</p><ul><li>由于每个值分别包装在对象中，所以ArrayList的效率远远低于int[]数组</li></ul></li></ul><p>基本数据类型：</p><ul><li><p>优点：</p><ul><li>计算效率高</li><li>不会由于常量池而引起比较大小的错误</li></ul></li><li><p>缺点：</p><ul><li>当数据库查询出结果封装到结果集时,如何返回的值为null时,会将结果赋值给字段,运行时会报错,不能将null值赋值给基本数据类型</li></ul></li></ul><p><strong>两者的区别：</strong><br>1、声明方式不同，基本类型不适用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br>2、存储方式及位置不同，基本类型是直接将变量值存储在堆栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br>3、初始值不同，基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null<br>4、使用方式不同，基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。<br>5、包装类都是继承Number 接口实现Compareble 接口的</p><hr><h4 id="5、MyISAM-和-INNODB-的区别？"><a href="#5、MyISAM-和-INNODB-的区别？" class="headerlink" title="5、MyISAM 和 INNODB 的区别？"></a><font color=#008000>5、MyISAM 和 INNODB 的区别？</font></h4><ol><li><p>事务安全：</p><p>MyISAM 不支持事务（×）</p><p>INNODB  支持事务（√）</p></li><li><p>外键 ：</p><p>MyISAM 不支持外键（×）</p><p> INNODB 支持外键（√）</p></li><li><p>锁机制：</p><p>MyISAM 是表锁</p><p>INNODB 是行锁</p></li><li><p>查询和添加速度：</p><p>MyISAM 批量插入速度快</p></li><li><p>支持全文索引：</p><p>MyISAM 支持全文索引（√）</p><p>INNODB 不支持全文索引（×）</p></li><li><p>MyISAM 内存空间使用率比 INNODB 低</p></li></ol><p>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用 memory, 速度极快. （如果 mysql 重启的话，数据就不存在了）</p><hr><h4 id="6、Java中final、finally、finalize的区别与用法"><a href="#6、Java中final、finally、finalize的区别与用法" class="headerlink" title="6、Java中final、finally、finalize的区别与用法"></a><font color=#008000>6、Java中final、finally、finalize的区别与用法</font></h4><ul><li>final：java中的关键字，修饰符。<br>1.如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。<br>2.如果将变量或者方法声明为final，可以保证它们在使用中不被改变.<ul><li>被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。</li><li>被声明final的方法只能使用，不能重载。</li></ul></li><li>finally：java的一种异常处理机制。<br>　　finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。</li><li>finalize：Java中的一个方法名。<br>Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。</li></ul><hr><h4 id="7、try-catch-finally"><a href="#7、try-catch-finally" class="headerlink" title="7、try-catch-finally"></a><font color=#008000>7、try-catch-finally</font></h4><ol><li>异常处理语法结构中只有 try 块是必需的，也就是说，如果没有 try 块，则不能有后面的 catch 块和 finally 块；</li><li>catch 块和 finally 块都是可选的，但 catch 块和 finally 块至少出现其中之一，也可以同时出现；</li><li>可以有多个 catch 块，捕获父类异常的 catch 块必须位于捕获子类异常的后面；</li><li>不能只有 try 块，既没有 catch 块，也没有 finally 块；</li><li>多个 catch 块必须位于 try 块之后，finally 块必须位于所有的 catch 块之后。</li><li>finally 与 try 语句块匹配的语法格式，此种情况会导致异常丢失，所以不常见。</li></ol><hr><h4 id="8、Java中常见的五种异常"><a href="#8、Java中常见的五种异常" class="headerlink" title="8、Java中常见的五种异常"></a><font color=#008000>8、Java中常见的五种异常</font></h4><ol><li>ClassCastException【类转换异常】</li><li>IndexOutOfBoundsException【数组越界】</li><li>NullPointerException【空指针】</li><li>IllegalAccessException【安全权限异常】</li><li>IOException【输入输出异常】</li></ol><hr><h4 id="9、Java中垃圾回收的目的？什么时候进行？"><a href="#9、Java中垃圾回收的目的？什么时候进行？" class="headerlink" title="9、Java中垃圾回收的目的？什么时候进行？"></a><font color=#008000>9、Java中垃圾回收的目的？什么时候进行？</font></h4><p>垃圾回收是在内存中中存在<strong>没有引用的对象</strong>或<strong>超过作用域的对象时</strong>进行垃圾回收，垃圾回收的目的是识别并且丢弃不再使用的对象来释放和重用资源。</p><p>目的：<br>回收堆中不再使用的对象，释放资源。<br>回收时间：当对象失去引用后，系统会在合适的时间回收它所占的内存。</p><ul><li>老年代的对象所需要的内存大于老年代剩余内存，则会触发老年代 GC（Full GC）。</li><li>当程序调用System.gc() 时也会触发Full GC。</li></ul><hr><h4 id="10、什么是内存泄漏？"><a href="#10、什么是内存泄漏？" class="headerlink" title="10、什么是内存泄漏？"></a><font color=#008000>10、什么是内存泄漏？</font></h4><p>【<strong>out of memory</strong>】</p><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中。</p><p><strong>内存溢出的原因以及解决方法</strong></p><ol><li><p>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</p></li><li><p>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</p></li><li><p>代码中存在死循环或循环产生过多重复的对象实体；</p></li><li><p>启动参数内存值设定的过小</p></li></ol><p>内存溢出的解决方案：</p><p>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p><p>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><hr><h4 id="11、String-s-new-String-“xyz”-创建几个String对象？"><a href="#11、String-s-new-String-“xyz”-创建几个String对象？" class="headerlink" title="11、String s = new String(“xyz”);创建几个String对象？"></a><font color=#008000>11、String s = new String(“xyz”);创建几个String对象？</font></h4><p>两个或一个</p><ul><li>第一次调用 new String(“xyz”); 时，会在堆内存中创建一个字符串对象，同时在字符串常量池中创建一个对象 “xyz”</li><li>第二次调用 new String(“xyz”); 时，只会在堆内存中创建一个字符串对象，指向之前在字符串常量池中创建的 “xyz”</li></ul><hr><h4 id="12、类加载器工作机制？"><a href="#12、类加载器工作机制？" class="headerlink" title="12、类加载器工作机制？"></a><font color=#008000>12、类加载器工作机制？</font></h4><ol><li>装载：将Java二进制代码导入jvm中，生成Class文件。</li><li>连接：<ul><li>校验：检查载入Class文件数据的正确性 </li><li>准备：给类的静态变量分配存储空间</li><li>解析：将符号引用转成直接引用</li></ul></li><li>初始化：对类的静态变量，静态方法和静态代码块执行初始化工作。<br>双亲委派模型：类加载器收到类加载请求，首先将请求委派给父类加载器完成 用户自定义加载器-&gt;应用程序加载器-&gt;扩展类加载器-&gt;启动类加载器。</li></ol><hr><h4 id="13、Spring中的Controller-，Service，Dao是不是线程安全的？"><a href="#13、Spring中的Controller-，Service，Dao是不是线程安全的？" class="headerlink" title="13、Spring中的Controller ，Service，Dao是不是线程安全的？"></a><font color=#008000>13、Spring中的Controller ，Service，Dao是不是线程安全的？</font></h4><ol><li>在@Controller/@Service等容器中，默认情况下，scope 值是单例 singleton 的，也是线程不安全的。</li><li>尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例 (singleton) 还是多实例 (prototype) 他都是线程不安全的。</li><li>默认注入的 Bean 对象，在不设置 scope 的时候他也是线程不安全的。</li><li>一定要定义变量的话，用 ThreadLocal 来封装，这个是线程安全的</li></ol><hr><h4 id="14、Java-中-sleep-和-wait-的区别？"><a href="#14、Java-中-sleep-和-wait-的区别？" class="headerlink" title="14、Java 中 sleep() 和 wait() 的区别？"></a><font color=#008000>14、Java 中 sleep() 和 wait() 的区别？</font></h4><ol><li>这两个方法来自不同的类分别是，sleep 来自 Thread 类，和 wait 来自 Object 类。</li><li>最主要是 sleep 方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。</li><li>使用范围：wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可以在任何地方使用。</li><li>sleep 必须捕获异常，而 wait，notify 和 notifyAll 不需要捕获异常。</li></ol><p> <strong>未完待续 … …</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-13-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="日积月累" scheme="https://codeyg.top/tags/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--SpringBoot启动原理</title>
    <link href="https://codeyg.top/2021/06/27/%E9%9D%A2%E8%AF%95--SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://codeyg.top/2021/06/27/%E9%9D%A2%E8%AF%95--SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-27T13:58:58.000Z</published>
    <updated>2021-07-02T15:23:20.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 SpringBoot 启动原理：</strong></p><hr><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spring-boot-logo.png" style="zoom:67%;" /><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近在不断的面试中总结<code>Spring</code>全家桶已经是必须要熟练掌握的框架了，其中化繁为简的<code>SpringBoot</code>更是经常被提及的框架，所以我今天就来聊聊 SpringBoot。</p><p>说起<code>SpringBoot</code>的江湖地位，由于其设计优雅，实现简单，可以节省不少开发时间。</p><a id="more"></a><blockquote><p>以下源码的 <code>SpringBoot</code> 版本：2.3.9.RELEASE</p></blockquote><p>其实<code>SpringBoot</code>的启动大体上分为 2 个步骤：</p><ol><li>启动类上注解：@SpringBootApplication</li><li>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</li></ol><h4 id="启动原理"><a href="#启动原理" class="headerlink" title="启动原理"></a>启动原理</h4><h5 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h5><p>main 方法上的注解 @SpringBootApplication：</p><p>三个注解核心注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguratio</li><li>@ComponentScan</li></ul><p><strong>@SpringBootConfiguration</strong></p><p>根据 Javadoc 可知，该注解作用就是将当前的类作为一个 <strong>JavaConfig</strong>，然后<strong>触发注解</strong><code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的<strong>处理</strong>，本质上与<strong>@Configuration</strong>注解没有区别。</p><p><strong>@ComponentScan</strong></p><p>扫描的 <code>Spring</code> 对应的组件，如 <strong>@Componet</strong>，<strong>@Repository</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 SpringBoot 启动原理：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spring-boot-logo.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;最近在不断的面试中总结&lt;code&gt;Spring&lt;/code&gt;全家桶已经是必须要熟练掌握的框架了，其中化繁为简的&lt;code&gt;SpringBoot&lt;/code&gt;更是经常被提及的框架，所以我今天就来聊聊 SpringBoot。&lt;/p&gt;
&lt;p&gt;说起&lt;code&gt;SpringBoot&lt;/code&gt;的江湖地位，由于其设计优雅，实现简单，可以节省不少开发时间。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="SpringBoot" scheme="https://codeyg.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Spring入门</title>
    <link href="https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/"/>
    <id>https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2021-06-19T13:58:58.000Z</published>
    <updated>2021-07-24T18:04:06.137Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇Java小知识</p></blockquote><p><strong>本篇着重介绍一下 Spring 框架</strong></p><hr><br><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png" style="zoom:50%;" /><br><br><p><strong>写在前面</strong></p><p>百度百科：</p><p>Spring 框架是由于软件开发的复杂性而创建的。</p><p>Spring 使用的是基本的<code>JavaBean</code>来完成以前只可能由<code>EJB</code>完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。</p><a id="more"></a><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h3><h4 id="Spring-的整体架构"><a href="#Spring-的整体架构" class="headerlink" title="Spring 的整体架构"></a>Spring 的整体架构</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1555451-20200715233519469-2015600342.png" style="zoom:90%;" /><hr><h4 id="Spring-应用的设计模式"><a href="#Spring-应用的设计模式" class="headerlink" title="Spring 应用的设计模式"></a>Spring 应用的设计模式</h4><ul><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式</strong>: Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知 (Advice) 使用到了适配器模式、Spring MVC 中也是用到了适配器模式适配 controller。</li></ul><h3 id="Spring-三层架构"><a href="#Spring-三层架构" class="headerlink" title="Spring 三层架构"></a>Spring 三层架构</h3><ul><li>A 表现层  <code>web</code>层 、 <code>MVC</code>是表现层的一个设计模型 </li><li>B 业务层 <code>service</code>层</li><li>C 持久层 <code>dao</code>层</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>要与 SPringMVC 的三层架构区分开。</p><h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><ul><li><strong>spring-core</strong> 模块提供了框架的基本组成部分，包括 <code>IoC</code> 和依赖注入功能。</li><li><strong>spring-beans</strong> 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</li><li><strong>context</strong> 模块建立在由 <strong>core</strong>和 <strong>beans</strong> 模块的基础上建立起来的，它以一种类似于 JNDI 注册的方式访问对象。Context 模块继承自 Bean 模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过 Servelet 容器）等功能。Context 模块也支持 Java EE 的功能，比如 EJB、JMX 和远程调用等。<strong>ApplicationContext</strong> 接口是 Context 模块的焦点。<strong>spring-context-support</strong> 提供了对第三方集成到 Spring 上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</li><li><strong>spring-expression</strong> 模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是 JSP2.1 规范中定义的统一表达式语言的扩展，支持 set 和 get 属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从 Spring IoC 容器检索对象，还支持列表的投影、选择以及聚合等。</li></ul><h4 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h4><p><font color=#FF0000>注：JDBC【Java Data Base Connectivity】，ORM【Object Relational Mapping】，OXM【Object XML Mapping】，JMS【Java Message Service】</font></p><ul><li><strong>JDBC</strong> 模块提供了 JDBC 抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。</li><li><strong>ORM</strong> 模块提供了对流行的对象关系映射 API 的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring的其它功能整合，比如前面提及的事务管理。</li><li><strong>OXM</strong> 模块提供了对 OXM 实现的支持，比如 JAXB、Castor、XML Beans、JiBX、XStream 等。</li><li><strong>JMS</strong> 模块包含生产（produce）和消费（consume）消息的功能。从 Spring 4.1 开始，集成了 spring-messaging 模块。</li><li><strong>事务</strong>模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写 beginTransaction()、commit()、rollback() 等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细）</li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p><ul><li><strong>Web</strong> 模块提供面向 web 的基本功能和面向 web 的应用上下文，比如多部分（multipart）文件上传功能、使用 Servlet 监听器初始化 IoC 容器等。它还包括 HTTP 客户端以及 Spring 远程调用中与 web 相关的部分。</li><li><strong>Web-MVC</strong> 模块为 web 应用提供了模型视图控制（MVC）和 REST Web服务的实现。Spring 的 MVC 框架可以使领域模型代码和 web 表单完全地分离，且可以与 Spring 框架的其它所有功能进行集成。</li><li><strong>Web-Socket</strong> 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</li><li><strong>Web-Portlet</strong> 模块提供了用于 Portlet 环境的 MVC 实现，并反映了 spring-webmvc 模块的功能。</li></ul><hr><h3 id="Spring-框架的优点"><a href="#Spring-框架的优点" class="headerlink" title="Spring 框架的优点"></a>Spring 框架的优点</h3><ol><li>非侵入式设计</li><li>方便解耦、简化开发</li><li>支持AOP</li><li>支持声明式事务处理</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>降低Jave EE API的使用难度。</li></ol><p><font color=#008000>说到 spring 的容器管理就不得不先提一下 bean 的概念</font></p><h3 id="Bean-的概念"><a href="#Bean-的概念" class="headerlink" title="Bean 的概念"></a>Bean 的概念</h3><ol><li>在 Java 中，“Bean”是对“可重用组件”的惯用叫法。组件本身就是一个抽象概念，Bean 作为其代称，也是一个抽象概念，当我们将一个类或一个对象作为组件来考虑时，就可以称它为 Bean。</li><li>在 Spring 中，Bean 的概念同上，它有时也被称为 Component。由 Spring 容器管理的 Bean 则称为 Spring Bean。</li></ol><p><strong>扩展：</strong></p><ul><li><p><em>Java Bean</em> 的概念不同于 Bean，Java Bean 是指符合 <em>JavaBeans</em> 规范的一类特殊的 Bean，即：所有属性均为 private，提供 getter 和 setter，提供默认构造方法。JavaBean 也可以认为是遵循特定约定的 POJO。</p></li><li><p>POJO（Plain Ordinary Java Object）是指简单且普通的 Java 对象。严格来说，它不继承类，不实现接口，不处理业务逻辑，仅用于封装数据。</p></li></ul><p><font color=#008000>说到 spring 就不得不提到两个重要的概念</font></p><ul><li>IoC 【控制反转】</li><li>DI 【依赖注入】</li></ul><h3 id="IOC-与-DI"><a href="#IOC-与-DI" class="headerlink" title="IOC 与 DI"></a>IOC 与 DI</h3><h4 id="IOC-定义"><a href="#IOC-定义" class="headerlink" title="IOC 定义"></a>IOC 定义</h4><p>IoC（Inverse Of Control，控制反转）是一种设计思想，所谓控制反转，指的是对资源的控制方式进行反转。</p><p><strong>IOC 容器</strong>具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>【控制权在自己】：在 OOP 中，对象之间往往存在某种依赖关系，当一个对象依赖另一个对象时，传统 OOP 的做法是在它内部直接 <strong>new</strong> 一个出来，这种做法是由对象自己主动创建并管理依赖资源。</p><p>【控制权在 Spring 容器】：”控制反转”是指 <strong>new</strong> 实例工作不由程序员来做而是交给 Spring 容器来做。使得对象不再主动控制依赖资源，而是被动接受资源，IoC 要求将资源的控制权下放给 <strong>Ioc</strong> 容器，它将对资源进行集中管理，对象需要什么资源就从容器中取，或者让容器主动将资源注入进来。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>在 IoC 之后，对象与依赖资源之间不再具有强耦合性，资源可以被直接替换，而无需改动需求方的代码。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>在 Spring 中 <strong>BeanFactory</strong> 是 IOC 容器的实际代表者。【工厂模式】</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_20-38-32.png" alt=""></p><hr><h4 id="Spring-的两种-IoC-容器"><a href="#Spring-的两种-IoC-容器" class="headerlink" title="Spring 的两种 IoC 容器"></a>Spring 的两种 IoC 容器</h4><p>Spring 提供了两种 IoC 容器： BeanFactory 和 ApplicationContext </p><ul><li>BeanFactory 提供基本的 IoC 服务支持。</li><li>ApplicationContext 对 BeanFactory 进行了扩展与增强，除了拥有 BeanFactory 的所有能力外，还提供了许多高级特性，如事件发布、资源加载、国际化消息等。ApplicationContext 接口继承自 BeanFactory 接口，它的实现也是直接复用了 BeanFactory 的实现，因此可以说，ApplicationContext 是 BeanFactory 的增强版。</li></ul><p>两者在核心功能上的区别主要是默认的加载策略不同，这点区别几乎可以忽略不计，通常情况下，我们总是使用更为强大的 ApplicationContext，很少会直接使用 BeanFactory。</p><h4 id="IoC-的两种实现方式"><a href="#IoC-的两种实现方式" class="headerlink" title="IoC 的两种实现方式"></a>IoC 的两种实现方式</h4><ul><li>DI（Dependency Injection，依赖注入）<br>所谓依赖注入，是指对象所依赖的资源将通过被动注入的方式得到，换言之，容器会主动地根据预先配置的依赖关系将资源注入进来。</li><li>DL（Dependency Lookup，依赖查找）<br>依赖查找是早先提出的一种 IoC 实现方式，它要求对象主动查找依赖资源，这种方式已经不再使用。</li></ul><h4 id="DI-定义"><a href="#DI-定义" class="headerlink" title="DI 定义"></a>DI 定义</h4><p>Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>依赖注入主要有两种实现方式，分别是属性 setter 注入和构造方法注入</p><ol><li><strong>属性 setter 注入</strong></li></ol><p>指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。</p><ol start="2"><li><strong>构造方法注入</strong></li></ol><p>指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。</p><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p><hr><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h4 id="AOP-的定义"><a href="#AOP-的定义" class="headerlink" title="AOP 的定义"></a>AOP 的定义</h4><ol><li><p>AOP（面向切面编程），它是利用对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p></li><li><p>AOP 采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存）</p></li></ol><p><strong>AOP：面向切面编程【底层就是动态代理】，指程序在运行期间动态的将某段代码切入到指定方法位置进行的编程方式。</strong></p><h4 id="AOP-的优势"><a href="#AOP-的优势" class="headerlink" title="AOP 的优势"></a>AOP 的优势</h4><ol><li>减少重复的代码</li><li>提供开发的效率</li><li>维护方便</li></ol><h4 id="AOP-体系"><a href="#AOP-体系" class="headerlink" title="AOP 体系"></a>AOP 体系</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-24_20-13-10.png" alt=""></p><h4 id="AOP-的使用场景"><a href="#AOP-的使用场景" class="headerlink" title="AOP 的使用场景"></a>AOP 的使用场景</h4><p><strong>日志场景</strong></p><ul><li>诊断上下文，如：【log4j 或 logback 】</li><li>辅助信息，如：方法执行时间 【System.currentTimeMillis()】</li></ul><p><strong>统计场景</strong></p><ul><li>方法调用次数</li><li>执行异常次数</li><li>数据抽样</li><li>数值累加</li></ul><p><strong>安防场景</strong></p><ul><li>熔断，如：【Netflix Hystrix】</li><li>限流和降级：如：【Alibaba Sentinel】</li><li>认证和授权，如：【Spring Security】</li><li>监控，如：【JMX】</li></ul><p><strong>性能场景</strong></p><ul><li><p>缓存，如 【Spring Cache】</p></li><li><p>超时控制</p></li></ul><h4 id="AOP-的底层原理"><a href="#AOP-的底层原理" class="headerlink" title="AOP 的底层原理"></a>AOP 的底层原理</h4><p><strong>JDK的动态代理技术（主要）</strong></p><ol><li>为接口创建代理类的字节码文件</li><li>使用 ClassLoader 将字节码文件加载到 JVM</li><li>创建代理类实例对象，执行对象的目标方法</li></ol><h4 id="AOP-的重要名词"><a href="#AOP-的重要名词" class="headerlink" title="AOP 的重要名词"></a>AOP 的重要名词</h4><ol><li><p><strong>【 Joinpoint 】连接点</strong> </p><p>所谓连接点是指那些被拦截到的点。在spring中指的是所有方法,因为spring只支持方法类型的连接点。</p></li><li><p><strong>【 Pointcut 】切入点</strong></p><p> （编写切入点表达式），程序增强的入口。</p></li><li><p><strong>【 Advice 】通知/增强</strong></p><p>对spring中方法要进行增强，编写事务管理相关代码。</p></li><li><p><strong>【 Target 】目标对象</strong></p><p>代理的目标对象</p></li><li><p><strong>【 Weaving 】织入</strong></p><p>是指把增强应用到目标对象来创建新的代理对象的过程</p></li><li><p><strong>【 Proxy 】代理</strong></p><p>一个类被AOP织入增强后，就产生一个结果代理类</p></li><li><p><font color=#FF8C00>Aspect(切面) = 切入点 + 通知</font></p></li></ol><h4 id="AOP-通知执行顺序"><a href="#AOP-通知执行顺序" class="headerlink" title="AOP 通知执行顺序"></a>AOP 通知执行顺序</h4><h5 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h5><p><strong>正常情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-25_01-29-28.png" alt=""></p><p><strong>异常情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-25_01-29-42.png" alt=""></p><p><strong>多个切面的情况（假设正常情况）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-25_01-29-12.png" alt=""></p><h5 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h5><p>从 Spring 5.2.7 开始，Spring AOP 不再严格按照 AspectJ 定义的规则来执行 advice，而是根据其类型按照从高到低的优先级进行执行：@Around，@Before ，@After，@AfterReturning，@AfterThrowing</p><h5 id="1、单个切面类"><a href="#1、单个切面类" class="headerlink" title="1、单个切面类"></a>1、单个切面类</h5><p><strong>Spring 5.28：</strong><br>　　　　正常情况：around 环绕前置 ==&gt; @Before ==&gt; target 目标方法执行 ==&gt; @AfterReturning ==&gt; @After ==&gt; around 环绕返回 ==&gt; around 环绕最终<br>　　　　异常情况：around 环绕前置 ==&gt; @Before ==&gt; target 目标方法执行 ==&gt; @AfterThrowing ==&gt; @After ==&gt; around 环绕异常 ==&gt; around 环绕最终</p><h5 id="2、多个切面"><a href="#2、多个切面" class="headerlink" title="2、多个切面"></a>2、多个切面</h5><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-25_01-05-02.png" style="zoom:80%;" /><p><strong>Spring 5.28：</strong><br>　　　　正常情况：切面1环绕前置 ==&gt; 切面1@Before ==&gt; 切面2环绕前置 ==&gt; 切面2@Before ==&gt; 目标方法执行 ==&gt; 切面2@AfterReturning ==&gt; 切面2@After ==&gt; 切面2环绕返回 ==&gt; 切面2环绕最终 ==&gt; 切面1@AfterReturning ==&gt; 切面1@After ==&gt; 切面1环绕返回 ==&gt; 切面1环绕最终<br>　　　　异常情况：切面1环绕前置 ==&gt; 切面1@Before ==&gt; 切面2环绕前置 ==&gt; 切面2@Before ==&gt; 目标方法执行 ==&gt; 切面2@AfterThrowing ==&gt; 切面2@After ==&gt; 切面2环绕异常 ==&gt; 切面2环绕最终 ==&gt; 切面1@AfterThrowing ==&gt; 切面1@After ==&gt; 切面1环绕异常 ==&gt; 切面1环绕最终</p><h5 id="3、-Order注解指定先后顺序"><a href="#3、-Order注解指定先后顺序" class="headerlink" title="3、@Order注解指定先后顺序"></a>3、@Order注解指定先后顺序</h5><p>数字越小，优先级越高，先进后出</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(value = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceProxy</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Order</span>(value = <span class="number">0</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceProxy2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结果： </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 切面二：环绕前置通知</span></span><br><span class="line"><span class="comment"> * 切面二：<span class="doctag">@Before</span></span></span><br><span class="line"><span class="comment"> * 切面一：环绕前置通知</span></span><br><span class="line"><span class="comment"> * 切面一：<span class="doctag">@Before</span></span></span><br><span class="line"><span class="comment"> * 目标方法执行</span></span><br><span class="line"><span class="comment"> * 切面一：<span class="doctag">@AfterReturning</span></span></span><br><span class="line"><span class="comment"> * 切面一：<span class="doctag">@After</span></span></span><br><span class="line"><span class="comment"> * 切面一：环绕返回通知</span></span><br><span class="line"><span class="comment"> * 切面一：环绕最终通知</span></span><br><span class="line"><span class="comment"> * 切面二：<span class="doctag">@AfterReturning</span></span></span><br><span class="line"><span class="comment"> * 切面二：<span class="doctag">@After</span></span></span><br><span class="line"><span class="comment"> * 切面二：环绕返回通知</span></span><br><span class="line"><span class="comment"> * 切面二：环绕最终通知</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p> <strong>由此得出：</strong></p><p>spring aop 就是一个同心圆，要执行的方法为圆心，最外层的 order 最小。</p><h4 id="AOP-实践"><a href="#AOP-实践" class="headerlink" title="AOP 实践"></a>AOP 实践</h4><p>AOP看起来很麻烦, 只要3步就可以了:</p><ol><li>将业务逻辑组件和切面类都加入到容器中, 告诉spring哪个是切面类(@Aspect)</li><li>在切面类上的每个通知方法上标注通知注解, 告诉Spring何时运行(写好切入点表达式,参照官方文档)</li><li>开启基于注解的AOP模式 @EableXXXX</li></ol><h5 id="1、引入-Aop-的依赖"><a href="#1、引入-Aop-的依赖" class="headerlink" title="1、引入 Aop 的依赖"></a>1、引入 Aop 的依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、编写-Aop-切面类"><a href="#2、编写-Aop-切面类" class="headerlink" title="2、编写 Aop 切面类"></a>2、编写 Aop 切面类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span></span><br><span class="line"><span class="comment">     * 切点的集合，这个表达式所描述的是一个虚拟面（规则）</span></span><br><span class="line"><span class="comment">     * 就是为了Annotation扫描时能够拿到注解中的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * execution函数用于匹配方法执行的连接点，语法为：</span></span><br><span class="line"><span class="comment">     * execution(方法修饰符(可选)  返回类型  方法名  参数  异常模式(可选))</span></span><br><span class="line"><span class="comment">     * 参数部分允许使用通配符：</span></span><br><span class="line"><span class="comment">     * *  匹配任意字符，但只能匹配一个元素</span></span><br><span class="line"><span class="comment">     * .. 匹配任意字符，可以匹配任意多个元素，表示类时，必须和*联合使用</span></span><br><span class="line"><span class="comment">     * +  必须跟在类名后面，如Horseman+，表示类本身和继承或扩展指定类的所有类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.ase.aop.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置环绕通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms with exception : "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知: 在目标方法()运行之前运行 (<span class="doctag">@Before</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"before: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：在目标方法()运行结束之后运行,无论正常或异常结束 (<span class="doctag">@After</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"after: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：在目标方法()正常返回之后运行 (<span class="doctag">@AfterReturning</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfterReturn</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"afterReturn: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：在目标方法()出现异常后运行(<span class="doctag">@AfterThrowing</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"aspect()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception ex)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"afterThrow: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">        log.info(<span class="string">"message: &#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、编写切点方法"><a href="#3、编写切点方法" class="headerlink" title="3、编写切点方法"></a>3、编写切点方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/aop"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">api1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">"nowTime"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、结果"><a href="#4、结果" class="headerlink" title="4、结果"></a>4、结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] o.s.web.servlet.DispatcherServlet        : Initializing Servlet <span class="string">'dispatcherServlet'</span></span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] o.s.web.servlet.DispatcherServlet        : Completed initialization in <span class="number">0</span> ms</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] com.ase.aop.config.LogAspect             : before: execution(Map com.ase.aop.controller.BaseController.api1())</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] com.ase.aop.controller.BaseController    : map = &#123;nowTime=<span class="number">2021</span>-<span class="number">07</span>-<span class="number">24</span> <span class="number">20</span>:<span class="number">37</span>:<span class="number">05</span>&#125;</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] com.ase.aop.config.LogAspect             : afterReturn: execution(Map com.ase.aop.controller.BaseController.api1())</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] com.ase.aop.config.LogAspect             : after: execution(Map com.ase.aop.controller.BaseController.api1())</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">2</span>] com.ase.aop.config.LogAspect             : <span class="function">around <span class="title">execution</span><span class="params">(Map com.ase.aop.controller.BaseController.api1()</span>)Use time : 16 ms!</span></span><br></pre></td></tr></table></figure><h5 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h5><p><strong>JoinPoint 对象封装了 Spring Aop 中切面方法的信息</strong>,在切面方法中添加 JoinPoint 参数,就可以获取到封装了该方法信息的JoinPoint对象.。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>Signature getSignature()</td><td>获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息</td></tr><tr><td>Object[] getArgs()</td><td>获取传入目标方法的参数对象</td></tr><tr><td>Object getTarget()</td><td>获取被代理的对象</td></tr><tr><td>Object getThis()</td><td>获取代理对象</td></tr></tbody></table><h4 id="使用-annotation（注解）"><a href="#使用-annotation（注解）" class="headerlink" title="使用 annotation（注解）"></a>使用 annotation（注解）</h4><p>可以定义一个注解，注解分为两部分 :</p><p>① 元注解 ; ② public @interface 注解名称 ;</p><h5 id="annotation-注解属性"><a href="#annotation-注解属性" class="headerlink" title="annotation 注解属性"></a>annotation 注解属性</h5><p>注解的本质是接口 , 接口中可以定义 常量 和 方法 ;</p><p>在注解中定义 接口方法 , 就是 注解的属性 ;</p><p>为注解添加属性 : 接口中的方法都是抽象方法 , 其中 public abstract 可以省略 ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)            <span class="comment">//  注解用于字段上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)    <span class="comment">// 保留到运行时，可通过注解获取</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"><span class="comment">//public abstract String path();</span></span><br><span class="line">    <span class="function">String <span class="title">path</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解属性使用格式 :</p><blockquote><p>@注解名称(属性名称 = 属性值)</p></blockquote><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(path = <span class="string">""</span>)</span><br><span class="line">MyMethods(String arg)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="annotation-注解属性类型"><a href="#annotation-注解属性类型" class="headerlink" title="annotation 注解属性类型"></a>annotation 注解属性类型</h5><p>注解属性 ( 接口方法 ) 返回值类型要求 :</p><p>① 基本数据类型 : byte , short , int , long , float , double , char , boolean ;</p><p>② 字符串类型 : String ;</p><p>③ 枚举类型 : enum ;</p><p>④ 注解类型 ;</p><p>⑤ 以上类型的数组形式 ;</p><p><strong>注解属性返回值必须是以上的类型 , 不能设置其它类型返回值 , 否则会报错 ;</strong></p><p>定义 注解属性 时 , 可以 使用 default 关键字 指定属性默认值 </p><p>举个荔枝：注解属性 intValue 值类型为 int 整型 , 默认值 100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>如果 注解属性指定了默认值 , 在使用注解时 , 可以选择不为该属性赋值 ( 此时使用默认属性值 ) , 也可以进行赋值 ( 指定一个新的属性值 ) ;</p><p>如果 注解属性没有指定默认值 , 则使用注解 时 , 必须为其指定一个默认值 , 否则编译时报错 ;</p><p>如果 注解属性名称是 value , 并且 注解中只有 1 个属性 , 那么在使用注解为注解属性赋值时 , 可以省略注解名称 , 直接传入注解属性值 ;</p><h5 id="annotation-反射获取注解"><a href="#annotation-反射获取注解" class="headerlink" title="annotation 反射获取注解"></a>annotation 反射获取注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"Annotation 自定义注解测试"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用我们的自定义注解</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(path = <span class="string">"Annotation-Aop"</span>)</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"自定义注解"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAnnotationTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类模板</span></span><br><span class="line">        Class c = MyAnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有字段</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="comment">// 判断这个字段是否有MyField注解</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(MyAnnotation<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">                MyAnnotation annotation = field.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                log.info(<span class="string">"字段:["</span> + field.getName() + <span class="string">"], 描述:["</span> + annotation.path() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[main] INFO com.ase.aop.annotation.MyAnnotationTest - 字段:[path], 描述:[Annotation-Aop]</span><br></pre></td></tr></table></figure><h4 id="Log-日志实践"><a href="#Log-日志实践" class="headerlink" title="Log 日志实践"></a>Log 日志实践</h4><h5 id="1、引入-Aop-的依赖-1"><a href="#1、引入-Aop-的依赖-1" class="headerlink" title="1、引入 Aop 的依赖"></a>1、引入 Aop 的依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、自定义注解"><a href="#2、自定义注解" class="headerlink" title="2、自定义注解"></a>2、自定义注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)            <span class="comment">//  注解用于字段上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)    <span class="comment">// 保留到运行时，可通过注解获取</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyLog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、编写-Aop-切面类"><a href="#3、编写-Aop-切面类" class="headerlink" title="3、编写 Aop 切面类"></a>3、编写 Aop 切面类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点,该方法无方法体,主要为方便同类中其他方法使用此处配置的切入点</span></span><br><span class="line"><span class="comment">     * 切点的集合，这个表达式所描述的是一个虚拟面（规则）</span></span><br><span class="line"><span class="comment">     * 就是为了Annotation扫描时能够拿到注解中的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.ase.aop.annotation.MyLog)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置环绕通知,使用在方法aspect()上注册的切入点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 获取方法名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取入参</span></span><br><span class="line">        Object[] param = joinPoint.getArgs();</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(Object o : param)&#123;</span><br><span class="line">            sb.append(o + <span class="string">"; "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"进入["</span> + methodName + <span class="string">"]方法,参数为:"</span> + sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续执行方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((ProceedingJoinPoint) joinPoint).proceed();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"around "</span> + joinPoint + <span class="string">"\tUse time : "</span> + (end - start) + <span class="string">" ms with exception : "</span> + throwable.getMessage());</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(methodName , <span class="string">"&#123;&#125; 方法执行结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知: 在目标方法(div)运行之前运行 (<span class="doctag">@Before</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logStart</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"before: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：在目标方法(div)运行结束之后运行,无论正常或异常结束 (<span class="doctag">@After</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"after: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：在目标方法(div)正常返回之后运行 (<span class="doctag">@AfterReturning</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAfterReturn</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"afterReturn: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：在目标方法(div)出现异常后运行(<span class="doctag">@AfterThrowing</span>)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(pointcut = <span class="string">"aspect()"</span>, throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logException</span><span class="params">(JoinPoint joinPoint, Exception ex)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"afterThrow: &#123;&#125;"</span>, joinPoint);</span><br><span class="line">        log.info(<span class="string">"message: &#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、编写切点方法"><a href="#4、编写切点方法" class="headerlink" title="4、编写切点方法"></a>4、编写切点方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/aop"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">aop1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">"nowTime"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        log.info(<span class="string">"map = "</span> + map);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyLog</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/aop2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">aop2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">"nowTime"</span>, LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)));</span><br><span class="line">        log.info(<span class="string">"map = "</span> + map);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、结果"><a href="#5、结果" class="headerlink" title="5、结果"></a>5、结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入[aop2]方法,参数为:</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.ase.aop.config.LogAspect             : before: execution(Map com.ase.aop.controller.BaseController.aop2())</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.ase.aop.controller.BaseController    : map = &#123;nowTime=<span class="number">2021</span>-<span class="number">07</span>-<span class="number">25</span> <span class="number">00</span>:<span class="number">04</span>:<span class="number">02</span>&#125;</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.ase.aop.config.LogAspect             : afterReturn: execution(Map com.ase.aop.controller.BaseController.aop2()) </span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.ase.aop.config.LogAspect             : after: execution(Map com.ase.aop.controller.BaseController.aop2())</span><br><span class="line">[nio-<span class="number">8080</span>-exec-<span class="number">1</span>] com.ase.aop.config.LogAspect             : <span class="function">around <span class="title">execution</span><span class="params">(Map com.ase.aop.controller.BaseController.aop2()</span>)Use time : 17 ms!</span></span><br><span class="line"><span class="function">[nio-8080-exec-1] com.ase.aop.config.LogAspect             : aop2方法执行结束</span></span><br></pre></td></tr></table></figure><h5 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h5><p><strong>在编写的切点方法中只有标注了自定义的注解 MyLog 的 aop2 切点方法才会被 Aop 切面所处理</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇Java小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Spring 框架&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;br&gt;

&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百度百科：&lt;/p&gt;
&lt;p&gt;Spring 框架是由于软件开发的复杂性而创建的。&lt;/p&gt;
&lt;p&gt;Spring 使用的是基本的&lt;code&gt;JavaBean&lt;/code&gt;来完成以前只可能由&lt;code&gt;EJB&lt;/code&gt;完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="https://codeyg.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://codeyg.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--TCP 3次挥手与4次握手</title>
    <link href="https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2021-06-16T13:58:58.000Z</published>
    <updated>2021-07-22T08:59:20.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 TCP 3次挥手与4次握手 ：</strong> 但不局限于介绍 TCP~</p><hr><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>划重点</strong></p><p><font color=#008000><code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议</font></p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。</p><p>那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。</p><a id="more"></a><h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1612150605-NindRH-image.png" style="zoom:67%;" /><hr><p>由上至下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP-头部包含哪些信息"><a href="#HTTP-头部包含哪些信息" class="headerlink" title="HTTP 头部包含哪些信息"></a>HTTP 头部包含哪些信息</h4><p>HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p><p>下面重点来说一下我们熟悉的 “实体头部” </p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td><strong>Content-Type</strong></td><td><strong>返回内容的MIME类型</strong></td><td><strong>Content-Type: text/html; charset=utf-8</strong></td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><hr><h4 id="POST-和-Get-的区别"><a href="#POST-和-Get-的区别" class="headerlink" title="POST 和 Get 的区别"></a>POST 和 Get 的区别</h4><p>我们知道，HTTP定义了与服务器进行交互的不同方法，常见的有四种：GET、POST、PUT、DELETE。其中，GET 和 POST 最常用。</p><ul><li><code>GET</code> 用来获取资源，它只是获取、查询数据，不会修改服务器的数据。</li><li><code>POST</code> 则是可以向服务器发送修改请求，进行数据的修改的。</li></ul><h5 id="从性能角度"><a href="#从性能角度" class="headerlink" title="从性能角度"></a>从性能角度</h5><ol><li>post 携带的请求头更多；</li><li>握手次数 post：get （6 : 4）；</li><li>get 保存数据（Ajax），post则不会；</li></ol><h5 id="从安全角度"><a href="#从安全角度" class="headerlink" title="从安全角度"></a>从安全角度</h5><ol><li>post 更加的安全（请求数据不会作为 url 的一部分，缓存、日志等）</li><li>post 发送的数据量更大，get 有 url 的长度限制；</li><li>post 发送的更多的数据类型 ， get 只能是 ASCLL；</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>我们常说的一些区别都是一些表面上的。</p><p>比如：<code>GET</code>没有<code>POST</code>安全；<code>GET</code>请求时<code>URL</code>的长度是有限制的；<code>GET</code>没有<code>body</code>而<code>POST</code>有<code>body</code>等等。</p><p>这些都是针对浏览器中的要求， 在使用<code>HTTP</code>作为接口进行传输时，就没有这么多条条框框了。</p><p>此时<code>GET</code>和<code>POST</code>只是<code>HTTP</code>协议中的两种请求方式，而<code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议， 无论<code>GET</code>还是<code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别。</p><p><code>GET</code>也可以有<code>body</code>，<code>POST</code>也不一定非要使用<code>body</code></p><hr><h4 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h4><p><font color=#008000>HTTP 和 HTTPS 的区别有哪些？</font></p><p>最明显直观的就是在网页上访问网址，地址栏位的 url 显示区别</p><ul><li>如果是 http 请求，则显示为不安全</li><li>如果是 https 请求，则显示为安全</li></ul><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。</p><p><strong>HTTP报文格式</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/http_get_post.png" style="zoom:67%;" /><h5 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h5><p><strong>HTTPS = SSL + HTTP</strong></p><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><strong>Http：</strong></p><ul><li>无状态 【是指协议对于交互性场景没有记忆能力、cookie / session 让服务器有记忆能力】</li><li>无连接 【限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接】</li><li>基于请求和响应</li><li>简单快速</li><li>使用明文通信（不会确认通信方）</li></ul><p><strong>Https:</strong></p><ul><li>通过 SSL / TLS 提供加密</li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol><li>Https更加的安全</li><li>Https需要申请证书</li><li>端口不同：http =&gt; 80； https =&gt; 443；</li><li>状态不同：http =&gt; 无状态； https =&gt; 协议加密；</li></ol><h5 id="HTTP通信传输"><a href="#HTTP通信传输" class="headerlink" title="HTTP通信传输"></a>HTTP通信传输</h5><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_00-36-54.png" alt=""></p><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手经典图例（客户端请求服务端获取数据）</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-13-48.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【seq】序号</p><p>【ack】确认序号</p><p>【SYN】同步                                                        </p><p>【ACK】确认</p><p><strong>三次握手</strong></p><ul><li><p>第一次握手：客户端首先向服务端发送请求，tcp 报文头中发送标识 SYN=1 (SYN表示客户端请求跟服务端建立连接),序号 Seq=x。</p></li><li><p>第二次握手：服务端在接收到客户端发送的请求之后，需要告诉客户端已收到请求，tcp 报文头中发送标识SYN=1,ACK=1(SYN表示服务端请求跟客户端建立连接，ACK 表示对客户端的连接请求进行应答),序号 Seq=y,确认号=x+1（表示对客户端发送的序号Seq=x的请求进行确认）。</p></li><li><p>第三次握手：客户端在接收到服务端发送的请求和确认信息之后，同样需要告诉服务端已收到信息，tcp 报文头中发送标识 ACK=1(ACK表示对服务端的连接请求进行应答),序号 Seq=x+1，确认号 Ack=y+1（表示对服务端发送的序号 Seq=y 的请求进行确认）</p><p>当三次握手都成功的时候，我们发现此时客户端发送的信息服务端能够收到并且服务端发送的信息客户端也能收到，通信双方<strong>连接成功</strong>。</p></li></ul><p><strong>注意</strong></p><ol><li>发送请求中的发送标识SYN、ACK表示的是发送报文中两个标识位！而Seq和Ack分别代表发送序号和确认号。</li><li>服务端在接收到了客户端的连接请求后，回复中同时发送了SYN、ACK两个标识位，将建立连接的请求和对客户端的确认应答在同一个数据包中发送了，这也是为什么只需要三次握手，就能建立连接</li></ol><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><font color=#008000>当客户端和服务端之间的数据传输完毕之后，我们就需要释放连接（一直建立连接会浪费资源），那为啥需要四次挥手呢？</font></p><p>四次挥手经典图例</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-35-29.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【MSL】报文最大生存时间 （它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃）</p><p><strong>四次挥手</strong></p><ul><li><p>第一次挥手：客户端向服务端发送断开连接的请求，告诉服务端我这边不需要再请求你的数据了，tcp报文头中发送标识FIN=1（表示客户端请求跟服务端断开连接）,序号Seq=u</p></li><li><p>第二次挥手：服务端在接收到客户端发送的断开请求后，需告诉客户端已收到请求，tcp报文头中发送标识ACK=1(ACK表示对客户端的断开连接的请求进行应答),序号Seq=v,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）。</p></li><li><p>第三次挥手：当服务端数据传输完毕之后，向客户端发起断开连接的请求，告诉客户端我这边也不需要再发送数据了，tcp报文头中发送标识FIN=1，ACK=1(FIN表示服务端请求跟客户端断开连接，ACK表示对上一次客户端的断开连接的请求进行应答),序号Seq=w,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）</p></li><li><p>第四次挥手：客户端接收到服务发送的断开连接请求后，需告诉服务端已收到信息，作出应答，tcp报文头中发送标识ACK=1(ACK表示对服务端的断开连接的请求进行应答),序号Seq=u+1,确认号Ack=w+1（表示对服务端发送的序号Seq=w的请求进行确认）</p></li></ul><p><font color=#008000>1. 为什么不能像握手的时候一样三次握手，为啥需要四次挥手呢？</font></p><p>答：在实际的网络中，服务端在接收到客户端断开连接的请求的时候，此时服务端可能还有数据没有传输完毕，不能立即向客户端发送断开连接的请求！</p><p>当客户端主动发起断开请求的时候，服务器先回应一个确认，等所有数据传输完毕后再发送服务器断开的请求。</p><p><font color=#008000>2. 为什么需要维持2MSL呢？</font></p><p>答：第4次挥手的时候客户端向服务端发送断开连接的请求的确认ACK，如果客户端发送完成后就直接就关闭连接，如果由于网络原因服务端没有收到ACK，那服务端就没法关闭连接了！</p><p>因此客户端在回复确认后，还需要等待，万一服务端没有收到应答还会继续发送断开连接的请求；</p><hr><h4 id="TCP-长连接和短连接"><a href="#TCP-长连接和短连接" class="headerlink" title="TCP 长连接和短连接"></a>TCP 长连接和短连接</h4><p><strong>长连接</strong>：</p><p> 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。 </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-09-20.png" alt=""></p><p><strong>短连接</strong>：</p><p>短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-08-13.png" alt=""></p><p><strong>应用场景：</strong></p><p> 长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况。</p><p>例如：</p><ul><li>数据库的连接用长连接（如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费）</li><li>微信，QQ 之类的即时通讯（文本消息、语音消息、视频消息、图片消息）。</li></ul><p>短连接多用于 WEB 网站的 http 服务。</p><p>因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。</p><hr><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>无连接协议，也称透明协议，也位于传输层。</p><p><strong>UDP 与 TCP 区别</strong>：</p><ol><li><p>TCP 提供面向连接的传输，通信前要先建立连接（三次握手机制）； </p><p>UDP 提供无连接的传输，通信前不需要建立连接。</p></li><li><p>TCP 提供可靠的传输（有序，无差错，不丢失，不重复）；</p><p> UDP 提供不可靠的传输。</p></li><li><p>TCP 面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； </p><p>UDP 是面向数据报的传输，没有分组开销。</p></li><li><p>TCP 提供拥塞控制和流量控制机制； </p><p>UDP 不提供拥塞控制和流量控制机制。</p></li></ol><p><strong>对比</strong></p><table><thead><tr><th align="left"></th><th align="left">UDP</th><th align="left">TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td align="left">面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td align="left">可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td align="left">只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td align="left">面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td align="left">首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td align="left">适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP协议（Internet Protocol，互联网协议），是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p><ul><li><p>IP 就是一张身份证，存在于电脑、手机、监控摄像头、汽车等任何需要联网的设备上面；</p></li><li><p>IP 是可以被追踪到和定位的；</p></li></ul><p>面试的时候有面试官聊到关于网络相关考点，于是问道：</p><p><font color=#008000>能说出访问一个网页的全过程？</font></p><p>答：打开浏览器，在地址栏输入URL，回车，出现网页内容。</p><p>太笼统了，要具体！</p><p><font color=#008000>在地址栏输入URL后，整个过程发生了什么？其中的原理是什么？</font></p><p>答：整个过程可以概括为几下几个部分：</p><ol><li>通过解析域名找到 IP，如果缓存里没有就要请求 DNS 服务器得到 IP 地址；</li><li>与目的主机进行 TCP 连接（三次握手）构建 HTTP 请求；</li><li>发送与收取数据（浏览器与目的主机开始HTTP访问过程）；</li><li>与目的主机断开 TCP 连接（四次挥手）；</li></ol><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p><font color=#008000>能简单说说域名解析？并且一个域名可以对应多个IP地址吗？</font></p><p>域名通过 <code>DNS</code> 解析 得到 <code>IP</code> </p><p>首先得知道啥是 DNS ？</p><p>DNS（Domain Name System）是因特网的一项服务，它作为域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>解析域名</li></ul><p>人们在通过浏览器访问网站时只需要记住网站的域名即可，而不需要记住那些不太容易理解的IP地址。</p><p>在DNS系统中有一个比较重要的的资源类型叫做主机记录也称为A记录，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p><ul><li>负载均衡</li></ul><p>DNS除了能解析域名之外还具有负载均衡的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-49-29.png" alt=""></p><hr><p>由上图可以看出，在 DNS 服务器中应该配置了多个A记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.apusapp.com IN A 114.100.20.201;</span><br><span class="line">www.apusapp.com IN A 114.100.20.202;</span><br><span class="line">www.apusapp.com IN A 114.100.20.203;</span><br></pre></td></tr></table></figure><p>每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。</p><p>一个域名可以对应多个IP地址。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 TCP 3次挥手与4次握手 ：&lt;/strong&gt; 但不局限于介绍 TCP~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;划重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;&lt;code&gt;HTTP&lt;/code&gt;协议是基于&lt;code&gt;TCP/IP&lt;/code&gt;的应用层协议&lt;/font&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。&lt;/p&gt;
&lt;p&gt;那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="计算机网络" scheme="https://codeyg.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--锁（Lock）</title>
    <link href="https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/"/>
    <id>https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/</id>
    <published>2021-06-15T13:58:58.000Z</published>
    <updated>2021-06-20T18:07:51.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 Java 中的锁：</strong></p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>面试中我们都会遇到一个场景：</p><p><font color=#008000>在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？</font></p><p>很多人脑海里最先想到的一定是“加锁”。</p><p>提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。</p><p><font color=#008000>除了使用 sychronized 关键字，还有其他的解决方案吗？</font></p><p>JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。</p><p>JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。</p><p>下面我们来详细的介绍一下 “锁”</p><hr><a id="more"></a><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-13-50.png"  /><hr><h3 id="Java-的主流锁都有哪些"><a href="#Java-的主流锁都有哪些" class="headerlink" title="Java 的主流锁都有哪些"></a>Java 的主流锁都有哪些</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/lock.png" style="zoom: 67%;" /><p>悲观锁、乐观锁、自旋锁、偏向锁、轻量级锁、重量级锁、公平锁、非公平锁、可重入锁、非可重入锁。</p><h4 id="1、乐观锁-VS-悲观锁"><a href="#1、乐观锁-VS-悲观锁" class="headerlink" title="1、乐观锁 VS 悲观锁"></a>1、乐观锁 VS 悲观锁</h4><p>顾名思义，两种锁的名字分别体现了看待线程同步的不同角度。</p><p>对于同一个数据的并发操作：</p><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/optimistic_pessimistic.png" style="zoom:50%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 1、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 操作同步资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、ReentrantLock</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止因为没有获取到锁的情况，finally中lock.unlock()去释放锁，导致出错！</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 操作同步资源</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">optimistic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();  <span class="comment">//执行自增1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。</p><p><font color=#008000>为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</font></p><p>答：乐观锁的主要实现方式 “CAS” 的技术原理实现。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p><p>java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。所以对于乐观锁，“更新”是一个不断重试的操作。</p><p>那么我们进入原子类 AtomicInteger 的源码，看一下 AtomicInteger 的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-15_23-27-12.png" alt=""></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储 value 在 AtomicInteger 中的偏移量。</li><li>value： 存储 AtomicInteger 的 int 值，该属性需要借助 volatile 关键字保证其在线程间是可见的。</li></ul><h6 id="CAS虽然很高效，但是它也存在三大问题"><a href="#CAS虽然很高效，但是它也存在三大问题" class="headerlink" title="CAS虽然很高效，但是它也存在三大问题"></a>CAS虽然很高效，但是它也存在三大问题</h6><ol><li>ABA问题</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ol><h6 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h6><p>加标志位，例如搞个⾃增的字段，操作⼀次就⾃增加⼀，或者搞个时间戳，⽐较时间戳的值。</p><p> 举个栗⼦：现在我们去要求操作数据库，根据CAS的原则我们本来只需要查询原本的值就好了，现在我 们⼀同查出他的标志位版本字段vision。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue where value &#x3D; #&#123;oldValue&#125;</span><br><span class="line"># oldValue就是我们执⾏前查询出来的值</span><br></pre></td></tr></table></figure><p>带版本号能防⽌ABA的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue ，vision &#x3D; vision + 1 where value &#x3D; #</span><br><span class="line">&#123;oldValue&#125; and vision &#x3D; #&#123;vision&#125;</span><br><span class="line"># 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不⼀样</span><br></pre></td></tr></table></figure><hr><h4 id="2、自旋锁-VS-适应性自旋锁"><a href="#2、自旋锁-VS-适应性自旋锁" class="headerlink" title="2、自旋锁 VS 适应性自旋锁"></a>2、自旋锁 VS 适应性自旋锁</h4><p><font color=#008000>为什么要有自旋锁和适应性自旋锁？</font></p><p>首先，阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spinlocks.png" style="zoom:50%;" /><p>虽然自旋锁有效的避免了因线程之间的切换而产生的开销，但是也并非没有缺点。</p><p>缺点就是它不能代替阻塞。而且它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好。</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次）没有成功获得锁，就应当挂起线程。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-09-40.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-11-25.png" alt=""></p><hr><p>自旋锁的实现原理同样也是CAS。</p><p>AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><h5 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h5><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</p></li><li><p>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。、</p></li></ul><hr><h4 id="3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h4><p>这四种锁是指锁的状态，专门针对synchronized的。</p><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/8afdf6f2.png" style="zoom:50%;" /><hr><h4 id="4、公平锁-VS-非公平锁"><a href="#4、公平锁-VS-非公平锁" class="headerlink" title="4、公平锁 VS 非公平锁"></a>4、公平锁 VS 非公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p><ul><li><p>优点：等待锁的线程不会饿死。</p></li><li><p>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p></li></ul><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p><ul><li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/fair_lock.png" style="zoom:50%;" /><hr><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/not_fair_lock.png" style="zoom: 67%;" /><hr><p>ReentrantLock的源码来看一下公平锁和非公平锁</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-32-49.png" alt=""></p><hr><h4 id="5、可重入锁-VS-非可重入锁"><a href="#5、可重入锁-VS-非可重入锁" class="headerlink" title="5、可重入锁 VS 非可重入锁"></a>5、可重入锁 VS 非可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁。</p><p>可重入锁的一个优点是可一定程度避免死锁。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 可重入锁 -------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。 </p><p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p><font color=#008000>为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？</font></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/reentrant_lock.png" style="zoom:50%;" /><p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/no_reentrant_lock.png" style="zoom:50%;" /><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><hr><h4 id="6、独享锁-VS-共享锁"><a href="#6、独享锁-VS-共享锁" class="headerlink" title="6、独享锁 VS 共享锁"></a>6、独享锁 VS 共享锁</h4><p>独享锁（排他锁）和共享锁同样是一种概念。</p><ul><li>独享锁是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</li><li>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-58-22.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-00-45.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-02-36.png" alt=""></p><hr><p>ReentrantReadWriteLock 有两把锁：</p><ul><li><p>ReadLock</p></li><li><p>WriteLock</p></li></ul><p>由词知意，一个读锁一个写锁，合称“读写锁”</p><p>最终发现在 ReentrantLock 虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Java 中的锁：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;面试中我们都会遇到一个场景：&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;很多人脑海里最先想到的一定是“加锁”。&lt;/p&gt;
&lt;p&gt;提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;除了使用 sychronized 关键字，还有其他的解决方案吗？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。&lt;/p&gt;
&lt;p&gt;JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。&lt;/p&gt;
&lt;p&gt;下面我们来详细的介绍一下 “锁”&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="锁" scheme="https://codeyg.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM垃圾回收机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T15:58:58.000Z</published>
    <updated>2021-06-20T18:32:48.750Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面</strong></p><p>为啥要写这篇文章呢？还要从很久之前的一次问答说起！</p><p><font color=#008000>什么是 Java 垃圾回收机制？（ JC 哥问我）</font></p><p>我：就是收集一些不被用到的对象，然后集中销毁吧~</p><p><font color=#008000>那应该如何来判断那些对象不被用到呢？</font></p><p>我：好像是 … … 我真的不知道</p><p><font color=#008000>仔细想想</font></p><p>我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？</p><p><font color=#008000>我就说嘛，想想能知道的，继续</font></p><p>我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？</p><p><font color=#008000>是个办法，具体呢？</font></p><p>我：xxx xxx</p><p>…</p><p>…</p><p>最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）</p><p><strong>本篇着重介绍一下JVM垃圾回收机制：</strong></p><hr><a id="more"></a><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><p>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。</p><p>在<code>JVM</code>中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p><font color=#008000>回去好好看一下什么是 GC ，那GC 是什么？</font></p><h3 id="GC-是什么？为什么要-GC"><a href="#GC-是什么？为什么要-GC" class="headerlink" title="GC 是什么？为什么要 GC"></a>GC 是什么？为什么要 GC</h3><p>GC 垃圾收集（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存。</p><p>不当的回收可能会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p><font color=#008000>首先来看一下 Java 中都有哪些引用类型吧</font></p><h3 id="Java-中的引用类型"><a href="#Java-中的引用类型" class="headerlink" title="Java 中的引用类型"></a>Java 中的引用类型</h3><ol><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ol><p><font color=#008000>我之前说通过标记位（flag）来判断对象是否被引用，算是说对了一点点吧</font></p><h3 id="如何判断对象是否可以被回收？什么时候被回收？"><a href="#如何判断对象是否可以被回收？什么时候被回收？" class="headerlink" title="如何判断对象是否可以被回收？什么时候被回收？"></a>如何判断对象是否可以被回收？什么时候被回收？</h3><p><strong>一般有两种方法来判断：</strong></p><ol><li><strong>引用计数器法</strong><br>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。但是他有一个缺点是不能解决循环引用的问题。</li></ol><ol start="2"><li><strong>可达性分析算法</strong><br>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ol><blockquote><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p></blockquote><p><font color=#008000>说了这么多，既然是算法都分别有哪些呢？</font></p><h3 id="JVM-的垃圾回收算法？"><a href="#JVM-的垃圾回收算法？" class="headerlink" title="JVM 的垃圾回收算法？"></a>JVM 的垃圾回收算法？</h3><ul><li><p>标记-清除算法</p></li><li><p>标记-复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代-收集算法</p></li></ul><h4 id="标记-清除算法（mark-sweep）"><a href="#标记-清除算法（mark-sweep）" class="headerlink" title="标记-清除算法（mark-sweep）"></a>标记-清除算法（mark-sweep）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>该算法分为两个阶段，<strong>标记和清除</strong>。</p><p>标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>执行速度快</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>执行效率不稳定，大量的标记、清除</li><li>内存碎片严重化，后续可能发生对象不能找到利用空间的问题</li></ol><h4 id="标记-复制算法（mark-cope）"><a href="#标记-复制算法（mark-cope）" class="headerlink" title="标记-复制算法（mark-cope）"></a>标记-复制算法（mark-cope）</h4><p>标记-复制算法也称为【半区复制】</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>按内存容量将内存划分为等大小的两块。</p><p>每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>内存连续</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>内存使用率不高，只有原来的一半，浪费内存空间</p><h4 id="标记-整理算法（mark-compact）"><a href="#标记-整理算法（mark-compact）" class="headerlink" title="标记-整理算法（mark-compact）"></a>标记-整理算法（mark-compact）</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>改进于标记-标记-清除算法，通过标记后将存活的对象移动向内存的一端，然后清除端边界外的对象。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>保证了内存的连续性，不会浪费内存。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li><p>效率低（需要移动内存对象）</p></li><li><p>移动时会有并发问题。</p></li></ol><p><font color=#008000>重点说一下分代-收集算法</font></p><h4 id="分代-收集算法（generation-collect）"><a href="#分代-收集算法（generation-collect）" class="headerlink" title="分代-收集算法（generation-collect）"></a>分代-收集算法（generation-collect）</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>根据对象存活周期的不同将内存划分为几块，一般是<strong>新生代</strong>和<strong>老年代</strong>，新生代基本采用标记-复制算法，老年代采用标记-整理算法和标记-清除算法。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_02-26-58.png" alt=""></p><p>新生代每次垃圾回收大偶会后大批的对象死去，每次回收存活后的少量对象在阈值将去到老年代。</p><h5 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h5><p><strong>对象优先在 Eden 区分配：</strong></p><p>多数情况，对象都在新生代 Eden 区分配。</p><p>当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。</p><p>如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><ul><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代</strong></p><p>新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。</p><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><p>大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。<br>        虚拟机提供了一个<code>XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用的是复制算法）。</p><p><strong>长期存活对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。</p><p>因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。</p><p>对象在 Survivor 区中每过一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为啥要写这篇文章呢？还要从很久之前的一次问答说起！&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是 Java 垃圾回收机制？（ JC 哥问我）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：就是收集一些不被用到的对象，然后集中销毁吧~&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;那应该如何来判断那些对象不被用到呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：好像是 … … 我真的不知道&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;仔细想想&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;我就说嘛，想想能知道的，继续&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;是个办法，具体呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：xxx xxx&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM垃圾回收机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM内存结构</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-13T14:58:58.000Z</published>
    <updated>2021-06-20T17:15:14.091Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#008000>什么是JVM？</font></p><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下JVM内存结构：</strong></p><hr><a id="more"></a><h4 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:67%;" /><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储<strong>类信息、常量、静态变</strong>量等数据，是<strong>线程共享</strong>的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>线程与进程：</strong></p><ul><li>同步于线程：程序计数器、虚拟机栈、本地方法栈</li><li>同步于进程：方法区、堆</li></ul><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<strong>唯一一个不会出现Stack Overflow Error 的地方。</strong></p><h4 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>1、对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>2、Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。</p><p><strong>控制参数</strong></p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><h4 id="内存结构相关包含"><a href="#内存结构相关包含" class="headerlink" title="内存结构相关包含"></a>内存结构相关包含</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_01-13-25.png" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#008000&gt;什么是JVM？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM内存结构：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- Java的类加载机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-06-14T17:08:29.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h4><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下Java的类加载机制：</strong></p><hr><a id="more"></a><h4 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>加载的过程包括了<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。</p><p><strong>加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段获取类的二进制字节流的动作是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>验证：确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>准备：为类的 <code>静态变量分</code>配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量是指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p><strong>结束生命周期</strong></p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 <code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>定义</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是JVM？&quot;&gt;&lt;a href=&quot;#什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM？&quot;&gt;&lt;/a&gt;什么是JVM？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下Java的类加载机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--HashMap红黑树</title>
    <link href="https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-07-16T20:17:12.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 HashMap为什么用红黑树：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上文说到，HashMap的扩容原理。</p><p>JDK1.7 使用的是 <strong>数组 + 单链表</strong> 的数据结构。</p><p>JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。</p><p>当阈值是默认阈值 <strong>0.75</strong>，链表的深度大于等于 <strong>8</strong>，数组容量大于等于 <strong>64</strong> 时，扩容的时候会把链表转成红黑树，时间复杂度从 <strong>O(n)</strong> 变成 <strong>O(logN)</strong>；当红黑树的节点深度小于等于 <strong>6</strong> 时，红黑树会转为<strong>链表结构</strong>。</p><p><strong><font color=#008000>在Java8中为什么要使用红黑树来实现的HashMap？</font></strong></p><p>答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）</p><a id="more"></a><h4 id="什么是红黑树呢？"><a href="#什么是红黑树呢？" class="headerlink" title="什么是红黑树呢？"></a>什么是红黑树呢？</h4><p>别急，先来回顾一下什么是二叉树！</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>简单地理解，满足以下两个条件的树就是二叉树：</p><ol><li>本身是有序树；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><blockquote><p>二叉树还可以继续分类，衍生出<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p></blockquote><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为<strong>满二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-34-34.898Z.png" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为<strong>完全二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-35-38.517Z.png" alt=""></p><center>完全二叉树</center><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-36-27.077Z.png" alt=""></p><center>非完全二叉树</center><hr><p>好了说完二叉树相关的知识后，还没有引入红黑树，因为在不断优化的过程中还是需要慢慢来，回顾一下平衡二叉树（AVL Tree）。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T12-57-32.630Z.png" style="zoom:67%;" /><p>对二叉树的节点进行查找发现深度为 1 的节点的查找次数为 1，深度为2的查找次数为 2，深度为n的节点的查找次数为n，因此其平均查找次数为  (1+2+2+3+3+3) / 6 = 2.3 次</p><p>当然上面是理想的情况，因为二叉查找树可以任意地构造，同样是 2,3,5,6,7,8 这六个数字，也可以按照下图的方式来构造。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-03-36.302Z.png" style="zoom:67%;" /><p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称 AVL 树。</p><h4 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h4><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p><p>AVL树，它的任何节点的两个子树的高度差&lt;=1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-13-21.964Z.png" style="zoom: 67%;" /><center>AVL树</center><p>不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-15-54.465Z.png" style="zoom:67%;" /><center>非AVL树</center><p>至此，引出红黑树(弱平衡二叉树)</p><h4 id="红黑树-弱平衡二叉树"><a href="#红黑树-弱平衡二叉树" class="headerlink" title="红黑树(弱平衡二叉树)"></a>红黑树(弱平衡二叉树)</h4><p>红黑树也属于平衡二叉树，但在每个节点增加一个存储位表示节点的颜色，非红即黑。</p><p>红黑树的英文是“Red-Black Tree”，简称R-B Tree。它是一种不严格的平衡二叉查找树，我前面说了，它的定义是不严格符合平衡二叉查找树的定义的。</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：<strong>如果一个结点存在黑子结点，那么该结点肯定有两个子结点</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-37-06.560Z.png" style="zoom:80%;" /><hr><h4 id="B树（Balance-Tree）"><a href="#B树（Balance-Tree）" class="headerlink" title="B树（Balance-Tree）"></a>B树（Balance-Tree）</h4><p><strong>B树是一颗多路平衡查找树</strong></p><p>它类似普通的平衡二叉树，不同的一点是B 树允许每个节点有更多的子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T14-44-46.777Z.png" alt=""></p><p>B 树有如下特点:</p><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况 O(1) 就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><p><strong>B 树是专门为外部存储器设计的</strong>。如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p><p><strong>B 树允许每个节点有更多的子节点即可（多叉树）</strong>。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p><h4 id="B-树（-Balance-Tree）"><a href="#B-树（-Balance-Tree）" class="headerlink" title="B+树（ Balance+Tree）"></a>B+树（ Balance+Tree）</h4><p><strong>B+Tree是在B Tree基础上的一种优化</strong>，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>B+Tree相对于B Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li><strong>数据记录都存放在叶子节点中</strong>；（查询时间复杂度固定为 log n）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-41-28.142Z.png" alt=""></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种<strong>链式环结构</strong>。</p><p>咋一看 B+ 树好像查询要比 B 树慢一些（同样的数据，查询【IO】次数变多了），但是是事实如此吗？</p><p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p><p>B+ 树可以很好的利用局部性原理，若我们访问节点 key为 80，则 key 为 79、83、87的节点将来也可能被访问，<strong>磁盘预读原理</strong>就会提前把这些数据都读进内存，使得范围查询和排序都很快，从而减少了磁盘 IO 的次数。</p><p>由于B树的节点都存了 key 和 data ，而 B+ 树只有叶子节点存 data，非叶子节点都只是索引值，没有实际的数据，这就时 B+ 树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！</p><p>B+ 树优势：</p><ol><li>B+ 树叶节点两两相连可大大增加区间访问性；</li><li>B+ 树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确；</li></ol><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p><strong><font color=#008000>MySQL 为什么使用 B Tree（B+Tree）存储？</font></strong></p><p>这就是下篇博客要着重介绍的东西咯~</p><p>我好像发现通过一个 hashmap 能够牵扯出一连串的知识啊！</p><p>这可能就是它的知识体系吧，正如我们在面试的过程中，面试官通过一个”点“，问着问着就问出来一个“面”。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 HashMap为什么用红黑树：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;上文说到，HashMap的扩容原理。&lt;/p&gt;
&lt;p&gt;JDK1.7 使用的是 &lt;strong&gt;数组 + 单链表&lt;/strong&gt; 的数据结构。&lt;/p&gt;
&lt;p&gt;JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。&lt;/p&gt;
&lt;p&gt;当阈值是默认阈值 &lt;strong&gt;0.75&lt;/strong&gt;，链表的深度大于等于 &lt;strong&gt;8&lt;/strong&gt;，数组容量大于等于 &lt;strong&gt;64&lt;/strong&gt; 时，扩容的时候会把链表转成红黑树，时间复杂度从 &lt;strong&gt;O(n)&lt;/strong&gt; 变成 &lt;strong&gt;O(logN)&lt;/strong&gt;；当红黑树的节点深度小于等于 &lt;strong&gt;6&lt;/strong&gt; 时，红黑树会转为&lt;strong&gt;链表结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=#008000&gt;在Java8中为什么要使用红黑树来实现的HashMap？&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="HashMap" scheme="https://codeyg.top/tags/HashMap/"/>
    
  </entry>
  
</feed>
