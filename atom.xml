<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇航员不会飞</title>
  
  <subtitle>里面的人想出去，外面的人想进来</subtitle>
  <link href="https://codeyg.top/atom.xml" rel="self"/>
  
  <link href="https://codeyg.top/"/>
  <updated>2021-07-21T18:38:59.732Z</updated>
  <id>https://codeyg.top/</id>
  
  <author>
    <name>白日梦想家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一面--Redis和MySQL数据一致性问题</title>
    <link href="https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>https://codeyg.top/2021/07/22/%E9%9D%A2%E8%AF%95--Redis%E5%92%8CMySQL%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-22T00:58:58.000Z</published>
    <updated>2021-07-21T18:38:59.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis 和 MySQL 数据一致性问题</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-53-11.png" alt=""></p><p><strong>写在前面</strong></p><p>对于Web来说，用户量和访问量增一定程度上推动项目技术和架构的更迭和进步。</p><p>当页面并发量和访问量并不多，MySQL<code>足以支撑</code>自己逻辑业务的发展。其实可以不加缓存，最多对静态页面进行缓存即可。</p><p><font color=#008000>什么时候需要缓存？</font></p><p>页面的并发量显著增多，数据库有些压力，并且有些数据更新频率较低<code>反复被查询</code>或者查询速度<code>较慢</code>。</p><p>对高命中的对象存到 Key-Value 形式的 Redis 中，那么，如果数据被命中，那么可以不经过效率很低的 DB。从高效的 Redis 中查找到数据。</p><p>虽然还能通过静态页面缓存页面、cdn加速、甚至负载均衡这些方法提高系统并发量，但是本片博客只是针对 Redis 缓存做讨论</p><a id="more"></a><h3 id="Redis-缓存的应用"><a href="#Redis-缓存的应用" class="headerlink" title="Redis 缓存的应用"></a>Redis 缓存的应用</h3><h4 id="不使用缓存的时候"><a href="#不使用缓存的时候" class="headerlink" title="不使用缓存的时候"></a>不使用缓存的时候</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-08-41.png" style="zoom:80%;" /><hr><h4 id="缓存适用的高并发场景"><a href="#缓存适用的高并发场景" class="headerlink" title="缓存适用的高并发场景"></a>缓存适用的高并发场景</h4><p>缓存适用于高并发的场景，提升服务容量。</p><p>主要是将从经常被访问的数据或者查询成本较高从慢的介质中存到比较快的介质中，比如从硬盘—&gt;内存。</p><p>大多数关系数据库是基于硬盘读写的，其效率和资源有限，而 redis 是基于内存的，其读写速度差别差别很大。当并发过高关系数据库性能达到瓶颈时候，就可以策略性将常访问数据放到 redis 提高系统吞吐和并发量。</p><h5 id="常用网站为什么会响应慢？"><a href="#常用网站为什么会响应慢？" class="headerlink" title="常用网站为什么会响应慢？"></a>常用网站为什么会响应慢？</h5><p>对于常用网站和场景，关系数据库主要可能慢在两个地方：</p><ul><li>读写IO性能较差</li><li>一个数据可能通过较大量计算得到</li></ul><blockquote><p>所以使用缓存能够减少磁盘IO次数和关系数据库的计算次数</p></blockquote><p><strong>体现：</strong></p><ul><li>基于内存，读写较快</li><li>使用哈希算法直接定位结果不需要计算</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-24-18.png" style="zoom:80%;" /><hr><h3 id="Redis-缓存需要注意的问题"><a href="#Redis-缓存需要注意的问题" class="headerlink" title="Redis 缓存需要注意的问题"></a>Redis 缓存需要注意的问题</h3><p>缓存使用不当会带来很多问题，所以需要对一些细节进行认真考量和设计。</p><p><font color=#FF8C00>最难的数据一致性！</font></p><h4 id="是否用缓存"><a href="#是否用缓存" class="headerlink" title="是否用缓存"></a>是否用缓存</h4><p>项目不能为了用缓存而用缓存，缓存并一定适合所有场景！</p><p>如果对<strong>数据一致性要求极高</strong>，又或者<strong>数据频繁更改而查询并不多</strong>，又或者根本没并发量的、查询简单的不一定需要缓存，还可能浪费资源使得项目变得臃肿难维护。</p><h4 id="过期策略选择"><a href="#过期策略选择" class="headerlink" title="过期策略选择"></a>过期策略选择</h4><p>缓存装的是相对热点和常用的数据，redis 资源也是有限，需要选择一个合理的策略让缓存过期删除，根据时间来的 FIFO 是最好实现的。且 redis 在全局 key 支持过期策略。</p><p>并且过期时间也要根据系统情况合理设置，如果硬件好点当前可以稍微久一点，但是过期时间过久或者过短可能都不太好，过短可能缓存命中率不高，而过久很可能造成很多冷门数据存储在Redis中不释放。</p><h3 id="Redis-缓存数据一致性问题"><a href="#Redis-缓存数据一致性问题" class="headerlink" title="Redis 缓存数据一致性问题"></a>Redis 缓存数据一致性问题</h3><h4 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h4><p><code>read</code>：从 redis 中读取，如果 redis 中没有，那么就从 MySQL 中获取更新 redis 缓存。 </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-37-06.png" alt=""></p><hr><h4 id="写数据-【先更新数据库，再更新缓存-普通低并发-】"><a href="#写数据-【先更新数据库，再更新缓存-普通低并发-】" class="headerlink" title="写数据 【先更新数据库，再更新缓存(普通低并发)】"></a>写数据 【先更新数据库，再更新缓存(普通低并发)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_01-49-00.png" alt=""></p><p>先更新数据库信息，再更新Redis缓存。这是常规做法，缓存基于数据库，取自数据库。</p><p>但是其中可能遇到一些问题，例如上述如果更新缓存失败(宕机等其他状况)，将会使得数据库和 redis 数据不一致。<font color=#FF0000>造成 DB 新数据，缓存旧数据</font></p><hr><h4 id="写数据-【先删除缓存，再写入数据库-低并发优化-】"><a href="#写数据-【先删除缓存，再写入数据库-低并发优化-】" class="headerlink" title="写数据 【先删除缓存，再写入数据库(低并发优化)】"></a>写数据 【先删除缓存，再写入数据库(低并发优化)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-04-31.png" alt=""></p><p>这种情况能够有效避免【先更新数据库，再更新缓存】中防止写入 redis 失败的问题。将缓存删除进行更新。理想是让下次访问 redis 为空去 mysql 取得最新值到缓存中。但是这种情况仅限于低并发的场景中而不适用高并发场景!</p><p><strong>存在的问题</strong></p><p>我们在【先更新数据库，再更新缓存】讨论过如果更新库成功，缓存更新失败会导致脏数据。我们理想是删除缓存让下一个线程访问适合更新缓存。问题是：如果这下一个线程来的太早呢？</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-11-16.png" alt=""></p><p>因为在多线的情况下，无法保证那条线程优先执行。</p><p>将会出现 redis 缓存数据和 mysql 不一致</p><p><font color=#FF0000>高并发下依然会造成缓存是旧数据，DB 是新数据</font></p><hr><h4 id="写数据【延时双删策略】"><a href="#写数据【延时双删策略】" class="headerlink" title="写数据【延时双删策略】"></a>写数据【延时双删策略】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-23-14.png" alt=""></p><p>能过缓解在【先删除缓存，再写入数据库】中在更新MySQL过程中有读的线程进入造成Redis缓存与MySQL数据不一致。</p><p>方法就是 <font color=#FF0000>删除缓存</font>-&gt;<font color=#008000>更新缓存</font>-&gt;<font color=#FF0000>延时【几百ms，可异步】再次删除缓存</font></p><p><strong>存在的问题</strong></p><p>第二次删除错误、多写多读高并发情况下对MySQL访问的压力等等，当然你可以选择用MQ等消息队列异步解决。</p><hr><h4 id="写数据【直接操作缓存，定期写入sql-适合高并发-】"><a href="#写数据【直接操作缓存，定期写入sql-适合高并发-】" class="headerlink" title="写数据【直接操作缓存，定期写入sql(适合高并发)】"></a>写数据【直接操作缓存，定期写入sql(适合高并发)】</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_02-34-36.png" alt=""></p><p>直接操作缓存，将缓存定期写入sql。</p><p>因为 redis 这种非关系数据库又基于内存操作 KV 相比传统关系型要快很多！</p><p><strong>异步更新缓存(基于订阅 binlog 的同步机制)</strong></p><p><strong>技术整体思路：</strong></p><p>MySQL binlog 增量订阅消费 + 消息队列 + 增量数据更新到 redis</p><ul><li><strong>读Redis</strong>：热数据基本都在 redis</li><li><strong>写MySQL</strong>：增删改都是操作 mysql</li><li><strong>更新Redis数据</strong>：mysql 的数据操作 binlog，来更新到 redis</li></ul><p><strong>数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到 redis)</li><li>一个是增量（实时更新）</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis 和 MySQL 数据一致性问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-53-11.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于Web来说，用户量和访问量增一定程度上推动项目技术和架构的更迭和进步。&lt;/p&gt;
&lt;p&gt;当页面并发量和访问量并不多，MySQL&lt;code&gt;足以支撑&lt;/code&gt;自己逻辑业务的发展。其实可以不加缓存，最多对静态页面进行缓存即可。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么时候需要缓存？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;页面的并发量显著增多，数据库有些压力，并且有些数据更新频率较低&lt;code&gt;反复被查询&lt;/code&gt;或者查询速度&lt;code&gt;较慢&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对高命中的对象存到 Key-Value 形式的 Redis 中，那么，如果数据被命中，那么可以不经过效率很低的 DB。从高效的 Redis 中查找到数据。&lt;/p&gt;
&lt;p&gt;虽然还能通过静态页面缓存页面、cdn加速、甚至负载均衡这些方法提高系统并发量，但是本片博客只是针对 Redis 缓存做讨论&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Spring 循环依赖以及三级缓存</title>
    <link href="https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Spring%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%8A%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2021-07-21T01:00:00.000Z</published>
    <updated>2021-07-21T16:16:12.271Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Spring 循环依赖以及三级缓存</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-45-33.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>什么是循环依赖？</font></p><p>简单的说就是 A 依赖 B，B 依赖 A 这样就构成了循环依赖。</p><p><font color=#008000>具体说一说 spring 是如何解决循环依赖的吧</font></p><p>让我好好想一想……</p><a id="more"></a><h3 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h3><p>所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。</p><p>举个图解荔枝：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_22-16-10.png" style="zoom:90%;" /><p>举个代码荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanB</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> BeanA beanA;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanA</span><span class="params">(BeanA beanA)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.beanA = beanA;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeanB beanB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanB</span><span class="params">(BeanB beanB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanB = beanB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanA"</span> <span class="attr">class</span>=<span class="string">"com.ase.BeanA"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanB"</span> <span class="attr">ref</span>=<span class="string">"beanB"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanB"</span> <span class="attr">class</span>=<span class="string">"com.ase.BeanB"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanA"</span> <span class="attr">ref</span>=<span class="string">"beanA"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照上面的例子，Spring 启动后，读取如上的配置文件，会按顺序先实例化 A，但是创建的时候又发现它依赖了 B，接着就去实例化 B ，同样又发现它依赖了 A ，从而导致了无限循环，淦！</p><p><strong>尝试思考</strong></p><p>Spring 实例化对象分两步：</p><p>第一步，会先创建一个原始对象，只是没有设置属性，可以理解为”半成品”—— 官方叫 A 对象的早期引用（EarlyBeanReference）；</p><p>第二步，当实例化 B 的时候发现依赖了 A， B 就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了，这其实就是 Spring 解决循环依赖的思想；</p><hr><h3 id="循环依赖发生的时机"><a href="#循环依赖发生的时机" class="headerlink" title="循环依赖发生的时机"></a>循环依赖发生的时机</h3><h4 id="Bean-实例化"><a href="#Bean-实例化" class="headerlink" title="Bean 实例化"></a>Bean 实例化</h4><p>主要分为三步，如图：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_22-33-22.png" style="zoom:80%;" /><p>问题出现在：第一步和第二步的过程中，也就是填充属性 / 方法的过程中</p><h4 id="Spring-如何解决的"><a href="#Spring-如何解决的" class="headerlink" title="Spring 如何解决的"></a>Spring 如何解决的</h4><ul><li>Spring 为了解决单例的循环依赖问题，使用了 <strong>三级缓存</strong> ，递归调用时发现 Bean 还在创建中即为循环依赖</li><li>单例模式的 Bean 保存在如下的数据结构中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 二级缓存：存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 三级级缓存：存放 bean 工厂对象，用于解决循环依赖 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">bean 的获取过程：先从一级获取，失败再从二级、三级里面获取</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">创建中状态：是指对象已经 new 出来了但是所有的属性均为 null 等待被 init</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>一级缓存：singletonObjects，存放完全实例化属性赋值完成的 Bean，直接可以使用。</li><li>二级缓存：earlySingletonObjects，存放早期 Bean 的引用，尚未属性装配的 Bean</li><li>三级缓存：singletonFactories，三级缓存，存放实例化完成的 Bean工厂。</li></ul><h4 id="循环依赖的解决流程图"><a href="#循环依赖的解决流程图" class="headerlink" title="循环依赖的解决流程图"></a>循环依赖的解决流程图</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-22_00-13-55.png" alt=""></p><hr><h4 id="A、B-相互依赖"><a href="#A、B-相互依赖" class="headerlink" title="A、B 相互依赖"></a>A、B 相互依赖</h4><p>检测循环依赖的过程如下：</p><ul><li><p>A 创建过程中需要 B，于是 <strong>A 将自己放到三级缓里面</strong> ，去实例化 B</p></li><li><p>B 实例化的时候发现需要 A，于是 B 先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了</p><ul><li><strong>然后把三级缓存里面的这个 A 放到二级缓存里面，并删除三级缓存里面的 A</strong></li><li>B 顺利初始化完毕，<strong>将自己放到一级缓存里面</strong>（此时B里面的A依然是创建中状态）</li></ul></li><li><p>然后回来接着创建 A，此时 B 已经创建结束，直接从一级缓存里面拿到 B ，然后完成创建，<strong>并将自己放到一级缓存里面</strong></p></li><li><p>如此一来便解决了循环依赖的问题</p></li></ul><p><strong>总结</strong></p><p>先让最底层对象完成初始化，通过三级缓存与二级缓存提前曝光创建中的 Bean，让其他 Bean 率先完成初始化。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><font color=#FF8C00>Spring 还是有一些无法解决的循环依赖！</font></p><p>使用构造器注入其他 Bean 的实例，这个就没办法了，要手动改代码。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Spring 循环依赖以及三级缓存&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-45-33.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是循环依赖？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;简单的说就是 A 依赖 B，B 依赖 A 这样就构成了循环依赖。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;具体说一说 spring 是如何解决循环依赖的吧&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;让我好好想一想……&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="Spring" scheme="https://codeyg.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Redis 五种数据结构详解</title>
    <link href="https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Redis%205%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>https://codeyg.top/2021/07/21/%E9%9D%A2%E8%AF%95--Redis%205%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-07-21T00:08:08.000Z</published>
    <updated>2021-07-21T02:13:34.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis 的五种数据结构</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-42-43.png" alt=""></p><p><strong>写在前面</strong></p><p>Redis 是基于 C 语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件。</p><p>Redis 的五种数据结构详解，包括这五种的数据结构的底层原理实现。</p><a id="more"></a><h4 id="Redis的五种数据结构"><a href="#Redis的五种数据结构" class="headerlink" title="Redis的五种数据结构"></a>Redis的五种数据结构</h4><ol><li><code>String</code>：字符串类型</li><li><code>List</code>：列表类型</li><li><code>Set</code>：无序集合类型</li><li><code>ZSet</code>：有序集合类型</li><li><code>Hash</code>：哈希表类型</li></ol><h4 id="Redis核心对象"><a href="#Redis核心对象" class="headerlink" title="Redis核心对象"></a>Redis核心对象</h4><p>在Redis中有一个<strong>「核心的对象」</strong>叫做 <code>redisObject</code> ，是用来表示所有的 key 和 value 的，用 redisObject 结构体来表示<code>String、Hash、List、Set、ZSet</code>五种数据类型。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_09-28-52.png" alt=""></p><p>在redisObject中<strong>「type表示属于哪种数据类型，encoding表示该数据的存储方式」</strong>，也就是底层的实现的该数据类型的数据结构。</p><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>redis 中的字符串和 c 语言中的字符串类型却是有明显的区别。</p><p>string 类型的数据结构存储方式有三种<code>int、raw、embstr</code>。</p><p><strong>未完待续……</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis 的五种数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_08-42-43.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 是基于 C 语言编写的开源非关系型内存数据库，可以用作数据库、缓存、消息中间件。&lt;/p&gt;
&lt;p&gt;Redis 的五种数据结构详解，包括这五种的数据结构的底层原理实现。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--MySQL 存储引擎</title>
    <link href="https://codeyg.top/2021/07/19/%E9%9D%A2%E8%AF%95--MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://codeyg.top/2021/07/19/%E9%9D%A2%E8%AF%95--MySQL%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</id>
    <published>2021-07-19T13:58:58.000Z</published>
    <updated>2021-07-21T00:46:16.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 MySQL 存储引擎</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_00-12-04.png" alt=""></p><p><strong>写在前面</strong></p><p>本文依照数据库 5.7 来描述滴~</p><p><font color=#008000>明确一点：</font></p><p>数据库实例（instance）才是真正用于操作数据库文件的。</p><p>MySQL 是一个单进程、多线程架构的数据库；</p><p>在集群的情况下，一个数据库对应对个数据库实例。</p><a id="more"></a><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>数据库：由一个个文件组成（二进制）</p><p>数据库实例：执行类似于（Insert、Update、Delete）来更改数据库的内容</p><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul><li>Atomicity（原子性）</li><li>Consistency（一致性）</li><li>Isolation（隔离性）</li><li>Durability（持久性）</li></ul><br/><h3 id="MySQL-存储引擎对比"><a href="#MySQL-存储引擎对比" class="headerlink" title="MySQL 存储引擎对比"></a>MySQL 存储引擎对比</h3><table><thead><tr><th align="center">特点</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">批量插入的速度</td><td align="center">高</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="center"><font color=#008000>事务安全</font></td><td align="center">-</td><td align="center"><font color=#008000>支持</font></td><td align="center">-</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持</td><td align="center">不支持</td></tr><tr><td align="center"><font color=#008000>锁机制</font></td><td align="center"><font color=#008000>表锁</font></td><td align="center"><font color=#008000>行锁</font></td><td align="center"><font color=#008000>表锁</font></td></tr><tr><td align="center">存储限制</td><td align="center">256 TB</td><td align="center">64 T</td><td align="center">RAM</td></tr><tr><td align="center">B 树索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">哈希索引</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">集群索引</td><td align="center">-</td><td align="center">支持</td><td align="center">-</td></tr><tr><td align="center">数据缓存</td><td align="center">-</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">索引缓存</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">数据可压缩</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">空间使用</td><td align="center">低</td><td align="center">高</td><td align="center">N/A</td></tr><tr><td align="center"><font color=#008000>内存使用</font></td><td align="center"><font color=#008000>低</font></td><td align="center"><font color=#008000>高</font></td><td align="center"><font color=#008000>中</font></td></tr><tr><td align="center"><font color=#008000>支持外键</font></td><td align="center"><font color=#008000>不支持</font></td><td align="center"><font color=#008000>支持</font></td><td align="center"><font color=#008000>不支持</font></td></tr></tbody></table><hr><h3 id="MySQL-存储引擎"><a href="#MySQL-存储引擎" class="headerlink" title="MySQL 存储引擎"></a>MySQL 存储引擎</h3><h4 id="MySQL-插件式存储引擎概念"><a href="#MySQL-插件式存储引擎概念" class="headerlink" title="MySQL 插件式存储引擎概念"></a>MySQL 插件式存储引擎概念</h4><p><strong>MySQL 存储引擎（核心）</strong></p><p><font color=#FF8C00>存储引擎是基于表的，而不是数据库</font></p><p><strong>MySQL 默认存储引擎</strong></p><p>使用下面的语句可以修改数据库临时的默认存储引擎</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET default_storage_engine &#x3D; &lt;存储引擎名&gt;</span><br></pre></td></tr></table></figure><p>但是当再次重启客户端时，默认存储引擎仍然是 InnoDB</p><h3 id="表锁概念"><a href="#表锁概念" class="headerlink" title="表锁概念"></a>表锁概念</h3><h4 id="行锁和表锁"><a href="#行锁和表锁" class="headerlink" title="行锁和表锁"></a>行锁和表锁</h4><p>在mysql 的 InnoDB引擎支持行锁，与Oracle不同，mysql的行锁是通过索引加载的，即是行锁是加在索引响应的行上的，要是对应的SQL语句没有走索引，则会全表扫描，</p><p>行锁则无法实现，取而代之的是表锁。</p><p><strong>表锁</strong>：不会出现死锁，发生锁冲突几率高，并发低。</p><p><strong>行锁：</strong>会出现死锁，发生锁冲突几率低，并发高。</p><p><strong>锁冲突：</strong>例如说事务A将某几行上锁后，事务B又对其上锁，锁不能共存否则会出现锁冲突。<strong>（但是共享锁可以共存，共享锁和排它锁不能共存，排它锁和排他锁也不可以）</strong></p><p><strong>死锁：</strong>例如说两个事务，事务A锁住了1-5行，同时事务B锁住了6-10行，此时事务A请求锁住6-10行，就会阻塞直到事务B施放6-10行的锁，而随后事务B又请求锁住1-5行，事务B也阻塞直到事务A释放1-5行的锁。死锁发生时，会产生 Deadlock 错误。</p><p><font color=#FF8C00>锁是对表操作的，所以自然锁住全表的表锁就不会出现死锁</font></p><h4 id="行锁的类型"><a href="#行锁的类型" class="headerlink" title="行锁的类型"></a>行锁的类型</h4><p>行锁分 共享锁 和 排它锁</p><p>共享锁：</p><p>又称读锁，当一个事务对某几行上读锁时，允许其他事务对这几行进行读操作，但不允许其进行写操作，也不允许其他事务给这几行上排它锁，但允许上读锁。</p><p>排它锁：</p><p>又称写锁，当一个事务对某几个上写锁时，不允许其他事务写，但允许读。更不允许其他事务给这几行上任何锁。包括写锁。</p><p>举个荔枝：</p><p>上共享锁的写法：<font color=#008000>lock in share mode</font> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  math from results where math &gt; 60 lock in share mode；</span><br></pre></td></tr></table></figure><p>上排它锁的写法：<font color=#008000>for update</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select math from results where math &gt; 60 for update</span><br></pre></td></tr></table></figure><h4 id="行锁的实现"><a href="#行锁的实现" class="headerlink" title="行锁的实现"></a>行锁的实现</h4><ol><li><p>行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</p></li><li><p>两个事务不能锁同一个索引，例如：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 事务A先执行：</span><br><span class="line">select math from results where math &gt; 60 for update;</span><br><span class="line"> </span><br><span class="line"># 事务B再执行：</span><br><span class="line">select math from results where math &lt; 60 for update；</span><br><span class="line"># 这样的话，事务 B 是会阻塞的。如果事务 B 把 math 索引换成其他索引就不会阻塞，</span><br><span class="line"># 但注意，换成其他索引锁住的行不能和 math 索引锁住的行有重复。</span><br></pre></td></tr></table></figure><br/><h3 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a>InnoDB 存储引擎</h3><p><font color=#FF8C00>5.8版本后的默认存储引擎</font></p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>支持事务的安装</li><li>灾难恢复型好</li><li>使用行级锁</li><li>实现了缓冲处理</li><li>支持外键</li><li>适合大型的数据库网站</li></ol><br/><h3 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a>MyISAM 存储引擎</h3><p><font color=#FF8C00>5.8版本的默认存储引擎</font></p><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li>支持全文索引</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li><p>不支持事务</p></li><li><p>不支持行锁</p></li></ol><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>MYD 和 MYI</p><p>其缓冲池中只存索引文件，而不是缓冲数据文件；</p><ul><li>MYD：用来存放数据文件（Date）</li><li>MYI：用来存放索引文件（Index）</li></ul><p>5.0 版本前：默认支持表的大小为 4 GB；</p><p>5.0 版本时：默认支持表的大小为 256 TB；</p><br/><h3 id="Memory-存储引擎"><a href="#Memory-存储引擎" class="headerlink" title="Memory 存储引擎"></a>Memory 存储引擎</h3><p>将表中的数据存放在内存当中，一旦数据库重新启动或者崩溃，则表中的数据都将消失。</p><p>适合用于存储临时数据的临时表。</p><p>默认使用的是哈希索引而不是 B+ 树索引；</p><p>只支持表锁，不支持 text 和 blob 列类型。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 MySQL 存储引擎&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-21_00-12-04.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文依照数据库 5.7 来描述滴~&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;明确一点：&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;数据库实例（instance）才是真正用于操作数据库文件的。&lt;/p&gt;
&lt;p&gt;MySQL 是一个单进程、多线程架构的数据库；&lt;/p&gt;
&lt;p&gt;在集群的情况下，一个数据库对应对个数据库实例。&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="MySQL 存储引擎" scheme="https://codeyg.top/tags/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>jdk8新特性--stream</title>
    <link href="https://codeyg.top/2021/07/17/jdk8%E6%96%B0%E7%89%B9%E6%80%A7--stream/"/>
    <id>https://codeyg.top/2021/07/17/jdk8%E6%96%B0%E7%89%B9%E6%80%A7--stream/</id>
    <published>2021-07-17T14:58:58.000Z</published>
    <updated>2021-07-18T21:29:24.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p>jdk1.8新特性知识点：</p><p><strong>Lambda 表达式、函数式接口、方法引用和构造器调用、Stream API、接口中的默认方法和静态方法、新时间日期 API</strong></p><p><strong>本篇着重介绍一下 stream 流</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-29-30.png" alt=""></p><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p><font color=#008000>什么是 stream 流？</font></p><p>Java8 中，Collection 新增了两个流方法，分别是 Stream() 和 parallelStream()</p><p>Java8 中添加了一个新的接口类 Stream，相当于高级版的 Iterator，它可以通过 Lambda 表达式对集合进行大批量数据操作，或 者各种非常便利、高效的聚合数据操作。</p><p>Stream 将要处理的元素集合看作一种流，在流的过程中，借助 Stream API 对流中的元素进行操作，比如：筛选、排序、聚合等。</p><p><font color=#008000>jdk8 为什么要引入 stream 流？</font></p><p>在 Java8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。</p><p><font color=#6AAFE6>流不存储数据</font></p><a id="more"></a><h3 id="stream-概述"><a href="#stream-概述" class="headerlink" title="stream 概述"></a>stream 概述</h3><p>Stream可以由数组或集合创建，对流的操作分为两种：</p><ol><li>中间操作，每次返回一个新的流，可以有多个。</li><li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li></ol><p>另外，Stream有几个特性：</p><ol><li>stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream 不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ol><p>stream 是元素的集合，这点让 stream 看起来用些类似 Iterator</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_00-46-42.png" alt=""></p><br/><h3 id="stream-的创建"><a href="#stream-的创建" class="headerlink" title="stream 的创建"></a>stream 的创建</h3><h4 id="通过集合数组创建"><a href="#通过集合数组创建" class="headerlink" title="通过集合数组创建"></a>通过集合数组创建</h4><ol><li><p>通过 java.util.Collection.stream() 方法用集合创建流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        <span class="comment">// 创建一个顺序流</span></span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">        <span class="comment">// 创建一个并行流</span></span><br><span class="line">        Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>使用 java.util.Arrays.stream(T[] array) 方法用数组创建流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        IntStream stream = Arrays.stream(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>使用 Stream 的静态方法：of()、iterate()、generate()</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamCreateTest3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamCreateTest3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line">        </span><br><span class="line">        Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">        stream3.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><br/><h4 id="stream-和-parallelStream"><a href="#stream-和-parallelStream" class="headerlink" title="stream 和 parallelStream"></a>stream 和 parallelStream</h4><p><font color=#008000>stream</font> 是顺序流，由主线程按顺序对流执行操作</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_23-56-01.png" style="zoom:70%;" /><p><font color=#008000>parallelStream</font> 并行流就是一个把内容分成多个数据块，并用不不同的线程分别处理每个数据块的流。最后合并每个数据块的计算结果</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_23-56-15.png" style="zoom:70%;" /><p>如果流中的数据量足够大，并行流可以加快处速度。</p><p>除了直接创建并行流，还可以通过<code>parallel()</code>把顺序流转换成并行流</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"parallelSum = "</span> + parallelSum(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parallelSum</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>).limit(n).parallel().reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="stream-的使用"><a href="#stream-的使用" class="headerlink" title="stream 的使用"></a>stream 的使用</h3><p>在使用 stream 之前，先看一下：<code>Optional</code></p><p><code>Optional</code>类是一个可以为<code>null</code>的容器对象。如果值存在则<code>isPresent()</code>方法会返回<code>true</code>，调用<code>get()</code>方法会返回该对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+        +--------+     +--------+     +-----+     +---------+</span><br><span class="line">| stream of elements + -----&gt; | filter + --&gt; | sorted + --&gt; | map + --&gt; | collect |</span><br><span class="line">+--------------------+        +--------+     +--------+     +-----+     +---------+</span><br></pre></td></tr></table></figure><p><strong>stream（图示）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-23-04.png" alt=""></p><hr><p><strong>stream–collect（图示）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-23-39.png" alt=""></p><hr><h4 id="遍历-匹配（foreach-find-match）"><a href="#遍历-匹配（foreach-find-match）" class="headerlink" title="遍历/匹配（foreach/find/match）"></a>遍历/匹配（foreach/find/match）</h4><p><code>Stream</code>也是支持类似集合的遍历和匹配元素的，只是<code>Stream</code>中的元素是以<code>Optional</code>类型存在的。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-39-44.png" style="zoom:80%;" /><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输出符合条件的元素</span></span><br><span class="line">        list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).forEach(System.out::print);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">// 匹配第一个</span></span><br><span class="line">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">        <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">        <span class="comment">// 是否包含符合特定条件的元素</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(x -&gt; x &lt; <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"匹配第一个值："</span> + findFirst.get());</span><br><span class="line">        System.out.println(<span class="string">"匹配任意一个值："</span> + findAny.get());</span><br><span class="line">        System.out.println(<span class="string">"是否存在大于6的值："</span> + anyMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="筛选（filter）"><a href="#筛选（filter）" class="headerlink" title="筛选（filter）"></a>筛选（filter）</h4><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-40-26.png" style="zoom:80%;" /><p>举个荔枝：</p><p>筛选出<code>Integer</code>集合中大于7的元素，并打印出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        stream.filter(x -&gt; x &gt; <span class="number">7</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a>聚合（max/min/count)</h4><p><code>max</code>、<code>min</code>、<code>count</code>这些字眼在 mysql 中我们常用它们进行数据统计。</p><p>java stream 中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_01-46-58.png" style="zoom:80%;" /><p>举个荔枝：</p><p>获取<code>String</code>集合中最长的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"adnm"</span>, <span class="string">"admmt"</span>, <span class="string">"pot"</span>, <span class="string">"xbangd"</span>, <span class="string">"weoujgsd"</span>);</span><br><span class="line"></span><br><span class="line">        Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">        System.out.println(<span class="string">"最长的字符串："</span> + max.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个荔枝：</p><p>获取Integer集合中的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自然排序</span></span><br><span class="line">        Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">        <span class="comment">// 自定义排序</span></span><br><span class="line">        Optional&lt;Integer&gt; max2 = list.stream().max((o1, o2) -&gt; o1.compareTo(o2));</span><br><span class="line">        System.out.println(<span class="string">"自然排序的最大值："</span> + max.get());</span><br><span class="line">        System.out.println(<span class="string">"自定义排序的最大值："</span> + max2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="映射（map-flatMap）"><a href="#映射（map-flatMap）" class="headerlink" title="映射（map / flatMap）"></a>映射（map / flatMap）</h4><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中</p><p>分为<code>map</code>和<code>flatMap</code>：</p><ul><li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-29-38.png" style="zoom:80%;" /><ul><li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-30-15.png" style="zoom:80%;" /><p>举个荔枝：</p><p>英文字符串数组的元素全部改为大写、整数数组每个元素+3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] strArr = &#123; <span class="string">"abcd"</span>, <span class="string">"bcdd"</span>, <span class="string">"defde"</span>, <span class="string">"fTr"</span> &#125;;</span><br><span class="line">        List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">        List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每个元素大写："</span> + strList);</span><br><span class="line">        System.out.println(<span class="string">"每个元素+3："</span> + intListNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再举个荔枝：</p><p>将两个字符数组合并成一个新的字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"m,k,l,a"</span>, <span class="string">"1,3,5,7"</span>);</span><br><span class="line">        List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">            <span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">            String[] split = s.split(<span class="string">","</span>);</span><br><span class="line">            Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">            <span class="keyword">return</span> s2;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"处理前的集合："</span> + list);</span><br><span class="line">        System.out.println(<span class="string">"处理后的集合："</span> + listNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="归约（reduce）"><a href="#归约（reduce）" class="headerlink" title="归约（reduce）"></a>归约（reduce）</h4><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_02-52-43.png" style="zoom:80%;" /><p>举个荔枝：</p><p>求<code>Integer</code>集合的元素之和、乘积和最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 求和方式1</span></span><br><span class="line">        Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">        <span class="comment">// 求和方式2</span></span><br><span class="line">        Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class="line">        <span class="comment">// 求和方式3</span></span><br><span class="line">        Integer sum3 = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求乘积</span></span><br><span class="line">        Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最大值方式1</span></span><br><span class="line">        Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">        <span class="comment">// 求最大值写法2</span></span><br><span class="line">        Integer max2 = list.stream().reduce(<span class="number">1</span>, Integer::max);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"list求和："</span> + sum.get() + <span class="string">","</span> + sum2.get() + <span class="string">","</span> + sum3);</span><br><span class="line">        System.out.println(<span class="string">"list求积："</span> + product.get());</span><br><span class="line">        System.out.println(<span class="string">"list求和："</span> + max.get() + <span class="string">","</span> + max2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="收集（collect）"><a href="#收集（collect）" class="headerlink" title="收集（collect）"></a>收集（collect）</h4><p><code>collect</code>，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合</p><blockquote><p><code>collect</code>主要依赖<code>java.util.stream.Collectors</code>类内置的静态方法</p></blockquote><h5 id="归集（toList-toSet-toMap）"><a href="#归集（toList-toSet-toMap）" class="headerlink" title="归集（toList/toSet/toMap）"></a>归集（toList/toSet/toMap）</h5><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里</p><p><code>toList</code>、<code>toSet</code>和<code>toMap</code>：</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">        List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">        Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Anni"</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="number">8000</span>)</span><br><span class="line">                .collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">        System.out.println(<span class="string">"toList:"</span> + listNew);</span><br><span class="line">        System.out.println(<span class="string">"toSet:"</span> + set);</span><br><span class="line">        System.out.println(<span class="string">"toMap:"</span> + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toList:[<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line">toSet:[<span class="number">4</span>, <span class="number">20</span>, <span class="number">6</span>]</span><br><span class="line">toMap:&#123;Tom=Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">23</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Anni=Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">24</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="统计（count-averaging）"><a href="#统计（count-averaging）" class="headerlink" title="统计（count/averaging）"></a>统计（count/averaging）</h5><p>Collectors提供了一系列用于数据统计的静态方法：</p><ul><li>计数：count</li><li>平均值：averagingInt、averagingLong、averagingDouble</li><li>最值：maxBy、minBy</li><li>求和：summingInt、summingLong、summingDouble</li><li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li></ul><p>举个荔枝：</p><p>统计员工人数、平均工资、工资总额、最高工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求总数</span></span><br><span class="line">        Long count = personList.stream().collect(Collectors.counting());</span><br><span class="line">        <span class="comment">// 求平均工资</span></span><br><span class="line">        Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line">        <span class="comment">// 求最高工资</span></span><br><span class="line">        Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">        <span class="comment">// 求工资之和</span></span><br><span class="line">        Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">        <span class="comment">// 一次性统计所有信息</span></span><br><span class="line">        DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"员工总数："</span> + count);</span><br><span class="line">        System.out.println(<span class="string">"员工平均工资："</span> + average);</span><br><span class="line">        System.out.println(<span class="string">"员工工资总和："</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">"员工工资所有统计："</span> + collect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">员工总数：<span class="number">3</span></span><br><span class="line">员工平均工资：<span class="number">7900.0</span></span><br><span class="line">员工工资总和：<span class="number">23700</span></span><br><span class="line">员工工资所有统计：DoubleSummaryStatistics&#123;count=<span class="number">3</span>, sum=<span class="number">23700.000000</span>, min=<span class="number">7000.000000</span>, average=<span class="number">7900.000000</span>, max=<span class="number">8900.000000</span>&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="分组（partitioningBy-groupingBy）"><a href="#分组（partitioningBy-groupingBy）" class="headerlink" title="分组（partitioningBy/groupingBy）"></a>分组（partitioningBy/groupingBy）</h5><ul><li>分区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li><li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_03-54-51.png" alt=""></p><p>举个荔枝：</p><p>将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Anni"</span>, <span class="number">8200</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Owen"</span>, <span class="number">9500</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Alisa"</span>, <span class="number">7900</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将员工按薪资是否高于8000分组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="number">8000</span>));</span><br><span class="line">        <span class="comment">// 将员工按性别分组</span></span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line">        <span class="comment">// 将员工先按性别分组，再按地区分组</span></span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class="line">        System.out.println(<span class="string">"员工按薪资是否大于8000分组情况："</span> + part);</span><br><span class="line">        System.out.println(<span class="string">"员工按性别分组情况："</span> + group);</span><br><span class="line">        System.out.println(<span class="string">"员工按性别、地区："</span> + group2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">员工按薪资是否大于<span class="number">8000</span>分组情况：&#123;<span class="keyword">false</span>=[Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], <span class="keyword">true</span>=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;]&#125;</span><br><span class="line">员工按性别分组情况：&#123;female=[Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], male=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;]&#125;</span><br><span class="line">员工按性别、地区：&#123;female=&#123;New York=[Person&#123;name=<span class="string">'Anni'</span>, salary=<span class="number">8200</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Alisa'</span>, salary=<span class="number">7900</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'New York'</span>&#125;], Washington=[Person&#123;name=<span class="string">'Lily'</span>, salary=<span class="number">7800</span>, age=<span class="number">0</span>, sex=<span class="string">'female'</span>, area=<span class="string">'Washington'</span>&#125;]&#125;, male=&#123;New York=[Person&#123;name=<span class="string">'Tom'</span>, salary=<span class="number">8900</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;, Person&#123;name=<span class="string">'Owen'</span>, salary=<span class="number">9500</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'New York'</span>&#125;], Washington=[Person&#123;name=<span class="string">'Jack'</span>, salary=<span class="number">7000</span>, age=<span class="number">0</span>, sex=<span class="string">'male'</span>, area=<span class="string">'Washington'</span>&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="接合（joining）"><a href="#接合（joining）" class="headerlink" title="接合（joining）"></a>接合（joining）</h5><p><code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        String names = personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">        System.out.println(<span class="string">"所有员工的姓名："</span> + names);</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">        String string = list.stream().collect(Collectors.joining(<span class="string">"-"</span>));</span><br><span class="line">        System.out.println(<span class="string">"拼接后的字符串："</span> + string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所有员工的姓名：Tom,Jack,Lily</span><br><span class="line">拼接后的字符串：A-B-C</span><br></pre></td></tr></table></figure><hr><h5 id="归约（reduce）-1"><a href="#归约（reduce）-1" class="headerlink" title="归约（reduce）"></a>归约（reduce）</h5><p><code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持</p><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">"female"</span>, <span class="string">"Washington"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每个员工减去起征点后的薪资之和</span></span><br><span class="line">        Integer sum = personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; (i + j - <span class="number">5000</span>)));</span><br><span class="line">        System.out.println(<span class="string">"员工扣税薪资总和："</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stream的reduce</span></span><br><span class="line">        Optional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">"员工薪资总和："</span> + sum2.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">员工扣税薪资总和：<span class="number">8700</span></span><br><span class="line">员工薪资总和：<span class="number">23700</span></span><br></pre></td></tr></table></figure><hr><h4 id="排序（sorted）"><a href="#排序（sorted）" class="headerlink" title="排序（sorted）"></a>排序（sorted）</h4><p>有两种排序：</p><ul><li>sorted()：自然排序，流中元素需实现 Comparable 接口</li><li>sorted (Comparator com)：Comparator 排序器自定义排序</li></ul><p>举个荔枝：</p><p>将员工按工资由高到低（工资一样则按年龄由大到小）排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Sherry"</span>, <span class="number">9000</span>, <span class="number">24</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Tom"</span>, <span class="number">8900</span>, <span class="number">22</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Jack"</span>, <span class="number">9000</span>, <span class="number">25</span>, <span class="string">"male"</span>, <span class="string">"Washington"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">8800</span>, <span class="number">26</span>, <span class="string">"male"</span>, <span class="string">"New York"</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">"Alisa"</span>, <span class="number">9000</span>, <span class="number">26</span>, <span class="string">"female"</span>, <span class="string">"New York"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按工资升序排序（自然排序）</span></span><br><span class="line">        List&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 按工资倒序排序</span></span><br><span class="line">        List&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">                .map(Person::getName).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 先按工资再按年龄升序排序</span></span><br><span class="line">        List&lt;String&gt; newList3 = personList.stream()</span><br><span class="line">                .sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 先按工资再按年龄自定义排序（降序）</span></span><br><span class="line">        List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p2.getSalary() - p1.getSalary();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"按工资升序排序："</span> + newList);</span><br><span class="line">        System.out.println(<span class="string">"按工资降序排序："</span> + newList2);</span><br><span class="line">        System.out.println(<span class="string">"先按工资再按年龄升序排序："</span> + newList3);</span><br><span class="line">        System.out.println(<span class="string">"先按工资再按年龄自定义降序排序："</span> + newList4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</span><br><span class="line">先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</span><br></pre></td></tr></table></figure><hr><h4 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h4><p>流也可以进行合并、去重、限制、跳过等操作</p><p><strong>去重</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-39-03.png" style="zoom:80%;" /><p><strong>限制</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-40-11.png" style="zoom:80%;" /><p><strong>跳过</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-19_04-39-31.png" style="zoom:80%;" /><p>举个荔枝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        streamOperation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">streamOperation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String[] arr1 = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span> &#125;;</span><br><span class="line">        String[] arr2 = &#123; <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span> &#125;;</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">        <span class="comment">// concat:合并两个流 distinct：去重</span></span><br><span class="line">        List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// limit：限制从流中获得前n个数据</span></span><br><span class="line">        List&lt;Integer&gt; collect = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// skip：跳过前n个数据</span></span><br><span class="line">        List&lt;Integer&gt; collect2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">1</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"流合并："</span> + newList);</span><br><span class="line">        System.out.println(<span class="string">"limit："</span> + collect);</span><br><span class="line">        System.out.println(<span class="string">"skip："</span> + collect2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</span><br><span class="line">先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</span><br><span class="line">先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;jdk1.8新特性知识点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lambda 表达式、函数式接口、方法引用和构造器调用、Stream API、接口中的默认方法和静态方法、新时间日期 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 stream 流&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-29-30.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;&lt;font color=#008000&gt;什么是 stream 流？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Java8 中，Collection 新增了两个流方法，分别是 Stream() 和 parallelStream()&lt;/p&gt;
&lt;p&gt;Java8 中添加了一个新的接口类 Stream，相当于高级版的 Iterator，它可以通过 Lambda 表达式对集合进行大批量数据操作，或 者各种非常便利、高效的聚合数据操作。&lt;/p&gt;
&lt;p&gt;Stream 将要处理的元素集合看作一种流，在流的过程中，借助 Stream API 对流中的元素进行操作，比如：筛选、排序、聚合等。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;jdk8 为什么要引入 stream 流？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;在 Java8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。&lt;/p&gt;
&lt;p&gt;&lt;font color=#6AAFE6&gt;流不存储数据&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jdk8新特性" scheme="https://codeyg.top/categories/jdk8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="stream" scheme="https://codeyg.top/tags/stream/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Maven依赖冲突</title>
    <link href="https://codeyg.top/2021/07/17/%E9%9D%A2%E8%AF%95--Maven/"/>
    <id>https://codeyg.top/2021/07/17/%E9%9D%A2%E8%AF%95--Maven/</id>
    <published>2021-07-17T13:58:58.000Z</published>
    <updated>2021-07-17T09:17:29.832Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下关于 Maven 的依赖冲突 ：</strong> </p><hr><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/maven.png" style="zoom: 67%;" /><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>之前在使用 maven 的时候还真的没有特意的留意过关于依赖冲突的问题。</p><p>这不，面试中被问到还有点猝不及防！</p><p>来吧，一起来回顾一遍~</p><a id="more"></a><h4 id="Maven-是什么？"><a href="#Maven-是什么？" class="headerlink" title="Maven 是什么？"></a>Maven 是什么？</h4><p>Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p><p>Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。</p><p>Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。</p><h4 id="Maven-POM"><a href="#Maven-POM" class="headerlink" title="Maven POM"></a>Maven POM</h4><p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖 （√）</li><li>插件（√）</li><li>执行目标（√）</li><li>项目构建 profile（√）</li><li>项目版本（√）</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>举个荔枝：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h4><h5 id="Maven-构建生命周期"><a href="#Maven-构建生命周期" class="headerlink" title="Maven 构建生命周期"></a>Maven 构建生命周期</h5><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_15-49-52.png" alt=""></p><table><thead><tr><th align="center">阶段</th><th align="center">处理</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">验证 validate</td><td align="center">验证项目</td><td align="center">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td align="center">编译 compile</td><td align="center">执行编译</td><td align="center">源代码编译在此阶段完成</td></tr><tr><td align="center">测试 test</td><td align="center">测试</td><td align="center">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td align="center">包装 package</td><td align="center">打包</td><td align="center">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td align="center">检查 verify</td><td align="center">检查</td><td align="center">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td align="center">安装 install</td><td align="center">安装</td><td align="center">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td align="center">部署 deploy</td><td align="center">部署</td><td align="center">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><h5 id="mvn-打包比较常用功能（重点）"><a href="#mvn-打包比较常用功能（重点）" class="headerlink" title="mvn 打包比较常用功能（重点）"></a>mvn 打包比较常用功能（重点）</h5><ul><li><p><code>clean</code>：执行该命令会删除项目路径下的 <font color=#FF8C00>target</font> 文件，但是不会删除本地的 maven 仓库已经生成的 jar 文件。</p></li><li><p><code>compile</code>：编译命令，会在项目路径下生成一个 <font color=#FF8C00>target</font> 目录，在该目录中包含一个classes文件夹，里面全是生成的class文件及字节码文件。</p></li><li><p><code>package</code>：这个命令会在你的项目路径下一个 <font color=#FF8C00>target</font> 目录，并且拥有 compile 命令的功能进行编译，同时会在 <font color=#FF8C00>target</font> 目录下生成项目的 jar/war 文件。</p></li><li><p><code>install</code>：该命令包含了 package 命令功能，不但会在项目路径下生成 class 文件和 jar 包，同时会在本地 maven 仓库生成 jar 文件，供其他项目使用。</p></li></ul><p>注意：</p><p><font color=#FF8C00>同时执行多次install或者package命令会每次都更新jar文件</font></p><h4 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h4><h5 id="Maven-仓库类型"><a href="#Maven-仓库类型" class="headerlink" title="Maven 仓库类型"></a>Maven 仓库类型</h5><p>Maven 仓库有三种类型：</p><ul><li>本地（local）：Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建。</li><li>中央（central）：Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</li><li>远程（remote）：如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</li></ul><h5 id="Maven-依赖搜索顺序"><a href="#Maven-依赖搜索顺序" class="headerlink" title="Maven 依赖搜索顺序"></a>Maven 依赖搜索顺序</h5><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><ul><li><strong>步骤 1</strong> － 在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。</li><li><strong>步骤 2</strong> － 在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中以备将来引用。</li><li><strong>步骤 3</strong> － 如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</li><li><strong>步骤 4</strong> － 在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库以备将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</li></ul><h5 id="Maven-阿里云-Aliyun-仓库"><a href="#Maven-阿里云-Aliyun-仓库" class="headerlink" title="Maven 阿里云(Aliyun)仓库"></a>Maven 阿里云(Aliyun)仓库</h5><p>修改 <code>maven</code> 根目录下的 conf 文件夹中的 settings.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven-的排除、归类和优化依赖"><a href="#Maven-的排除、归类和优化依赖" class="headerlink" title="Maven 的排除、归类和优化依赖"></a>Maven 的排除、归类和优化依赖</h4><h5 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h5><p>Maven 可能会自动引入快照版本的依赖，而快照版本的依赖是不稳定的，这时候就需要避免引入快照版本。这样的话需要用一种方式告知 Maven 排除快照版本的依赖引入，这种做法就是排除依赖。</p><p>直接依赖的配置里面添加 exclusions（除外） → exclusion（排除）元素，指定要排除依赖的 groupId 和 artifactId 就行。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h5><p>在引用依赖的时候，很多情况需要引入一个 Maven 项目的多个模块，这些模块都应该是相同的版本。</p><p>例如在下次升级，需要将 1.0 版本升级成 2.0 版本，这样就需要将 org.springframework 的每个模块的版本都统一更改，这样做很容易出现不一致的情况，就很容易出错。</p><p>为了避免出现这种情况，可以在 pom.xml 中定义一个属性名称描述版本的值。</p><p>举个荔枝：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 3.2.16.RELEASE,3.1.4.RELEASE --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.spring.version</span>&gt;</span>4.2.7.RELEASE<span class="tag">&lt;/<span class="name">project.build.spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.build.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="优化依赖"><a href="#优化依赖" class="headerlink" title="优化依赖"></a>优化依赖</h5><p> Maven 定位依赖的方式、传递依赖的规则以及怎么样排除依赖等。但是要实现这些动作，还必须对项目中的依赖有全面的了解，这样才能更有效地达到目的。</p><p>查看依赖的相关命令</p><p>列出所有的依赖列表。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:list</span><br></pre></td></tr></table></figure><p>以树形结构方式，列出依赖和层次关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:tree</span><br></pre></td></tr></table></figure><p>分析主代码、测试代码编译的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mvn dependency:analyze</span><br></pre></td></tr></table></figure><hr><h4 id="面试一下"><a href="#面试一下" class="headerlink" title="面试一下"></a>面试一下</h4><h5 id="什么是依赖冲突-版本冲突"><a href="#什么是依赖冲突-版本冲突" class="headerlink" title="什么是依赖冲突/版本冲突?"></a>什么是依赖冲突/版本冲突?</h5><p>Maven 的依赖机制会导致 jar 包的冲突</p><blockquote><p>举个例子，在项目中，使用了两个 jar 包，分别是 A 和 B。<br>现在 A 需要依赖另一个 jar 包 C，B 也需要依赖 C。<br>但是 A 依赖的 C 的版本是 1.0，B 依赖的C的版本是 2.0。<br>这时候，Maven 会将这 1.0 的 C 和 2.0 的 C 都下载到你的项目中，这样你的项目中就存在了不同版本的 C。</p></blockquote><p>这时Maven会采用<a href="#dependency"><font color=#FF8C00>最短路径优先原则</font></a>（即，根据寻找到的依赖路径中最短的），来决定使用哪个版本的 jar 包，而另一个无用的 jar 包则未被使用，这就是所谓的依赖冲突。</p><p>注意：</p><p>在大多数时候，依赖冲突可能并不会对系统造成什么异常，因为 Maven 始终选择了一个 jar 包来使用。<br>但是，不排除在某些特定条件下，会出现类似找不到类的异常。<br>所以，只要存在依赖冲突，最好还是解决掉，不要给系统留下隐患。</p><p>解决办法：</p><p>最经典的就是 log4j 的依赖排除，使用 Maven 提供的标签 exclusion</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>log4j-core 本身是依赖了 log4j-api 的，但是因为一些其他的模块也依赖了 log4j-api，并且两个 log4j-api 版本不同，所以我们使用标签排除掉 log4j-core 所依赖的 log4j-api，这样 Maven 就不会下载 log4j-core 所依赖的 log4j-api 了，也就保证了我们的项目中只有一个版本的 log4j-api。</p><h5 id="maven-的依赖原则"><a href="#maven-的依赖原则" class="headerlink" title="maven 的依赖原则"></a><span id="dependency">maven 的依赖原则</span></h5><p>maven 有三种原则依赖原则</p><p><font color=#008000>当一个项目中出现重复引用依赖 jar 包时，maven 一般有如下三种原则处理 jar</font></p><ol><li>最短路径原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; C -&gt; D(v1)</span><br><span class="line">F -&gt; G -&gt; D(v2)</span><br></pre></td></tr></table></figure><p>这个时候项目中就出现了两个版本的 D，这时 maven 会采用最短路径原则，选择 v2 版本的 D，因为 v1 版本的 D 是由 A 包间接依赖的，整个依赖路径长度为 3，而 v2 版本的 D 是由 F 包间接依赖的，整个依赖路径长度为 2。</p><ol start="2"><li>优先声明原则</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; B -&gt; D(v1)</span><br><span class="line">F -&gt; G -&gt; D(v2)</span><br></pre></td></tr></table></figure><p>如果两个 jar 包版本路径深度相同，则使用优先声明的版本 v1</p><ol start="3"><li>多次直接引不同版本的 jar 时，使用最后声明的版本</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.20.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果 pom 文件中，同时引用了如上两个版本，则会使用 4.3.20.RELEASE 版本（最后声明的版本）</p><h5 id="install-和-package-的区别"><a href="#install-和-package-的区别" class="headerlink" title="install 和 package 的区别"></a>install 和 package 的区别</h5><p>Maven install 安装指令，其实做了 2 件事情：</p><ol><li>将项目打包（jar/war），将打包结果放到项目下的 <font color=#FF8C00>target</font> 目录下；</li><li>同时将上述打包结果放到<font color=#FF8C00>本地仓库</font>的相应目录中，供其他项目或模块引用；</li></ol><p>Maven package 打包指令，其实就做了 1 件事：</p><ol><li>将项目打包（jar/war），将打包结果放到项目下的  <font color=#FF8C00>target</font> 目录下 （要先 clean）；</li></ol><p>注意：</p><p> clean 命令作用是：清理项目中 <font color=#FF8C00>target</font> 目录下文件；</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下关于 Maven 的依赖冲突 ：&lt;/strong&gt; &lt;/p&gt;
&lt;hr&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/maven.png&quot; style=&quot;zoom: 67%;&quot; /&gt;



&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;之前在使用 maven 的时候还真的没有特意的留意过关于依赖冲突的问题。&lt;/p&gt;
&lt;p&gt;这不，面试中被问到还有点猝不及防！&lt;/p&gt;
&lt;p&gt;来吧，一起来回顾一遍~&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="maven" scheme="https://codeyg.top/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--布隆过滤器</title>
    <link href="https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</id>
    <published>2021-07-16T13:58:58.000Z</published>
    <updated>2021-07-16T20:13:59.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下布隆过滤器</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-11-56.png" alt=""></p><p><strong>写在前面</strong></p><p><font color=#008000>为啥要写一篇关于布隆过滤器的博客？</font></p><p>还不是因为上集说到的 redis 中遇到缓存穿透的其中一个解决方案。</p><p>下面我们来详细的介绍一下 “ Bloom Filter ”</p><a id="more"></a><p>百度了一下：</p><p>布隆过滤器本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure）</p><p>特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在” 。</p><p> 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。 </p><p><font color=#008000>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？ </font></p><p>应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O (1) 的时间复杂度内返回结果，效率奇高。</p><p>了解布隆过滤器原理之前，先回顾下 Hash 函数原理。</p><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数的概念是：将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为哈希值或哈希编码，也叫散列值。如图：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-00-27.png" alt=""></p><p>所有散列函数都有如下基本特性：</p><ul><li>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为<strong>单向散列函数</strong>。</li><li>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同，这种情况称为“<strong>散列碰撞</strong>（collision）”。</li></ul><p>但是用 hash 表存储大数据量时，空间效率还是很低，当只有一个 hash 函数时，还很容易发生哈希碰撞。</p><h4 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h4><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-12-52.png" alt=""></p><p>如果我们要映射一个值到布隆过滤器中，我们需要使用<strong>多个不同的哈希函数</strong>生成<strong>多个哈希值，</strong>并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7（橙色部分）则上图转变为：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-13-24.png" alt=""></p><p>我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 （紫色部分）图继续变为：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-41-55.png" alt=""></p><p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了（绿色部分）</p><p>现在我们如果想查询 “google” 这个值是否存在，哈希函数返回了 1、5、8 三个值，结果我们发现 5 这个 bit 位上的值为 0，<strong>说明没有任何一个值映射到这个 bit 位上</strong>;</p><p>因此我们可以很确定地说 “google” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1;</p><p>那么我们可以说 “baidu” <strong>存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</strong></p><p>这是为什么呢？</p><p>答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位，例如：1、3、8 都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-44-00.png" alt=""></p><h4 id="布隆过滤器优点"><a href="#布隆过滤器优点" class="headerlink" title="布隆过滤器优点"></a>布隆过滤器优点</h4><p>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。</p><p>布隆过滤器存储空间和插入/查询时间都是常数。</p><p>另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p><p>布隆过滤器可以表示全集，其它任何数据结构都不能；</p><p>k 和 m 相同，使用同一组 Hash 函数的两个布隆过滤器的交并差运算可以使用位操作进行。</p><h4 id="布隆过滤器缺点"><a href="#布隆过滤器缺点" class="headerlink" title="布隆过滤器缺点"></a>布隆过滤器缺点</h4><p>布隆过滤器的缺点和优点一样明显。误算率（False Positive）是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。</p><p>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。</p><p>然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><h4 id="布隆过滤器的使用场景："><a href="#布隆过滤器的使用场景：" class="headerlink" title="布隆过滤器的使用场景："></a>布隆过滤器的使用场景：</h4><p>在程序的世界中，布隆过滤器是程序员的一把利器，利用它可以快速地解决项目中一些比较棘手的问题。</p><p>如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。</p><p>布隆过滤器的典型应用有：</p><ul><li>数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。</li><li>业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。</li><li>缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。</li><li>WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务</li><li>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。</li><li>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。</li></ul><h4 id="布隆过滤器的使用（Java版）"><a href="#布隆过滤器的使用（Java版）" class="headerlink" title="布隆过滤器的使用（Java版）"></a>布隆过滤器的使用（Java版）</h4><ol><li>需要引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个布隆过滤器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.log4j.Log4j2;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.DisplayName;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@DisplayName</span>(<span class="string">"TestBloomFilterTest测试类"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBloomFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===============测试开始==============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===============测试结束==============="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName</span>(<span class="string">"布隆过滤器"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BloomFilterTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BloomFilter&lt;String&gt; filter = BloomFilter.create(</span><br><span class="line">                Funnels.stringFunnel(Charset.defaultCharset()),</span><br><span class="line">                <span class="number">1000</span>,</span><br><span class="line">                <span class="number">0.001</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        filter.put(<span class="string">"baidu.com"</span>);</span><br><span class="line">        filter.put(<span class="string">"tencent.com"</span>);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"布隆过滤器中是否含有 baidu.com? &#123;&#125;"</span>,filter.mightContain(<span class="string">"baidu.com"</span>));</span><br><span class="line">        log.info(<span class="string">"布隆过滤器中是否含有 google.com? &#123;&#125;"</span>,filter.mightContain(<span class="string">"google.com"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>结果</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_03-35-30.png" alt=""></p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>本质上布隆过滤器是一种数据结构，特点是高效地插入和查询，可以用来确定<font color=#FF8C00>某个值一定不存在或者可能存在</font></p><p>回到 redis 中遇到缓存穿透的其中一个解决方案，布隆过滤器能够过滤掉一定不存在的值，也就是说，我们可以把数据库中所有的数据存储到布隆过滤器中，一旦有非法的值传进来，就能够轻而易举的判断出该值对于数据库来说是否有效，从而避免无谓的查询。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下布隆过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-11-56.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;为啥要写一篇关于布隆过滤器的博客？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;还不是因为上集说到的 redis 中遇到缓存穿透的其中一个解决方案。&lt;/p&gt;
&lt;p&gt;下面我们来详细的介绍一下 “ Bloom Filter ”&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Redis</title>
    <link href="https://codeyg.top/2021/07/15/%E9%9D%A2%E8%AF%95--Redis/"/>
    <id>https://codeyg.top/2021/07/15/%E9%9D%A2%E8%AF%95--Redis/</id>
    <published>2021-07-15T13:58:58.000Z</published>
    <updated>2021-07-16T20:23:09.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 Redis</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-16_21-42-34.png" alt=""></p><p><strong>写在前面</strong></p><h4 id="为什么不直接访问数据库？要在中间加一个Redis缓存？"><a href="#为什么不直接访问数据库？要在中间加一个Redis缓存？" class="headerlink" title="为什么不直接访问数据库？要在中间加一个Redis缓存？"></a><font color=#008000>为什么不直接访问数据库？要在中间加一个Redis缓存？</font></h4><p>其实我在了解redis之前一直有这样一个疑问，但是既然使用redis作为中间缓存一定是有道理的！</p><p>那么一起来看一下使用redis有哪些好处吧~</p><a id="more"></a><p><strong>原因：</strong></p><ol><li>Redis 可以用几十 G 内存来做缓存；</li><li>Redis 的缓存可以持久化 （RBD &amp; AOF）；</li><li>Redis 可以实现分布式的缓存；</li><li>Redis 可以处理每秒百万级的并发，是专业的缓存服务；</li><li>Redis 缓存有过期机制；</li><li>Redis 有丰富的 API。</li></ol><p>其中redis最典型的应用场景，当做缓存使用。</p><p>因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等……</p><ul><li>服务在处理请求时先从redis里获取结果，获取到了就可以直接返回，没有获取到的话再从数据库里获取，然后存到redis里以供下次使用。</li><li>用redis的好处是可以做到分布式，有状态的数据都存在redis里，使业务服务层无状态，以便业务层有很高的可扩展性。</li></ul><h4 id="先来说下redis是什么吧？"><a href="#先来说下redis是什么吧？" class="headerlink" title="先来说下redis是什么吧？"></a><font color=#008000>先来说下redis是什么吧？</font></h4><p>我：Redis是C语言开发的一个开源的高性能键值对（key-value）的内存数据库；</p><p>它是一种NoSQL（非关系型数据库）的数据库。</p><p>可以用作数据库、缓存、消息中间件等。</p><p>我接着说：Redis作为一个内存数据库。</p><ol><li>性能优秀，数据在内存中，读写速度非常快，支持并发10W QPS；</li><li>单进程单线程，是线程安全的，采用IO多路复用机制；</li><li>丰富的数据类型；</li><li>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；</li><li>主从复制，哨兵，高可用；</li><li>可以用作分布式锁；</li><li>可以作为消息中间件使用，支持发布订阅。</li></ol><br/><h4 id="具体说一下Redis有哪些数据结构呀？"><a href="#具体说一下Redis有哪些数据结构呀？" class="headerlink" title="具体说一下Redis有哪些数据结构呀？"></a><font color=#008000>具体说一下Redis有哪些数据结构呀？</font></h4><p>答：字符串（String）、字典（Hash）、列表（List）、集合（Set）、有序集合（SortedSet）</p><p><font color=#FF8C00>后面了解到还有：HyperLogLog、Geo、Pub/Sub 【这是加分的内容】</font></p><br/><h4 id="使用过Redis分布式锁么，它是怎么回事？"><a href="#使用过Redis分布式锁么，它是怎么回事？" class="headerlink" title="使用过Redis分布式锁么，它是怎么回事？"></a><font color=#008000>使用过Redis分布式锁么，它是怎么回事？</font></h4><p>答：先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><br/><h4 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a><font color=#008000>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</font></h4><p>（这道题很经典啊，网上见过~）</p><p>答：使用<code>keys</code>指令可以扫出指定模式的key列表 【 key  keys xxx*】</p><br/><h4 id="那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a><font color=#008000>那如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</font></h4><p>答：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p><p><font color=#FF8C00>后面了解到：这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</font></p><br/><h4 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a><font color=#008000>使用过Redis做异步队列么，你是怎么用的？</font></h4><p>答：一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><br/><h4 id="能不能生产一次消费多次呢？"><a href="#能不能生产一次消费多次呢？" class="headerlink" title="能不能生产一次消费多次呢？"></a><font color=#008000>能不能生产一次消费多次呢？</font></h4><p>答：使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p><br/><h4 id="pub-su-b有什么缺点？"><a href="#pub-su-b有什么缺点？" class="headerlink" title="pub/su b有什么缺点？"></a><font color=#008000>pub/su b有什么缺点？</font></h4><p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<code>RabbitMQ</code>等。</p><br/><h4 id="Redis是怎么持久化的？"><a href="#Redis是怎么持久化的？" class="headerlink" title="Redis是怎么持久化的？"></a><font color=#008000>Redis是怎么持久化的？</font></h4><p>（送分题~）</p><p>答：RBD 和 AOF </p><ul><li><p>RDB做镜像全量持久化，即将整个Redis内存数据持久化到一个文件。</p></li><li><p>AOF做增量持久化，AOF会将redis中每一步对数据修改的操作记录（日志）append到相应的文件中。</p></li></ul><br/><h4 id="那说一下-RBD-和-AOF-的优劣，及其原理吧"><a href="#那说一下-RBD-和-AOF-的优劣，及其原理吧" class="headerlink" title="那说一下 RBD 和 AOF 的优劣，及其原理吧"></a><font color=#008000>那说一下 RBD 和 AOF 的优劣，及其原理吧</font></h4><p>答：</p><p><strong>RDB</strong></p><p>优点：</p><ul><li>二进制压缩文件，恢复速度快</li></ul><p>缺点：</p><ul><li>可能丢失数据（服务器宕机的时候）</li></ul><p>原理：</p><p><strong>fork</strong> 和 <strong>cow</strong></p><ul><li>fork是指redis通过创建子进程来进行RDB操作；</li><li>cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><p><strong>AOF</strong></p><p>优点：</p><ul><li>不易丢失数据，数据完整性好</li></ul><p>缺点：</p><ul><li>每一步操作都记录，相对影响性能</li><li>数据恢复慢，文件较大</li></ul><p>原理：</p><p>为了降低 IO 消耗，AOF 写文件时，会先将数据写到缓冲区，然后再把缓冲区的内容 flush 到磁盘，这个过程叫做 fsync。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ appendfsync always  //每次写操作都flush，影响性能</span><br><span class="line">$ appendfsync everysec  //每秒flush</span><br><span class="line">$ appendfsync no  //消极等待OS刷新(一般30s),可能丢失数据</span><br></pre></td></tr></table></figure><p>相比于always的激进和no的消极，everysec在性能和数据完整性上取了一个折中。</p><br/><h4 id="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"></a><font color=#008000>是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？</font></h4><p>答：</p><ul><li><p>Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master，继续提供服务。</p></li><li><p>Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。</p></li></ul><br/><h4 id="Redis-会遇到的缓存雪崩，缓存穿透，缓存击穿吧"><a href="#Redis-会遇到的缓存雪崩，缓存穿透，缓存击穿吧" class="headerlink" title="Redis 会遇到的缓存雪崩，缓存穿透，缓存击穿吧"></a><font color=#008000>Redis 会遇到的缓存雪崩，缓存穿透，缓存击穿吧</font></h4><p>先来了解一下缓存雪崩，缓存穿透，缓存击穿是什么意思！</p><p>一、缓存雪崩</p><p><strong>含义：</strong></p><p>缓存雪崩表示在某一时间段，缓存集中失效，导致请求全部走数据库，有可能搞垮数据库，使整个服务瘫痪。</p><p>使缓存集中失效的原因：</p><ol><li><p>redis服务器挂掉了。</p></li><li><p>对缓存数据设置了相同的过期时间，导致某时间段内缓存集中失效。（√）</p></li></ol><p><strong>解决方案：</strong></p><ol><li><p>针对原因1，可以实现redis的高可用，Redis Cluster 或者 Redis Sentinel(哨兵) 等方案。</p></li><li><p>针对原因2，设置缓存过期时间时加上一个随机值，避免缓存在同一时间过期。</p></li></ol><p>举个荔枝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 设置过期时间加上一个随机值</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_1'</span>, <span class="string">'文章内容'</span>, 60 + mt_rand(1, 60));</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_2'</span>, <span class="string">'文章内容'</span>, 60 + mt_rand(1, 60));</span><br></pre></td></tr></table></figure><ol start="3"><li>使用双缓存策略，设置两个缓存，原始缓存和备用缓存，原始缓存失效时，访问备用缓存，备用缓存失效时间设置长点。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 原始缓存</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_2'</span>, <span class="string">'文章内容'</span>, 60);</span><br><span class="line"><span class="comment">## 设置备用缓存，失效时间设置长点</span></span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_backup_2'</span>, <span class="string">'文章内容'</span>, 1800);</span><br></pre></td></tr></table></figure><p>二、缓存穿透</p><p><strong>含义：</strong></p><p>缓存穿透表示查询一个一定不存在的数据，由于没有获取到缓存，所以没写入缓存，导致这个不存在的数据每次都需要去数据库查询，失去了缓存的意义。</p><p>请求的数据大量的没有获取到缓存，导致走数据库，有可能搞垮数据库，使整个服务瘫痪。</p><p>比如文章表，一般我们的主键ID都是无符号的自增类型，有些人想要搞垮你的数据库，每次请求都用负数ID，而ID为负数的记录在数据库根本就没有。</p><p><strong>解决方案：</strong></p><ol><li>对于像ID为负数的非法请求直接过滤掉，采用<a href="https://codeyg.top/2021/07/16/%E9%9D%A2%E8%AF%95--%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"><font color=#FF8C00>布隆过滤器 ( Bloom Filter )</font> </a>。</li><li>禁用IP 限制IP访问。</li><li><strong>限流</strong> 每秒最多访问3次。</li><li>针对在数据库中找不到记录的，我们仍然将该空数据存入缓存中，当然一般会设置一个较短的过期时间。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置文章ID为-10000的缓存为空</span><br><span class="line"><span class="variable">$id</span> = -10000;</span><br><span class="line"><span class="variable">$redis</span>-&gt;<span class="built_in">set</span>(<span class="string">'article_content_'</span> . <span class="variable">$id</span>, <span class="string">''</span>, 60);</span><br><span class="line"> </span><br><span class="line">var_dump(<span class="variable">$redis</span>-&gt;get(<span class="string">'article_content_'</span> . <span class="variable">$id</span>));</span><br></pre></td></tr></table></figure><p>三、缓存击穿</p><p><strong>含义：</strong></p><p>缓存击穿表示某个key的缓存非常热门，有很高的并发一直在访问，如果该缓存失效，那同时会走数据库，压垮数据库。</p><p>缓存击穿与缓存雪崩的区别是这里针对的是某一热门 key 缓存，而雪崩针对的是大量缓存的集中失效。</p><p><strong>解决方案：</strong></p><ol><li>让该热门 key 的缓存永不过期。</li><li>使用互斥锁，通过 redis 的 setnx 实现互斥锁。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRedis</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = <span class="keyword">new</span> Redis();</span><br><span class="line">    $redis-&gt;connect(<span class="string">'127.0.0.1'</span>, <span class="number">6379</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> $redis;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lock</span>(<span class="params">$key, $random</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    <span class="comment">//设置锁的超时时间，避免释放锁失败，del()操作失败，产生死锁。</span></span><br><span class="line">    $ret = $redis-&gt;<span class="keyword">set</span>($key, $random, ['nx', 'ex' =&gt; 3 * 60]);</span><br><span class="line">    return $ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//解锁</span><br><span class="line">function unLock($key, $random)</span><br><span class="line">&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    <span class="comment">//这里的随机数作用是，防止更新缓存操作时间过长，超过了锁的有效时间，导致其他请求拿到了锁。</span></span><br><span class="line">    <span class="comment">//但上一个请求更新缓存完毕后，如果不加判断直接删除锁，就会误删其他请求创建的锁。</span></span><br><span class="line">    <span class="keyword">if</span> ($redis-&gt;<span class="keyword">get</span>($key) == $random) &#123;</span><br><span class="line">        $redis-&gt;del($key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//从缓存中获取文章数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArticleInCache</span>(<span class="params">$id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $redis = getRedis();</span><br><span class="line">    $key = <span class="string">'article_content_'</span> . $id;</span><br><span class="line">    $ret = $redis-&gt;<span class="keyword">get</span>($key);</span><br><span class="line">    if ($ret === false) &#123;</span><br><span class="line">        <span class="comment">//生成锁的key</span></span><br><span class="line">        $lockKey = $key . <span class="string">'_lock'</span>;</span><br><span class="line">        <span class="comment">//生成随机数，用于设置锁的值，后面释放锁时会用到</span></span><br><span class="line">        $random = mt_rand();</span><br><span class="line">        <span class="comment">//拿到互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (lock($lockKey, $random)) &#123;</span><br><span class="line">            <span class="comment">//这里是伪代码，表示从数据库中获取文章数据</span></span><br><span class="line">            $value = $db-&gt;getArticle($id);</span><br><span class="line">            <span class="comment">//更新缓存，过期时间可以根据情况自已调整</span></span><br><span class="line">            $redis-&gt;<span class="keyword">set</span>($key, $value, 2 * 60);</span><br><span class="line">            //释放锁</span><br><span class="line">            unLock($lockKey, $random);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            <span class="comment">//等待200毫秒，然后重新获取缓存值，让其他获取到锁的进程取得数据并设置缓存</span></span><br><span class="line">            usleep(<span class="number">200</span>);</span><br><span class="line">            getArticleInCache($id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Redis&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-16_21-42-34.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么不直接访问数据库？要在中间加一个Redis缓存？&quot;&gt;&lt;a href=&quot;#为什么不直接访问数据库？要在中间加一个Redis缓存？&quot; class=&quot;headerlink&quot; title=&quot;为什么不直接访问数据库？要在中间加一个Redis缓存？&quot;&gt;&lt;/a&gt;&lt;font color=#008000&gt;为什么不直接访问数据库？要在中间加一个Redis缓存？&lt;/font&gt;&lt;/h4&gt;&lt;p&gt;其实我在了解redis之前一直有这样一个疑问，但是既然使用redis作为中间缓存一定是有道理的！&lt;/p&gt;
&lt;p&gt;那么一起来看一下使用redis有哪些好处吧~&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="redis" scheme="https://codeyg.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>日积月累</title>
    <link href="https://codeyg.top/2021/07/01/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    <id>https://codeyg.top/2021/07/01/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/</id>
    <published>2021-06-30T23:07:07.000Z</published>
    <updated>2021-07-20T15:43:57.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-13-27.png" alt=""></p><a id="more"></a><h4 id="1、-Autowired和-Resource的区别是什么？"><a href="#1、-Autowired和-Resource的区别是什么？" class="headerlink" title="1、@Autowired和@Resource的区别是什么？"></a><font color=#008000>1、@Autowired和@Resource的区别是什么？</font></h4><p>联系：</p><ul><li>@Autowired和@Resource注解都是作为bean对象注入的时候使用的；</li><li>两者都可以声明在字段和setter方法上；</li></ul><p>区别：</p><ul><li>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的；</li><li>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入；</li><li>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错；</li></ul><hr><h4 id="2、HashMap与ConcurrentHashMap的区别？"><a href="#2、HashMap与ConcurrentHashMap的区别？" class="headerlink" title="2、HashMap与ConcurrentHashMap的区别？"></a><font color=#008000>2、HashMap与ConcurrentHashMap的区别？</font></h4><p>相同点：</p><ul><li>首先两者的相同点在于底层都是数组+链表实现实现的；</li></ul><p>区别：</p><ul><li>HashMap是线程非安全的，ConcurrentHashMap是线程安全的</li></ul><hr><h4 id="3、处理哈希冲突的方法？"><a href="#3、处理哈希冲突的方法？" class="headerlink" title="3、处理哈希冲突的方法？"></a><font color=#008000>3、处理哈希冲突的方法？</font></h4><ul><li>开放定址法</li><li>链地址法（√）</li><li>再散列法</li></ul><hr><h4 id="4、包装类和基本数据类型的区别？"><a href="#4、包装类和基本数据类型的区别？" class="headerlink" title="4、包装类和基本数据类型的区别？"></a><font color=#008000>4、包装类和基本数据类型的区别？</font></h4><p>包装类：</p><ul><li><p>优点：</p><ul><li>可以赋值为null</li><li>提供了一系列的方法常用的有：parseInt(String s)、tostring()、valueOf(String s)、equals( object object)、i.compareto(integer anotherIntger)</li><li><font color=#FF8C00>集合中不允许放基本数据类型，只能放包装类！</font></li></ul></li><li><p>缺点：</p><ul><li>由于每个值分别包装在对象中，所以ArrayList的效率远远低于int[]数组</li></ul></li></ul><p>基本数据类型：</p><ul><li><p>优点：</p><ul><li>计算效率高</li><li>不会由于常量池而引起比较大小的错误</li></ul></li><li><p>缺点：</p><ul><li>当数据库查询出结果封装到结果集时,如何返回的值为null时,会将结果赋值给字段,运行时会报错,不能将null值赋值给基本数据类型</li></ul></li></ul><p><strong>两者的区别：</strong><br>1、声明方式不同，基本类型不适用new关键字，而包装类型需要使用new关键字来在堆中分配存储空间；<br>2、存储方式及位置不同，基本类型是直接将变量值存储在堆栈中，而包装类型是将对象放在堆中，然后通过引用来使用；<br>3、初始值不同，基本类型的初始值如int为0，boolean为false，而包装类型的初始值为null<br>4、使用方式不同，基本类型直接赋值直接使用就好，而包装类型在集合如Collection、Map时会使用到。<br>5、包装类都是继承Number 接口实现Compareble 接口的</p><hr><h4 id="5、MyISAM-和-INNODB-的区别？"><a href="#5、MyISAM-和-INNODB-的区别？" class="headerlink" title="5、MyISAM 和 INNODB 的区别？"></a><font color=#008000>5、MyISAM 和 INNODB 的区别？</font></h4><ol><li><p>事务安全：</p><p>MyISAM 不支持事务（×）</p><p>INNODB  支持事务（√）</p></li><li><p>外键 ：</p><p>MyISAM 不支持外键（×）</p><p> INNODB 支持外键（√）</p></li><li><p>锁机制：</p><p>MyISAM 是表锁</p><p>INNODB 是行锁</p></li><li><p>查询和添加速度：</p><p>MyISAM 批量插入速度快</p></li><li><p>支持全文索引：</p><p>MyISAM 支持全文索引（√）</p><p>INNODB 不支持全文索引（×）</p></li><li><p>MyISAM 内存空间使用率比 INNODB 低</p></li></ol><p>Memory 存储，比如我们数据变化频繁，不需要入库，同时又频繁的查询和修改，我们考虑使用 memory, 速度极快. （如果 mysql 重启的话，数据就不存在了）</p><p> <strong>未完待续 … …</strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-17_04-13-27.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="日积月累" scheme="https://codeyg.top/tags/%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--SpringBoot启动原理</title>
    <link href="https://codeyg.top/2021/06/27/%E9%9D%A2%E8%AF%95--SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://codeyg.top/2021/06/27/%E9%9D%A2%E8%AF%95--SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-27T13:58:58.000Z</published>
    <updated>2021-07-02T15:23:20.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 SpringBoot 启动原理：</strong></p><hr><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spring-boot-logo.png" style="zoom:67%;" /><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近在不断的面试中总结<code>Spring</code>全家桶已经是必须要熟练掌握的框架了，其中化繁为简的<code>SpringBoot</code>更是经常被提及的框架，所以我今天就来聊聊 SpringBoot。</p><p>说起<code>SpringBoot</code>的江湖地位，由于其设计优雅，实现简单，可以节省不少开发时间。</p><a id="more"></a><blockquote><p>以下源码的 <code>SpringBoot</code> 版本：2.3.9.RELEASE</p></blockquote><p>其实<code>SpringBoot</code>的启动大体上分为 2 个步骤：</p><ol><li>启动类上注解：@SpringBootApplication</li><li>启动类中的main方法：org.springframework.boot.SpringApplication#run(java.lang.Class&lt;?&gt;, java.lang.String…)</li></ol><h4 id="启动原理"><a href="#启动原理" class="headerlink" title="启动原理"></a>启动原理</h4><h5 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h5><p>main 方法上的注解 @SpringBootApplication：</p><p>三个注解核心注解：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguratio</li><li>@ComponentScan</li></ul><p><strong>@SpringBootConfiguration</strong></p><p>根据 Javadoc 可知，该注解作用就是将当前的类作为一个 <strong>JavaConfig</strong>，然后<strong>触发注解</strong><code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的<strong>处理</strong>，本质上与<strong>@Configuration</strong>注解没有区别。</p><p><strong>@ComponentScan</strong></p><p>扫描的 <code>Spring</code> 对应的组件，如 <strong>@Componet</strong>，<strong>@Repository</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 SpringBoot 启动原理：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spring-boot-logo.png&quot; style=&quot;zoom:67%;&quot; /&gt;

&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;最近在不断的面试中总结&lt;code&gt;Spring&lt;/code&gt;全家桶已经是必须要熟练掌握的框架了，其中化繁为简的&lt;code&gt;SpringBoot&lt;/code&gt;更是经常被提及的框架，所以我今天就来聊聊 SpringBoot。&lt;/p&gt;
&lt;p&gt;说起&lt;code&gt;SpringBoot&lt;/code&gt;的江湖地位，由于其设计优雅，实现简单，可以节省不少开发时间。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="SpringBoot" scheme="https://codeyg.top/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--Spring入门</title>
    <link href="https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/"/>
    <id>https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2021-06-19T13:58:58.000Z</published>
    <updated>2021-06-20T17:01:17.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇Java小知识</p></blockquote><p><strong>本篇着重介绍一下 Spring 框架</strong></p><hr><br><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png" style="zoom:50%;" /><br><br><p><strong>写在前面</strong></p><p>百度百科：</p><p>Spring 框架是由于软件开发的复杂性而创建的。</p><p>Spring 使用的是基本的<code>JavaBean</code>来完成以前只可能由<code>EJB</code>完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。</p><a id="more"></a><h3 id="Spring-的整体架构"><a href="#Spring-的整体架构" class="headerlink" title="Spring 的整体架构"></a>Spring 的整体架构</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1555451-20200715233519469-2015600342.png" style="zoom:90%;" /><hr><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>A 表现层  <code>web</code>层 、 <code>MVC</code>是表现层的一个设计模型 </li><li>B 业务层 <code>service</code>层</li><li>C 持久层 <code>dao</code>层</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>要与 SPringMVC 的三层架构区分开。</p><h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><ul><li><strong>spring-core</strong> 模块提供了框架的基本组成部分，包括 <code>IoC</code> 和依赖注入功能。</li><li><strong>spring-beans</strong> 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</li><li><strong>context</strong> 模块建立在由 <strong>core</strong>和 <strong>beans</strong> 模块的基础上建立起来的，它以一种类似于 JNDI 注册的方式访问对象。Context 模块继承自 Bean 模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过 Servelet 容器）等功能。Context 模块也支持 Java EE 的功能，比如 EJB、JMX 和远程调用等。<strong>ApplicationContext</strong> 接口是 Context 模块的焦点。<strong>spring-context-support</strong> 提供了对第三方集成到 Spring 上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</li><li><strong>spring-expression</strong> 模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是 JSP2.1 规范中定义的统一表达式语言的扩展，支持 set 和 get 属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从 Spring IoC 容器检索对象，还支持列表的投影、选择以及聚合等。</li></ul><h4 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h4><p><font color=#FF0000>注：JDBC【Java Data Base Connectivity】，ORM【Object Relational Mapping】，OXM【Object XML Mapping】，JMS【Java Message Service】</font></p><ul><li><strong>JDBC</strong> 模块提供了 JDBC 抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。</li><li><strong>ORM</strong> 模块提供了对流行的对象关系映射 API 的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring的其它功能整合，比如前面提及的事务管理。</li><li><strong>OXM</strong> 模块提供了对 OXM 实现的支持，比如 JAXB、Castor、XML Beans、JiBX、XStream 等。</li><li><strong>JMS</strong> 模块包含生产（produce）和消费（consume）消息的功能。从 Spring 4.1 开始，集成了 spring-messaging 模块。</li><li><strong>事务</strong>模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写 beginTransaction()、commit()、rollback() 等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细）</li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p><ul><li><strong>Web</strong> 模块提供面向 web 的基本功能和面向 web 的应用上下文，比如多部分（multipart）文件上传功能、使用 Servlet 监听器初始化 IoC 容器等。它还包括 HTTP 客户端以及 Spring 远程调用中与 web 相关的部分。</li><li><strong>Web-MVC</strong> 模块为 web 应用提供了模型视图控制（MVC）和 REST Web服务的实现。Spring 的 MVC 框架可以使领域模型代码和 web 表单完全地分离，且可以与 Spring 框架的其它所有功能进行集成。</li><li><strong>Web-Socket</strong> 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</li><li><strong>Web-Portlet</strong> 模块提供了用于 Portlet 环境的 MVC 实现，并反映了 spring-webmvc 模块的功能。</li></ul><hr><h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><h4 id="Spring-框架的优点"><a href="#Spring-框架的优点" class="headerlink" title="Spring 框架的优点"></a>Spring 框架的优点</h4><ol><li>非侵入式设计</li><li>方便解耦、简化开发</li><li>支持AOP</li><li>支持声明式事务处理</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>降低Jave EE API的使用难度。</li></ol><p><font color=#008000>说到 spring 的容器管理就不得不先提一下 bean 的概念</font></p><h4 id="Bean-的概念"><a href="#Bean-的概念" class="headerlink" title="Bean 的概念"></a>Bean 的概念</h4><ol><li>在 Java 中，“Bean”是对“可重用组件”的惯用叫法。组件本身就是一个抽象概念，Bean 作为其代称，也是一个抽象概念，当我们将一个类或一个对象作为组件来考虑时，就可以称它为 Bean。</li><li>在 Spring 中，Bean 的概念同上，它有时也被称为 Component。由 Spring 容器管理的 Bean 则称为 Spring Bean。</li></ol><p><strong>扩展：</strong></p><ul><li><p><em>Java Bean</em> 的概念不同于 Bean，Java Bean 是指符合 <em>JavaBeans</em> 规范的一类特殊的 Bean，即：所有属性均为 private，提供 getter 和 setter，提供默认构造方法。JavaBean 也可以认为是遵循特定约定的 POJO。</p></li><li><p>POJO（Plain Ordinary Java Object）是指简单且普通的 Java 对象。严格来说，它不继承类，不实现接口，不处理业务逻辑，仅用于封装数据。</p></li></ul><p><font color=#008000>说到 spring 就不得不提到两个重要的概念</font></p><ul><li>IoC 【控制反转】</li><li>DI 【依赖注入】</li></ul><h4 id="IOC-与-DI"><a href="#IOC-与-DI" class="headerlink" title="IOC 与 DI"></a>IOC 与 DI</h4><h5 id="IOC-定义"><a href="#IOC-定义" class="headerlink" title="IOC 定义"></a>IOC 定义</h5><p>IoC（Inverse Of Control，控制反转）是一种设计思想，所谓控制反转，指的是对资源的控制方式进行反转。</p><p><strong>IOC 容器</strong>具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>【控制权在自己】：在 OOP 中，对象之间往往存在某种依赖关系，当一个对象依赖另一个对象时，传统 OOP 的做法是在它内部直接 <strong>new</strong> 一个出来，这种做法是由对象自己主动创建并管理依赖资源。</p><p>【控制权在 Spring 容器】：”控制反转”是指 <strong>new</strong> 实例工作不由程序员来做而是交给 Spring 容器来做。使得对象不再主动控制依赖资源，而是被动接受资源，IoC 要求将资源的控制权下放给 <strong>Ioc</strong> 容器，它将对资源进行集中管理，对象需要什么资源就从容器中取，或者让容器主动将资源注入进来。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>在 IoC 之后，对象与依赖资源之间不再具有强耦合性，资源可以被直接替换，而无需改动需求方的代码。</p><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>在 Spring 中 <strong>BeanFactory</strong> 是 IOC 容器的实际代表者。【工厂模式】</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_20-38-32.png" alt=""></p><hr><h5 id="Spring-的两种-IoC-容器"><a href="#Spring-的两种-IoC-容器" class="headerlink" title="Spring 的两种 IoC 容器"></a>Spring 的两种 IoC 容器</h5><p>Spring 提供了两种 IoC 容器： BeanFactory 和 ApplicationContext </p><ul><li>BeanFactory 提供基本的 IoC 服务支持。</li><li>ApplicationContext 对 BeanFactory 进行了扩展与增强，除了拥有 BeanFactory 的所有能力外，还提供了许多高级特性，如事件发布、资源加载、国际化消息等。ApplicationContext 接口继承自 BeanFactory 接口，它的实现也是直接复用了 BeanFactory 的实现，因此可以说，ApplicationContext 是 BeanFactory 的增强版。</li></ul><p>两者在核心功能上的区别主要是默认的加载策略不同，这点区别几乎可以忽略不计，通常情况下，我们总是使用更为强大的 ApplicationContext，很少会直接使用 BeanFactory。</p><h5 id="IoC-的两种实现方式"><a href="#IoC-的两种实现方式" class="headerlink" title="IoC 的两种实现方式"></a>IoC 的两种实现方式</h5><ul><li>DI（Dependency Injection，依赖注入）<br>所谓依赖注入，是指对象所依赖的资源将通过被动注入的方式得到，换言之，容器会主动地根据预先配置的依赖关系将资源注入进来。</li><li>DL（Dependency Lookup，依赖查找）<br>依赖查找是早先提出的一种 IoC 实现方式，它要求对象主动查找依赖资源，这种方式已经不再使用。</li></ul><h5 id="DI-定义"><a href="#DI-定义" class="headerlink" title="DI 定义"></a>DI 定义</h5><p>Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>依赖注入主要有两种实现方式，分别是属性 setter 注入和构造方法注入</p><ol><li><strong>属性 setter 注入</strong></li></ol><p>指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。</p><ol start="2"><li><strong>构造方法注入</strong></li></ol><p>指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。</p><h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇Java小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Spring 框架&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;br&gt;

&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百度百科：&lt;/p&gt;
&lt;p&gt;Spring 框架是由于软件开发的复杂性而创建的。&lt;/p&gt;
&lt;p&gt;Spring 使用的是基本的&lt;code&gt;JavaBean&lt;/code&gt;来完成以前只可能由&lt;code&gt;EJB&lt;/code&gt;完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="https://codeyg.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://codeyg.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--TCP 3次挥手与4次握手</title>
    <link href="https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2021-06-16T13:58:58.000Z</published>
    <updated>2021-06-20T17:26:20.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 TCP 3次挥手与4次握手 ：</strong> 但不局限于介绍 TCP~</p><hr><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>划重点</strong></p><p><font color=#008000><code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议</font></p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。</p><p>那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。</p><a id="more"></a><h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1612150605-NindRH-image.png" style="zoom:67%;" /><hr><p>由上至下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP-头部包含哪些信息"><a href="#HTTP-头部包含哪些信息" class="headerlink" title="HTTP 头部包含哪些信息"></a>HTTP 头部包含哪些信息</h4><p>HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p><p>下面重点来说一下我们熟悉的 “实体头部” </p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td><strong>Content-Type</strong></td><td><strong>返回内容的MIME类型</strong></td><td><strong>Content-Type: text/html; charset=utf-8</strong></td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><hr><h4 id="POST-和-Get-的区别"><a href="#POST-和-Get-的区别" class="headerlink" title="POST 和 Get 的区别"></a>POST 和 Get 的区别</h4><p>我们知道，HTTP定义了与服务器进行交互的不同方法，常见的有四种：GET、POST、PUT、DELETE。其中，GET 和 POST 最常用。</p><ul><li><code>GET</code> 用来获取资源，它只是获取、查询数据，不会修改服务器的数据。</li><li><code>POST</code> 则是可以向服务器发送修改请求，进行数据的修改的。</li></ul><h5 id="从性能角度"><a href="#从性能角度" class="headerlink" title="从性能角度"></a>从性能角度</h5><ol><li>post 携带的请求头更多；</li><li>握手次数 post：get （6 : 4）；</li><li>get 保存数据（Ajax），post则不会；</li></ol><h5 id="从安全角度"><a href="#从安全角度" class="headerlink" title="从安全角度"></a>从安全角度</h5><ol><li>post 更加的安全（请求数据不会作为 url 的一部分，缓存、日志等）</li><li>post 发送的数据量更大，get 有 url 的长度限制；</li><li>post 发送的更多的数据类型 ， get 只能是 ASCLL；</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>我们常说的一些区别都是一些表面上的。</p><p>比如：<code>GET</code>没有<code>POST</code>安全；<code>GET</code>请求时<code>URL</code>的长度是有限制的；<code>GET</code>没有<code>body</code>而<code>POST</code>有<code>body</code>等等。</p><p>这些都是针对浏览器中的要求， 在使用<code>HTTP</code>作为接口进行传输时，就没有这么多条条框框了。</p><p>此时<code>GET</code>和<code>POST</code>只是<code>HTTP</code>协议中的两种请求方式，而<code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议， 无论<code>GET</code>还是<code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别。</p><p><code>GET</code>也可以有<code>body</code>，<code>POST</code>也不一定非要使用<code>body</code></p><hr><h4 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h4><p><font color=#008000>HTTP 和 HTTPS 的区别有哪些？</font></p><p>最明显直观的就是在网页上访问网址，地址栏位的 url 显示区别</p><ul><li>如果是 http 请求，则显示为不安全</li><li>如果是 https 请求，则显示为安全</li></ul><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。</p><p><strong>HTTP报文格式</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/http_get_post.png" style="zoom:67%;" /><h5 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h5><p><strong>HTTPS = SSL + HTTP</strong></p><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><strong>Http：</strong></p><ul><li>无状态 【是指协议对于交互性场景没有记忆能力、cookie / session 让服务器有记忆能力】</li><li>无连接 【限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接】</li><li>基于请求和响应</li><li>简单快速</li><li>使用明文通信（不会确认通信方）</li></ul><p><strong>Https:</strong></p><ul><li>通过 SSL / TLS 提供加密</li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol><li>Https更加的安全</li><li>Https需要申请证书</li><li>端口不同：http =&gt; 80； https =&gt; 443；</li><li>状态不同：http =&gt; 无状态； https =&gt; 协议加密；</li></ol><h5 id="HTTP通信传输"><a href="#HTTP通信传输" class="headerlink" title="HTTP通信传输"></a>HTTP通信传输</h5><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_00-36-54.png" alt=""></p><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手经典图例（客户端请求服务端获取数据）</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-13-48.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【seq】序号</p><p>【ack】确认序号</p><p>【SYN】同步                                                        </p><p>【ACK】确认</p><p><strong>三次握手</strong></p><ul><li><p>第一次握手：客户端首先向服务端发送请求，tcp 报文头中发送标识 SYN=1 (SYN表示客户端请求跟服务端建立连接),序号 Seq=x。</p></li><li><p>第二次握手：服务端在接收到客户端发送的请求之后，需要告诉客户端已收到请求，tcp 报文头中发送标识SYN=1,ACK=1(SYN表示服务端请求跟客户端建立连接，ACK 表示对客户端的连接请求进行应答),序号 Seq=y,确认号=x+1（表示对客户端发送的序号Seq=x的请求进行确认）。</p></li><li><p>第三次握手：客户端在接收到服务端发送的请求和确认信息之后，同样需要告诉服务端已收到信息，tcp 报文头中发送标识 ACK=1(ACK表示对服务端的连接请求进行应答),序号 Seq=x+1，确认号 Ack=y+1（表示对服务端发送的序号 Seq=y 的请求进行确认）</p><p>当三次握手都成功的时候，我们发现此时客户端发送的信息服务端能够收到并且服务端发送的信息客户端也能收到，通信双方<strong>连接成功</strong>。</p></li></ul><p><strong>注意</strong></p><ol><li>发送请求中的发送标识SYN、ACK表示的是发送报文中两个标识位！而Seq和Ack分别代表发送序号和确认号。</li><li>服务端在接收到了客户端的连接请求后，回复中同时发送了SYN、ACK两个标识位，将建立连接的请求和对客户端的确认应答在同一个数据包中发送了，这也是为什么只需要三次握手，就能建立连接</li></ol><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><font color=#008000>当客户端和服务端之间的数据传输完毕之后，我们就需要释放连接（一直建立连接会浪费资源），那为啥需要四次挥手呢？</font></p><p>四次挥手经典图例</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-35-29.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【MSL】报文最大生存时间 （它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃）</p><p><strong>四次挥手</strong></p><ul><li><p>第一次挥手：客户端向服务端发送断开连接的请求，告诉服务端我这边不需要再请求你的数据了，tcp报文头中发送标识FIN=1（表示客户端请求跟服务端断开连接）,序号Seq=u</p></li><li><p>第二次挥手：服务端在接收到客户端发送的断开请求后，需告诉客户端已收到请求，tcp报文头中发送标识ACK=1(ACK表示对客户端的断开连接的请求进行应答),序号Seq=v,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）。</p></li><li><p>第三次挥手：当服务端数据传输完毕之后，向客户端发起断开连接的请求，告诉客户端我这边也不需要再发送数据了，tcp报文头中发送标识FIN=1，ACK=1(FIN表示服务端请求跟客户端断开连接，ACK表示对上一次客户端的断开连接的请求进行应答),序号Seq=w,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）</p></li><li><p>第四次挥手：客户端接收到服务发送的断开连接请求后，需告诉服务端已收到信息，作出应答，tcp报文头中发送标识ACK=1(ACK表示对服务端的断开连接的请求进行应答),序号Seq=u+1,确认号Ack=w+1（表示对服务端发送的序号Seq=w的请求进行确认）</p></li></ul><p><font color=#008000>1. 为什么不能像握手的时候一样三次握手，为啥需要四次挥手呢？</font></p><p>答：在实际的网络中，服务端在接收到客户端断开连接的请求的时候，此时服务端可能还有数据没有传输完毕，不能立即向客户端发送断开连接的请求！</p><p>当客户端主动发起断开请求的时候，服务器先回应一个确认，等所有数据传输完毕后再发送服务器断开的请求。</p><p><font color=#008000>2. 为什么需要维持2MSL呢？</font></p><p>答：第4次挥手的时候客户端向服务端发送断开连接的请求的确认ACK，如果客户端发送完成后就直接就关闭连接，如果由于网络原因服务端没有收到ACK，那服务端就没法关闭连接了！</p><p>因此客户端在回复确认后，还需要等待，万一服务端没有收到应答还会继续发送断开连接的请求；</p><hr><h4 id="TCP-长连接和短连接"><a href="#TCP-长连接和短连接" class="headerlink" title="TCP 长连接和短连接"></a>TCP 长连接和短连接</h4><p><strong>长连接</strong>：</p><p> 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。 </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-09-20.png" alt=""></p><p><strong>短连接</strong>：</p><p>短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-08-13.png" alt=""></p><p><strong>应用场景：</strong></p><p> 长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况。</p><p>例如：</p><ul><li>数据库的连接用长连接（如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费）</li><li>微信，QQ 之类的即时通讯（文本消息、语音消息、视频消息、图片消息）。</li></ul><p>短连接多用于 WEB 网站的 http 服务。</p><p>因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP协议（Internet Protocol，互联网协议），是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p><ul><li><p>IP 就是一张身份证，存在于电脑、手机、监控摄像头、汽车等任何需要联网的设备上面；</p></li><li><p>IP 是可以被追踪到和定位的；</p></li></ul><p>面试的时候有面试官聊到关于网络相关考点，于是问道：</p><p><font color=#008000>能说出访问一个网页的全过程？</font></p><p>答：打开浏览器，在地址栏输入URL，回车，出现网页内容。</p><p>太笼统了，要具体！</p><p><font color=#008000>在地址栏输入URL后，整个过程发生了什么？其中的原理是什么？</font></p><p>答：整个过程可以概括为几下几个部分：</p><ol><li>通过解析域名找到 IP，如果缓存里没有就要请求 DNS 服务器得到 IP 地址；</li><li>与目的主机进行 TCP 连接（三次握手）构建 HTTP 请求；</li><li>发送与收取数据（浏览器与目的主机开始HTTP访问过程）；</li><li>与目的主机断开 TCP 连接（四次挥手）；</li></ol><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p><font color=#008000>能简单说说域名解析？并且一个域名可以对应多个IP地址吗？</font></p><p>域名通过 <code>DNS</code> 解析 得到 <code>IP</code> </p><p>首先得知道啥是 DNS ？</p><p>DNS（Domain Name System）是因特网的一项服务，它作为域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>解析域名</li></ul><p>人们在通过浏览器访问网站时只需要记住网站的域名即可，而不需要记住那些不太容易理解的IP地址。</p><p>在DNS系统中有一个比较重要的的资源类型叫做主机记录也称为A记录，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p><ul><li>负载均衡</li></ul><p>DNS除了能解析域名之外还具有负载均衡的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-49-29.png" alt=""></p><hr><p>由上图可以看出，在 DNS 服务器中应该配置了多个A记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.apusapp.com IN A 114.100.20.201;</span><br><span class="line">www.apusapp.com IN A 114.100.20.202;</span><br><span class="line">www.apusapp.com IN A 114.100.20.203;</span><br></pre></td></tr></table></figure><p>每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。</p><p>一个域名可以对应多个IP地址。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 TCP 3次挥手与4次握手 ：&lt;/strong&gt; 但不局限于介绍 TCP~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;划重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;&lt;code&gt;HTTP&lt;/code&gt;协议是基于&lt;code&gt;TCP/IP&lt;/code&gt;的应用层协议&lt;/font&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。&lt;/p&gt;
&lt;p&gt;那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="计算机网络" scheme="https://codeyg.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--锁（Lock）</title>
    <link href="https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/"/>
    <id>https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/</id>
    <published>2021-06-15T13:58:58.000Z</published>
    <updated>2021-06-20T18:07:51.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 Java 中的锁：</strong></p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>面试中我们都会遇到一个场景：</p><p><font color=#008000>在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？</font></p><p>很多人脑海里最先想到的一定是“加锁”。</p><p>提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。</p><p><font color=#008000>除了使用 sychronized 关键字，还有其他的解决方案吗？</font></p><p>JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。</p><p>JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。</p><p>下面我们来详细的介绍一下 “锁”</p><hr><a id="more"></a><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-13-50.png"  /><hr><h3 id="Java-的主流锁都有哪些"><a href="#Java-的主流锁都有哪些" class="headerlink" title="Java 的主流锁都有哪些"></a>Java 的主流锁都有哪些</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/lock.png" style="zoom: 67%;" /><p>悲观锁、乐观锁、自旋锁、偏向锁、轻量级锁、重量级锁、公平锁、非公平锁、可重入锁、非可重入锁。</p><h4 id="1、乐观锁-VS-悲观锁"><a href="#1、乐观锁-VS-悲观锁" class="headerlink" title="1、乐观锁 VS 悲观锁"></a>1、乐观锁 VS 悲观锁</h4><p>顾名思义，两种锁的名字分别体现了看待线程同步的不同角度。</p><p>对于同一个数据的并发操作：</p><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/optimistic_pessimistic.png" style="zoom:50%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 1、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 操作同步资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、ReentrantLock</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止因为没有获取到锁的情况，finally中lock.unlock()去释放锁，导致出错！</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 操作同步资源</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">optimistic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();  <span class="comment">//执行自增1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。</p><p><font color=#008000>为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</font></p><p>答：乐观锁的主要实现方式 “CAS” 的技术原理实现。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p><p>java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。所以对于乐观锁，“更新”是一个不断重试的操作。</p><p>那么我们进入原子类 AtomicInteger 的源码，看一下 AtomicInteger 的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-15_23-27-12.png" alt=""></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储 value 在 AtomicInteger 中的偏移量。</li><li>value： 存储 AtomicInteger 的 int 值，该属性需要借助 volatile 关键字保证其在线程间是可见的。</li></ul><h6 id="CAS虽然很高效，但是它也存在三大问题"><a href="#CAS虽然很高效，但是它也存在三大问题" class="headerlink" title="CAS虽然很高效，但是它也存在三大问题"></a>CAS虽然很高效，但是它也存在三大问题</h6><ol><li>ABA问题</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ol><h6 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h6><p>加标志位，例如搞个⾃增的字段，操作⼀次就⾃增加⼀，或者搞个时间戳，⽐较时间戳的值。</p><p> 举个栗⼦：现在我们去要求操作数据库，根据CAS的原则我们本来只需要查询原本的值就好了，现在我 们⼀同查出他的标志位版本字段vision。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue where value &#x3D; #&#123;oldValue&#125;</span><br><span class="line"># oldValue就是我们执⾏前查询出来的值</span><br></pre></td></tr></table></figure><p>带版本号能防⽌ABA的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue ，vision &#x3D; vision + 1 where value &#x3D; #</span><br><span class="line">&#123;oldValue&#125; and vision &#x3D; #&#123;vision&#125;</span><br><span class="line"># 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不⼀样</span><br></pre></td></tr></table></figure><hr><h4 id="2、自旋锁-VS-适应性自旋锁"><a href="#2、自旋锁-VS-适应性自旋锁" class="headerlink" title="2、自旋锁 VS 适应性自旋锁"></a>2、自旋锁 VS 适应性自旋锁</h4><p><font color=#008000>为什么要有自旋锁和适应性自旋锁？</font></p><p>首先，阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spinlocks.png" style="zoom:50%;" /><p>虽然自旋锁有效的避免了因线程之间的切换而产生的开销，但是也并非没有缺点。</p><p>缺点就是它不能代替阻塞。而且它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好。</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次）没有成功获得锁，就应当挂起线程。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-09-40.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-11-25.png" alt=""></p><hr><p>自旋锁的实现原理同样也是CAS。</p><p>AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><h5 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h5><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</p></li><li><p>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。、</p></li></ul><hr><h4 id="3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h4><p>这四种锁是指锁的状态，专门针对synchronized的。</p><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/8afdf6f2.png" style="zoom:50%;" /><hr><h4 id="4、公平锁-VS-非公平锁"><a href="#4、公平锁-VS-非公平锁" class="headerlink" title="4、公平锁 VS 非公平锁"></a>4、公平锁 VS 非公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p><ul><li><p>优点：等待锁的线程不会饿死。</p></li><li><p>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p></li></ul><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p><ul><li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/fair_lock.png" style="zoom:50%;" /><hr><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/not_fair_lock.png" style="zoom: 67%;" /><hr><p>ReentrantLock的源码来看一下公平锁和非公平锁</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-32-49.png" alt=""></p><hr><h4 id="5、可重入锁-VS-非可重入锁"><a href="#5、可重入锁-VS-非可重入锁" class="headerlink" title="5、可重入锁 VS 非可重入锁"></a>5、可重入锁 VS 非可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁。</p><p>可重入锁的一个优点是可一定程度避免死锁。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 可重入锁 -------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。 </p><p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p><font color=#008000>为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？</font></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/reentrant_lock.png" style="zoom:50%;" /><p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/no_reentrant_lock.png" style="zoom:50%;" /><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><hr><h4 id="6、独享锁-VS-共享锁"><a href="#6、独享锁-VS-共享锁" class="headerlink" title="6、独享锁 VS 共享锁"></a>6、独享锁 VS 共享锁</h4><p>独享锁（排他锁）和共享锁同样是一种概念。</p><ul><li>独享锁是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</li><li>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-58-22.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-00-45.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-02-36.png" alt=""></p><hr><p>ReentrantReadWriteLock 有两把锁：</p><ul><li><p>ReadLock</p></li><li><p>WriteLock</p></li></ul><p>由词知意，一个读锁一个写锁，合称“读写锁”</p><p>最终发现在 ReentrantLock 虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Java 中的锁：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;面试中我们都会遇到一个场景：&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;很多人脑海里最先想到的一定是“加锁”。&lt;/p&gt;
&lt;p&gt;提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;除了使用 sychronized 关键字，还有其他的解决方案吗？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。&lt;/p&gt;
&lt;p&gt;JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。&lt;/p&gt;
&lt;p&gt;下面我们来详细的介绍一下 “锁”&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="锁" scheme="https://codeyg.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM垃圾回收机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T15:58:58.000Z</published>
    <updated>2021-06-20T18:32:48.750Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面</strong></p><p>为啥要写这篇文章呢？还要从很久之前的一次问答说起！</p><p><font color=#008000>什么是 Java 垃圾回收机制？（ JC 哥问我）</font></p><p>我：就是收集一些不被用到的对象，然后集中销毁吧~</p><p><font color=#008000>那应该如何来判断那些对象不被用到呢？</font></p><p>我：好像是 … … 我真的不知道</p><p><font color=#008000>仔细想想</font></p><p>我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？</p><p><font color=#008000>我就说嘛，想想能知道的，继续</font></p><p>我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？</p><p><font color=#008000>是个办法，具体呢？</font></p><p>我：xxx xxx</p><p>…</p><p>…</p><p>最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）</p><p><strong>本篇着重介绍一下JVM垃圾回收机制：</strong></p><hr><a id="more"></a><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><p>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。</p><p>在<code>JVM</code>中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p><font color=#008000>回去好好看一下什么是 GC ，那GC 是什么？</font></p><h3 id="GC-是什么？为什么要-GC"><a href="#GC-是什么？为什么要-GC" class="headerlink" title="GC 是什么？为什么要 GC"></a>GC 是什么？为什么要 GC</h3><p>GC 垃圾收集（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存。</p><p>不当的回收可能会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p><font color=#008000>首先来看一下 Java 中都有哪些引用类型吧</font></p><h3 id="Java-中的引用类型"><a href="#Java-中的引用类型" class="headerlink" title="Java 中的引用类型"></a>Java 中的引用类型</h3><ol><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ol><p><font color=#008000>我之前说通过标记位（flag）来判断对象是否被引用，算是说对了一点点吧</font></p><h3 id="如何判断对象是否可以被回收？什么时候被回收？"><a href="#如何判断对象是否可以被回收？什么时候被回收？" class="headerlink" title="如何判断对象是否可以被回收？什么时候被回收？"></a>如何判断对象是否可以被回收？什么时候被回收？</h3><p><strong>一般有两种方法来判断：</strong></p><ol><li><strong>引用计数器法</strong><br>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。但是他有一个缺点是不能解决循环引用的问题。</li></ol><ol start="2"><li><strong>可达性分析算法</strong><br>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ol><blockquote><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p></blockquote><p><font color=#008000>说了这么多，既然是算法都分别有哪些呢？</font></p><h3 id="JVM-的垃圾回收算法？"><a href="#JVM-的垃圾回收算法？" class="headerlink" title="JVM 的垃圾回收算法？"></a>JVM 的垃圾回收算法？</h3><ul><li><p>标记-清除算法</p></li><li><p>标记-复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代-收集算法</p></li></ul><h4 id="标记-清除算法（mark-sweep）"><a href="#标记-清除算法（mark-sweep）" class="headerlink" title="标记-清除算法（mark-sweep）"></a>标记-清除算法（mark-sweep）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>该算法分为两个阶段，<strong>标记和清除</strong>。</p><p>标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>执行速度快</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>执行效率不稳定，大量的标记、清除</li><li>内存碎片严重化，后续可能发生对象不能找到利用空间的问题</li></ol><h4 id="标记-复制算法（mark-cope）"><a href="#标记-复制算法（mark-cope）" class="headerlink" title="标记-复制算法（mark-cope）"></a>标记-复制算法（mark-cope）</h4><p>标记-复制算法也称为【半区复制】</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>按内存容量将内存划分为等大小的两块。</p><p>每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>内存连续</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>内存使用率不高，只有原来的一半，浪费内存空间</p><h4 id="标记-整理算法（mark-compact）"><a href="#标记-整理算法（mark-compact）" class="headerlink" title="标记-整理算法（mark-compact）"></a>标记-整理算法（mark-compact）</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>改进于标记-标记-清除算法，通过标记后将存活的对象移动向内存的一端，然后清除端边界外的对象。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>保证了内存的连续性，不会浪费内存。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li><p>效率低（需要移动内存对象）</p></li><li><p>移动时会有并发问题。</p></li></ol><p><font color=#008000>重点说一下分代-收集算法</font></p><h4 id="分代-收集算法（generation-collect）"><a href="#分代-收集算法（generation-collect）" class="headerlink" title="分代-收集算法（generation-collect）"></a>分代-收集算法（generation-collect）</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>根据对象存活周期的不同将内存划分为几块，一般是<strong>新生代</strong>和<strong>老年代</strong>，新生代基本采用标记-复制算法，老年代采用标记-整理算法和标记-清除算法。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_02-26-58.png" alt=""></p><p>新生代每次垃圾回收大偶会后大批的对象死去，每次回收存活后的少量对象在阈值将去到老年代。</p><h5 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h5><p><strong>对象优先在 Eden 区分配：</strong></p><p>多数情况，对象都在新生代 Eden 区分配。</p><p>当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。</p><p>如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><ul><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代</strong></p><p>新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。</p><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><p>大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。<br>        虚拟机提供了一个<code>XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用的是复制算法）。</p><p><strong>长期存活对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。</p><p>因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。</p><p>对象在 Survivor 区中每过一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为啥要写这篇文章呢？还要从很久之前的一次问答说起！&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是 Java 垃圾回收机制？（ JC 哥问我）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：就是收集一些不被用到的对象，然后集中销毁吧~&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;那应该如何来判断那些对象不被用到呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：好像是 … … 我真的不知道&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;仔细想想&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;我就说嘛，想想能知道的，继续&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;是个办法，具体呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：xxx xxx&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM垃圾回收机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM内存结构</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-13T14:58:58.000Z</published>
    <updated>2021-06-20T17:15:14.091Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#008000>什么是JVM？</font></p><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下JVM内存结构：</strong></p><hr><a id="more"></a><h4 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:67%;" /><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储<strong>类信息、常量、静态变</strong>量等数据，是<strong>线程共享</strong>的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>线程与进程：</strong></p><ul><li>同步于线程：程序计数器、虚拟机栈、本地方法栈</li><li>同步于进程：方法区、堆</li></ul><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<strong>唯一一个不会出现Stack Overflow Error 的地方。</strong></p><h4 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>1、对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>2、Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。</p><p><strong>控制参数</strong></p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><h4 id="内存结构相关包含"><a href="#内存结构相关包含" class="headerlink" title="内存结构相关包含"></a>内存结构相关包含</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_01-13-25.png" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#008000&gt;什么是JVM？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM内存结构：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- Java的类加载机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-06-14T17:08:29.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h4><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下Java的类加载机制：</strong></p><hr><a id="more"></a><h4 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>加载的过程包括了<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。</p><p><strong>加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段获取类的二进制字节流的动作是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>验证：确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>准备：为类的 <code>静态变量分</code>配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量是指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p><strong>结束生命周期</strong></p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 <code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>定义</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是JVM？&quot;&gt;&lt;a href=&quot;#什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM？&quot;&gt;&lt;/a&gt;什么是JVM？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下Java的类加载机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--HashMap红黑树</title>
    <link href="https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-07-16T20:17:12.867Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 HashMap为什么用红黑树：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上文说到，HashMap的扩容原理。</p><p>JDK1.7 使用的是 <strong>数组 + 单链表</strong> 的数据结构。</p><p>JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。</p><p>当阈值是默认阈值 <strong>0.75</strong>，链表的深度大于等于 <strong>8</strong>，数组容量大于等于 <strong>64</strong> 时，扩容的时候会把链表转成红黑树，时间复杂度从 <strong>O(n)</strong> 变成 <strong>O(logN)</strong>；当红黑树的节点深度小于等于 <strong>6</strong> 时，红黑树会转为<strong>链表结构</strong>。</p><p><strong><font color=#008000>在Java8中为什么要使用红黑树来实现的HashMap？</font></strong></p><p>答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）</p><a id="more"></a><h4 id="什么是红黑树呢？"><a href="#什么是红黑树呢？" class="headerlink" title="什么是红黑树呢？"></a>什么是红黑树呢？</h4><p>别急，先来回顾一下什么是二叉树！</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>简单地理解，满足以下两个条件的树就是二叉树：</p><ol><li>本身是有序树；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><blockquote><p>二叉树还可以继续分类，衍生出<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p></blockquote><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为<strong>满二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-34-34.898Z.png" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为<strong>完全二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-35-38.517Z.png" alt=""></p><center>完全二叉树</center><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-36-27.077Z.png" alt=""></p><center>非完全二叉树</center><hr><p>好了说完二叉树相关的知识后，还没有引入红黑树，因为在不断优化的过程中还是需要慢慢来，回顾一下平衡二叉树（AVL Tree）。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T12-57-32.630Z.png" style="zoom:67%;" /><p>对二叉树的节点进行查找发现深度为 1 的节点的查找次数为 1，深度为2的查找次数为 2，深度为n的节点的查找次数为n，因此其平均查找次数为  (1+2+2+3+3+3) / 6 = 2.3 次</p><p>当然上面是理想的情况，因为二叉查找树可以任意地构造，同样是 2,3,5,6,7,8 这六个数字，也可以按照下图的方式来构造。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-03-36.302Z.png" style="zoom:67%;" /><p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称 AVL 树。</p><h4 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h4><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p><p>AVL树，它的任何节点的两个子树的高度差&lt;=1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-13-21.964Z.png" style="zoom: 67%;" /><center>AVL树</center><p>不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-15-54.465Z.png" style="zoom:67%;" /><center>非AVL树</center><p>至此，引出红黑树(弱平衡二叉树)</p><h4 id="红黑树-弱平衡二叉树"><a href="#红黑树-弱平衡二叉树" class="headerlink" title="红黑树(弱平衡二叉树)"></a>红黑树(弱平衡二叉树)</h4><p>红黑树也属于平衡二叉树，但在每个节点增加一个存储位表示节点的颜色，非红即黑。</p><p>红黑树的英文是“Red-Black Tree”，简称R-B Tree。它是一种不严格的平衡二叉查找树，我前面说了，它的定义是不严格符合平衡二叉查找树的定义的。</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：<strong>如果一个结点存在黑子结点，那么该结点肯定有两个子结点</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-37-06.560Z.png" style="zoom:80%;" /><hr><h4 id="B树（Balance-Tree）"><a href="#B树（Balance-Tree）" class="headerlink" title="B树（Balance-Tree）"></a>B树（Balance-Tree）</h4><p><strong>B树是一颗多路平衡查找树</strong></p><p>它类似普通的平衡二叉树，不同的一点是B 树允许每个节点有更多的子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T14-44-46.777Z.png" alt=""></p><p>B 树有如下特点:</p><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况 O(1) 就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><p><strong>B 树是专门为外部存储器设计的</strong>。如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p><p><strong>B 树允许每个节点有更多的子节点即可（多叉树）</strong>。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p><h4 id="B-树（-Balance-Tree）"><a href="#B-树（-Balance-Tree）" class="headerlink" title="B+树（ Balance+Tree）"></a>B+树（ Balance+Tree）</h4><p><strong>B+Tree是在B Tree基础上的一种优化</strong>，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>B+Tree相对于B Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li><strong>数据记录都存放在叶子节点中</strong>；（查询时间复杂度固定为 log n）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-41-28.142Z.png" alt=""></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种<strong>链式环结构</strong>。</p><p>咋一看 B+ 树好像查询要比 B 树慢一些（同样的数据，查询【IO】次数变多了），但是是事实如此吗？</p><p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p><p>B+ 树可以很好的利用局部性原理，若我们访问节点 key为 80，则 key 为 79、83、87的节点将来也可能被访问，<strong>磁盘预读原理</strong>就会提前把这些数据都读进内存，使得范围查询和排序都很快，从而减少了磁盘 IO 的次数。</p><p>由于B树的节点都存了 key 和 data ，而 B+ 树只有叶子节点存 data，非叶子节点都只是索引值，没有实际的数据，这就时 B+ 树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！</p><p>B+ 树优势：</p><ol><li>B+ 树叶节点两两相连可大大增加区间访问性；</li><li>B+ 树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确；</li></ol><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p><strong><font color=#008000>MySQL 为什么使用 B Tree（B+Tree）存储？</font></strong></p><p>这就是下篇博客要着重介绍的东西咯~</p><p>我好像发现通过一个 hashmap 能够牵扯出一连串的知识啊！</p><p>这可能就是它的知识体系吧，正如我们在面试的过程中，面试官通过一个”点“，问着问着就问出来一个“面”。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 HashMap为什么用红黑树：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;上文说到，HashMap的扩容原理。&lt;/p&gt;
&lt;p&gt;JDK1.7 使用的是 &lt;strong&gt;数组 + 单链表&lt;/strong&gt; 的数据结构。&lt;/p&gt;
&lt;p&gt;JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。&lt;/p&gt;
&lt;p&gt;当阈值是默认阈值 &lt;strong&gt;0.75&lt;/strong&gt;，链表的深度大于等于 &lt;strong&gt;8&lt;/strong&gt;，数组容量大于等于 &lt;strong&gt;64&lt;/strong&gt; 时，扩容的时候会把链表转成红黑树，时间复杂度从 &lt;strong&gt;O(n)&lt;/strong&gt; 变成 &lt;strong&gt;O(logN)&lt;/strong&gt;；当红黑树的节点深度小于等于 &lt;strong&gt;6&lt;/strong&gt; 时，红黑树会转为&lt;strong&gt;链表结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=#008000&gt;在Java8中为什么要使用红黑树来实现的HashMap？&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="HashMap" scheme="https://codeyg.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>排序总结（Sort Algorithm）</title>
    <link href="https://codeyg.top/2021/06/12/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/"/>
    <id>https://codeyg.top/2021/06/12/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-12T15:58:58.000Z</published>
    <updated>2021-06-14T17:10:34.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重为排序做个总结：</strong></p><hr><h4 id="什么是排序算法？"><a href="#什么是排序算法？" class="headerlink" title="什么是排序算法？"></a>什么是排序算法？</h4><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p><a id="more"></a><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_conclusion.jpg" style="zoom:67%;" /><h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_all_photo.png" style="zoom: 67%;" /><h4 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面 （相等不交换位置）；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面（相等交换位置）；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间；</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小；</li></ul><h4 id="比较和非比较的区别"><a href="#比较和非比较的区别" class="headerlink" title="比较和非比较的区别"></a>比较和非比较的区别</h4><p><font color=#FF8C00>快速排序、归并排序、堆排序、冒泡排序  </font>等属于 <font color=#008000>比较排序</font></p><p><font color=#FF8C00>计数排序、基数排序、桶排序 </font> 则属于  <font color=#FF0000>非比较排序</font></p><p>比较排序：在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置</p><p>非比较排序：非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置</p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><ul><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3)</li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1691302-20191103200642835-1582365806.png" alt=""></p><p>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述<strong>时间复杂度不断增大，算法的执行效率越低</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重为排序做个总结：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;什么是排序算法？&quot;&gt;&lt;a href=&quot;#什么是排序算法？&quot; class=&quot;headerlink&quot; title=&quot;什么是排序算法？&quot;&gt;&lt;/a&gt;什么是排序算法？&lt;/h4&gt;&lt;p&gt;排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="排序总结" scheme="https://codeyg.top/tags/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--HashMap原理</title>
    <link href="https://codeyg.top/2021/06/12/%E9%9D%A2%E8%AF%95--HashMap/"/>
    <id>https://codeyg.top/2021/06/12/%E9%9D%A2%E8%AF%95--HashMap/</id>
    <published>2021-06-12T13:58:58.000Z</published>
    <updated>2021-07-16T20:17:20.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 HashMap：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>众所周知，HashMap 是一个用于存储 <strong>Key-Value</strong> 键值对的集合，每一个键值对也叫做 <strong>Entry</strong>。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是 HashMap 的主干。</p><p><strong>画个重点：</strong></p><p><font color=#008000><strong>Hash的公式 —&gt;  index = HashCode（Key） &amp; （Length - 1）</strong></font></p><p><strong>HashMap 的数据结构两种：数组 + 链表</strong></p><ul><li>数组：查询速度快，可以根据索引查询；但插入和删除比较困难；</li><li>链表：查询速度慢，需要遍历整个链表，但插入和删除操作比较容易;</li><li>HashMap 是数组和链表组成的，数据结构中又叫“链表散列”;</li></ul><a id="more"></a><h4 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h4><ol><li>快速存储 ：比如当我们对 hashmap 进行 get 和 put 的时候速度非常快</li><li>快速查找（时间复杂度o(1)）当我们通过key去get一个 value 的时候时间复杂度非常的低，<strong>效率非常高</strong></li><li>可伸缩：(1) 数组扩容，边长；(2) 单线列表如果长度超过 <strong>8</strong> 的话会变成红黑树</li></ol><h4 id="HashMap的扩容原理"><a href="#HashMap的扩容原理" class="headerlink" title="HashMap的扩容原理"></a>HashMap的扩容原理</h4><p>HashMap 数组每一个元素的初始值都是 Null；</p><p>对于 HashMap，我们最常使用的是两个方法：<strong>Get</strong> 和 <strong>Put</strong> （获取和添加）</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614000934162.png" alt=""></p><h5 id="1-Put方法的原理"><a href="#1-Put方法的原理" class="headerlink" title="1.Put方法的原理"></a>1.Put方法的原理</h5><p>调用 Put 方法的时候发生了什么呢？</p><p>比如调用 hashMap.put(“apple”, 0) ，插入一个 Key 为 “apple” 的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：</p><p><strong>index = Hash（“apple”）</strong></p><p>假定最后计算出的index是2，那么结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-10-29.609Z.png" alt=""></p><p>但是，因为 HashMap 的长度是有限的，当插入的 Entry 越来越多时，再完美的 Hash 函数也难免会出现 <strong>index冲突</strong>的情况。比如下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T17-26-02.319Z.png" alt=""></p><p>HashMap数组的每一个元素不止是一个 <strong>Entry 对象</strong>，也是一个链表的<strong>头节点</strong>。每一个Entry对象通过 <strong>Next指针</strong>指向它的下一个 <strong>Entry节点</strong>。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表即可：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T17-26-37.073Z.png" alt=""></p><blockquote><p>当前采用的是 jdk 7 默认方法，也就是头插法</p></blockquote><h5 id="2-Get方法的原理"><a href="#2-Get方法的原理" class="headerlink" title="2.Get方法的原理"></a>2.Get方法的原理</h5><p><font color=#008000>使用Get方法根据Key来查找Value的时候，发生了什么呢？</font></p><p>首先会把输入的 Key 做一次 Hash 映射，得到对应的 index：</p><p><strong>index = Hash（“apple”）</strong>  <strong>=&gt;</strong>   <strong>index = 2</strong></p><p>由于刚才所说的 Hash 冲突，同一个位置有可能匹配到多个 Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的 Key 是 <strong>“apple”</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-02-40.117Z.png" alt=""></p><ul><li>第一步，我们查看的是头节点 Entry6，<strong>Entry6</strong> 的 Key 是 <strong>banana</strong>，显然不是我们要找的结果。</li><li>第二步，我们查看的是 Next 节点 Entry1，<strong>Entry1</strong> 的 Key 是 <strong>apple</strong>，正是我们要找的结果。</li></ul><blockquote><p>之所以把 Entry6 放在头节点，是因为 HashMap 的发明者认为，<strong>后插入的 Entry 被查找的可能性更大</strong>。</p></blockquote><hr><h5 id="HashMap-尾插法"><a href="#HashMap-尾插法" class="headerlink" title="HashMap 尾插法"></a>HashMap 尾插法</h5><p>上面提到过 hashmap 添加采用的是 jdk 7 默认方法（头插法），那一定时有原因的呀！</p><p>当来到 jdk 8 的时候改成尾插法了，why？</p><p><font color=#008000>来看看Node的源码</font></p><p>每一个节点都会保存自身的 <strong>hash</strong>、<strong>key</strong>、<strong>value</strong> 以及下个<strong>Next</strong>（节点）</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/carbon_node6-14.png" style="zoom: 50%;" /><p><strong>java8之前是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</p><p>但是，<strong>在java8之后，都是所用尾部插入了。</strong></p><p><font color=#008000>为啥改为尾部插入呢？</font></p><p>答：数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。</p><p><font color=#008000>什么时候resize呢？</font></p><p>答：</p><ol><li>有两个因素：</li></ol><ul><li>Capacity：HashMap当前长度 【list.length()】</li><li>LoadFactor：负载因子，默认值0.75f 【3/4】</li></ul><blockquote><p>比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容</p></blockquote><ol start="2"><li>分为两步：</li></ol><ul><li>扩容：创建一个新的 Entry 空数组，长度是原数组的 2 倍。</li><li>ReHash：遍历原 Entry 数组，把所有的Entry重新 Hash 到新数组。</li></ul><p><font color=#008000>为什么不直接复制过去？</font></p><p>答：是因为长度扩大以后，Hash的规则也随之改变。</p><p>（原来长度（Length）是 8 你位运算出来的值是 2 ，新的长度是 16 你位运算出来的值明显不一样了）</p><blockquote><p>Hash的公式 —&gt;  index = HashCode（Key） &amp; （Length - 1）</p></blockquote><p>扩容前：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-29-38.438Z.png" alt=""></p><p>扩容后： </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-30-05.405Z.png" alt=""></p><p>现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入 A，B，C</p><p>我们可以看到链表的指向 A =&gt; B =&gt; C</p><p><strong>Tip：A的下一个指针是指向B的</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-41-18.300Z.png" style="zoom:80%;" /><p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>所以：可能会出现 B 的下一个指针指向了 A</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-47-33.913Z.png" style="zoom:80%;" /><p>一旦几个线程都调整完成，就可能出现<strong>环形链表</strong>！</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-49-53.769Z.png" style="zoom:80%;" /><p>这个时候去取值,会出现 <strong>Infinite Loop</strong></p><hr><p>来到 jdk 8 链表有红黑树代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本 O(n) 的时间复杂度降低到了 O(logn)。</p><p>好处：如果<strong>使用尾插</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><p>就是说原本是 A =&gt; B ，在扩容后那个链表还是 A =&gt; B </p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T19-42-46.501Z.png" style="zoom: 80%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>Java 7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p></li><li><p>Java 8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p></li></ul><p>即使如此 Java 8 也是不建议把 HashMap 用在多线程中。</p><p>因为无法保证上一秒 put 的值，下一秒 get 的时候还是原值，所以线程安全还是无法保证。</p><hr><h5 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h5><p><font color=#008000>HashMap的默认初始化长度是多少？</font></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614031720500.png" alt=""></p><p>走，源码中找答案去</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614031914998.png" alt=""></p><p><strong>在 JDK1.8 的 236 行有 1&lt;&lt;4 就是 16</strong> （逻辑左移 4 位）</p><p>现在回过头来再看一下，重写 equals 方法的时候需要重写 hashCode 方法</p><ul><li>如果两个对象的 hash 值相同，那么这两个对象并不一定是相同；</li><li>如果两个对象的相同，那么这两个对象的 hash 值一定是相同；</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 HashMap：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;众所周知，HashMap 是一个用于存储 &lt;strong&gt;Key-Value&lt;/strong&gt; 键值对的集合，每一个键值对也叫做 &lt;strong&gt;Entry&lt;/strong&gt;。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是 HashMap 的主干。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画个重点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;&lt;strong&gt;Hash的公式 —&amp;gt;  index = HashCode（Key） &amp;amp; （Length - 1）&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap 的数据结构两种：数组 + 链表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组：查询速度快，可以根据索引查询；但插入和删除比较困难；&lt;/li&gt;
&lt;li&gt;链表：查询速度慢，需要遍历整个链表，但插入和删除操作比较容易;&lt;/li&gt;
&lt;li&gt;HashMap 是数组和链表组成的，数据结构中又叫“链表散列”;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="HashMap" scheme="https://codeyg.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--桶排序（Bucket Sort）</title>
    <link href="https://codeyg.top/2021/06/11/%E6%8E%92%E5%BA%8F--%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/11/%E6%8E%92%E5%BA%8F--%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-11T13:58:58.000Z</published>
    <updated>2021-07-18T14:57:39.608Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下桶排序：</strong></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-46-15.png" alt=""></p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>桶排序：</strong></p><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的<strong>桶子</strong>里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。就像是分不同的桶，在桶内再排序。</p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序数组中的最大值<strong>max</strong>、最小值<strong>min</strong>;</li><li>我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1;</li><li>遍历数组 arr，计算每个元素 arr[i] 放的桶;</li><li>每个桶各自排序;</li><li>遍历桶数组，把排序好的元素放进输出数组;</li></ol><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/firefox-2021-06-13T06-30-18.291Z.png" style="zoom: 80%;" /><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分别定义 arr 的最大值和最小值 (默认 arr 中首个元素为最小值)</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过遍历数组寻找到最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//桶数 (最大值-最小值)/数组长度+1</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据计算出来桶子个数来创建桶子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据桶子数值范围，将每个元素放入相应的桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新数组</span></span><br><span class="line">        ArrayList&lt;Integer&gt; newArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++) &#123;</span><br><span class="line">                newArr.add(bucketArr.get(i).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每个桶内："</span> + bucketArr.toString());</span><br><span class="line">        System.out.println(<span class="string">"新数组："</span> + newArr.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        bucketSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个桶内：[[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>], [<span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>], [<span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>], [<span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]]</span><br><span class="line">新数组：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>可以看出，在<strong>分桶</strong>和<strong>从桶</strong>依次输出的过程是稳定的。但是，由于我们在对每个桶进行排序时使用了其他算法，所以，桶排序的稳定性依赖于这一步。如果我们使用了快排，显然，算法是<strong>不稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><p>最差的情况就是数据过于集中从而导致都放在一个或者某几个桶中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下桶排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-07-18_22-46-15.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;桶排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的&lt;strong&gt;桶子&lt;/strong&gt;里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。就像是分不同的桶，在桶内再排序。&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="桶排序" scheme="https://codeyg.top/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
