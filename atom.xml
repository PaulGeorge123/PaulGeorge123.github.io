<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇航员不会飞</title>
  
  <subtitle>里面的人想出去，外面的人想进来</subtitle>
  <link href="https://codeyg.top/atom.xml" rel="self"/>
  
  <link href="https://codeyg.top/"/>
  <updated>2021-06-10T18:43:15.979Z</updated>
  <id>https://codeyg.top/</id>
  
  <author>
    <name>白日梦想家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【JVM系列】-- JVM内存结构</title>
    <link href="https://codeyg.top/2021/06/11/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://codeyg.top/2021/06/11/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-11T14:58:58.000Z</published>
    <updated>2021-06-10T18:43:15.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h4 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h4><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下JVM内存结构：</strong></p><hr><a id="more"></a><h3 id="先来看一张经典的JVM内存结构图"><a href="#先来看一张经典的JVM内存结构图" class="headerlink" title="先来看一张经典的JVM内存结构图"></a>先来看一张经典的JVM内存结构图</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:67%;" /><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储<strong>类信息、常量、静态变</strong>量等数据，是<strong>线程共享</strong>的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>线程与进程：</strong></p><ul><li>同步于线程：程序计数器、虚拟机栈、本地方法栈</li><li>同步于进程：方法区、堆</li></ul><hr><h4 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<strong>唯一一个不会出现Stack Overflow Error 的地方。</strong></p><h4 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a>JVM栈（JVM Stacks）</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><h4 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong></p><h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>1、对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>2、Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。</p><p><strong>控制参数</strong></p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JVM内存结构&quot;&gt;&lt;a href=&quot;#JVM内存结构&quot; class=&quot;headerlink&quot; title=&quot;JVM内存结构&quot;&gt;&lt;/a&gt;JVM内存结构&lt;/h2&gt;&lt;h4 id=&quot;什么是JVM？&quot;&gt;&lt;a href=&quot;#什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM？&quot;&gt;&lt;/a&gt;什么是JVM？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM内存结构：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- Java的类加载机制</title>
    <link href="https://codeyg.top/2021/06/11/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/11/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-11T13:58:58.000Z</published>
    <updated>2021-06-10T18:43:14.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java的类加载机制"><a href="#Java的类加载机制" class="headerlink" title="Java的类加载机制"></a>Java的类加载机制</h2><h4 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h4><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下Java的类加载机制：</strong></p><hr><a id="more"></a><h4 id="1、什么是类的加载"><a href="#1、什么是类的加载" class="headerlink" title="1、什么是类的加载"></a>1、什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h4 id="2、类的生命周期"><a href="#2、类的生命周期" class="headerlink" title="2、类的生命周期"></a>2、类的生命周期</h4><p>加载的过程包括了<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。</p><p><strong>加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段获取类的二进制字节流的动作是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>验证：确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>准备：为类的 <code>静态变量分</code>配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量是指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p><strong>结束生命周期</strong></p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 <code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h4 id="3、双亲委派模型"><a href="#3、双亲委派模型" class="headerlink" title="3、双亲委派模型"></a>3、双亲委派模型</h4><p><strong>定义</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java的类加载机制&quot;&gt;&lt;a href=&quot;#Java的类加载机制&quot; class=&quot;headerlink&quot; title=&quot;Java的类加载机制&quot;&gt;&lt;/a&gt;Java的类加载机制&lt;/h2&gt;&lt;h4 id=&quot;什么是JVM？&quot;&gt;&lt;a href=&quot;#什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM？&quot;&gt;&lt;/a&gt;什么是JVM？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下Java的类加载机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>排序总结</title>
    <link href="https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/"/>
    <id>https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-10T15:58:58.000Z</published>
    <updated>2021-06-09T18:03:00.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法总结（Sort-Algorithm）"><a href="#排序算法总结（Sort-Algorithm）" class="headerlink" title="排序算法总结（Sort Algorithm）"></a>排序算法总结（Sort Algorithm）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重为排序做个总结：</strong></p><hr><h3 id="什么是排序算法？"><a href="#什么是排序算法？" class="headerlink" title="什么是排序算法？"></a>什么是排序算法？</h3><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p><a id="more"></a><h4 id="1、算法分类"><a href="#1、算法分类" class="headerlink" title="1、算法分类"></a>1、算法分类</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_conclusion.jpg" style="zoom:67%;" /><h4 id="2、算法总结"><a href="#2、算法总结" class="headerlink" title="2、算法总结"></a>2、算法总结</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_all_photo.png" style="zoom: 67%;" /><h4 id="3、解释说明"><a href="#3、解释说明" class="headerlink" title="3、解释说明"></a>3、解释说明</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面 （相等不交换位置）；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面（相等交换位置）；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间；</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小；</li></ul><h4 id="4、比较和非比较的区别"><a href="#4、比较和非比较的区别" class="headerlink" title="4、比较和非比较的区别"></a>4、比较和非比较的区别</h4><p><font color=#FF8C00>快速排序、归并排序、堆排序、冒泡排序  </font>等属于 <font color=#008000>比较排序</font></p><p><font color=#FF8C00>计数排序、基数排序、桶排序 </font> 则属于  <font color=#FF0000>非比较排序</font></p><p>比较排序：在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置</p><p>非比较排序：非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置</p><h4 id="5、常见的时间复杂度"><a href="#5、常见的时间复杂度" class="headerlink" title="5、常见的时间复杂度"></a>5、常见的时间复杂度</h4><ul><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3)</li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1691302-20191103200642835-1582365806.png" alt=""></p><p>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述<strong>时间复杂度不断增大，算法的执行效率越低</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;排序算法总结（Sort-Algorithm）&quot;&gt;&lt;a href=&quot;#排序算法总结（Sort-Algorithm）&quot; class=&quot;headerlink&quot; title=&quot;排序算法总结（Sort Algorithm）&quot;&gt;&lt;/a&gt;排序算法总结（Sort Algorithm）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重为排序做个总结：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;什么是排序算法？&quot;&gt;&lt;a href=&quot;#什么是排序算法？&quot; class=&quot;headerlink&quot; title=&quot;什么是排序算法？&quot;&gt;&lt;/a&gt;什么是排序算法？&lt;/h3&gt;&lt;p&gt;排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="排序总结" scheme="https://codeyg.top/tags/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--归并排序</title>
    <link href="https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-10T13:58:58.000Z</published>
    <updated>2021-06-10T17:53:16.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下归并排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>归并排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(n)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于<strong>快速排序</strong>，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" target="_blank" rel="noopener">归并排序动图演示</a></p><p><a href="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" target="_blank" rel="noopener">递归法动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p><strong>归并排序是用分治思想</strong></p><ol><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ol><p><strong>递归法</strong></p><ul><li>① 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li><li>② 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li><li>③ 重复步骤②，直到所有元素排序完毕</li></ul><p><strong>总结：</strong>先分组，再归并</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1557906108-5066-20161218163120151-452283750.png" style="zoom: 33%;" /><hr><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp =<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        internalMergeSort(arr, temp, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalMergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左子数组</span></span><br><span class="line">            internalMergeSort(arr, temp, left, middle);</span><br><span class="line">            <span class="comment">//右子数组</span></span><br><span class="line">            internalMergeSort(arr, temp, middle+<span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">//合并两个子数组</span></span><br><span class="line">            mergeSortedArray(arr, temp, left, middle, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortedArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=middle+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=middle &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;=middle)&#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( j&lt;=right)&#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把数据复制回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            arr[left+i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        merge_sort(array);</span><br><span class="line">        <span class="comment">//打印快速排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>因为我们在遇到相等的数据的时候必然是按顺序“复刻”到辅助数组temp[]上的，所以，归并排序同样是<strong>稳定</strong>算法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;归并排序（Merge-Sort）&quot;&gt;&lt;a href=&quot;#归并排序（Merge-Sort）&quot; class=&quot;headerlink&quot; title=&quot;归并排序（Merge Sort）&quot;&gt;&lt;/a&gt;归并排序（Merge Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于&lt;strong&gt;快速排序&lt;/strong&gt;，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;归并排序动图演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递归法动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="归并排序" scheme="https://codeyg.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--堆排序</title>
    <link href="https://codeyg.top/2021/06/09/%E6%8E%92%E5%BA%8F--%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/09/%E6%8E%92%E5%BA%8F--%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-09T13:58:58.000Z</published>
    <updated>2021-06-09T18:06:41.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下堆排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>堆排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code><ul><li>初始化建堆：<code>O(n)</code></li><li>排序重建堆: <code>nlog(n)</code></li></ul></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示，每一个结点对应数组中的一个元素。利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" target="_blank" rel="noopener">堆排序动图演示1</a></p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" target="_blank" rel="noopener">堆排序动图演示2</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点；</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆；</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变；</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h5><p>堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树</p><h5 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h5><ul><li>是一棵完全二叉树</li><li>每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</li></ul><h5 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h5><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">         *  beginIndex = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">         * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(<span class="number">0</span>, i);</span><br><span class="line">            maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> ri = li + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line">        <span class="keyword">int</span> cMax = li;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (li &gt; len) &#123;</span><br><span class="line">            <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">        <span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) &#123;</span><br><span class="line">            cMax = ri;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">            <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">            swap(cMax, index);</span><br><span class="line">            <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">            maxHeapify(cMax, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试用例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> HeapSort(arr).sort();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>堆排序存在大量的筛选和移动过程，属于<strong>不稳定</strong>的排序算法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><p>堆排序操作过程中其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;堆排序（Heap-Sort）&quot;&gt;&lt;a href=&quot;#堆排序（Heap-Sort）&quot; class=&quot;headerlink&quot; title=&quot;堆排序（Heap Sort）&quot;&gt;&lt;/a&gt;堆排序（Heap Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下堆排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;堆排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;初始化建堆：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;排序重建堆: &lt;code&gt;nlog(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示，每一个结点对应数组中的一个元素。利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;堆排序动图演示1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;堆排序动图演示2&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="选择排序" scheme="https://codeyg.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--选择排序</title>
    <link href="https://codeyg.top/2021/06/08/%E6%8E%92%E5%BA%8F--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/08/%E6%8E%92%E5%BA%8F--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-08T13:58:58.000Z</published>
    <updated>2021-06-08T18:12:12.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下选择排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>选择排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" target="_blank" rel="noopener">选择排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</p></li><li><p>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p><p><strong>基本思路：</strong></p></li></ol><ul><li>外循环：循环每个位置（其实就是选择了这个位置，然后用内循环去选择一个合适的数，放到这个位置）；</li><li>内循环：在无序元素中选择一个合适的数；</li><li>把第二步选中的数据放到第一步选中的位置上就可以了；</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序法，外层循环控制所需找到最小值的次数，内层循环来寻找目标值后面比目标值小的元素，进行下标更新</span></span><br><span class="line"><span class="comment"> * 每次找到后，都将其放倒前面，与冒泡排序恰恰相反。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//外层循环控制所需找到最小值的次数,挖坑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">//内层循环来寻找目标值后面比目标值小的元素，准备填坑</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//下标更新</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[index]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填坑</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>用数组实现的选择排序是<strong>不稳定</strong>的，用链表实现的选择排序是<strong>稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是<strong>优于冒泡排序</strong>的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;选择排序（Selection-Sort）&quot;&gt;&lt;a href=&quot;#选择排序（Selection-Sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序（Selection Sort）&quot;&gt;&lt;/a&gt;选择排序（Selection Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下选择排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;选择排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="选择排序" scheme="https://codeyg.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--希尔排序</title>
    <link href="https://codeyg.top/2021/06/07/%E6%8E%92%E5%BA%8F--%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/07/%E6%8E%92%E5%BA%8F--%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-07T13:58:58.000Z</published>
    <updated>2021-06-08T18:12:20.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下希尔排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>希尔排序：</strong></p><ul><li>时间复杂度：当增量（<strong>gap</strong> ）为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为<code>O(N²)</code>，而Hibbard增量的希尔排序的时间复杂度为<code>O(N3/2)</code>。</li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>插入排序是效率低下是因为其移动元素每次只能移动一位，当排序元素的规模较大时，需要将元素一位一位地从一端移动到另一端。希尔排序正是基于此原理来优化、提高插入排序的效率。通过指定步长step，将原数组分为step个互相独立子数组，然后通过插入排序对这些子数组分别进行排序(即分组排序)，这时我们称其为<strong>step有序数组</strong>。当step最终为<strong>1</strong>做最后一次step有序时，就是我们平常所熟悉的插入排序了，由于该数组已经多次被较大的step进行分组排序了，此时只需要较少次数的元素移动就可以实现整个数组全局有序。</p><p><a href="https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp" target="_blank" rel="noopener">希尔排序动图演示</a></p><a id="more"></a><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/11ba6646605ae3996ede9ab2f0f6ae9b.jpg" style="zoom: 67%;" /><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>按照一定的<strong>增量 gap</strong> ，先将待排序表分割成若干个特殊子表，首个gap取值为数组长度一半（地板除）；</li><li>对于各个子表，进行<strong>直接插入排序</strong>；</li><li>随后 <strong>缩小 gap</strong> ，重复上述过程，直到 gap = 1 为止。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//增量每次都/2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//得到分组下标对应的值</span></span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="comment">//临时变量，用于保存步长下标值</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// j - step 就是代表与它同组隔壁的元素,如果分组前面大于后面的</span></span><br><span class="line">                <span class="keyword">while</span> (j - step &gt;= <span class="number">0</span> &amp;&amp; arr[j - step] &gt; temp) &#123;</span><br><span class="line">                    <span class="comment">//将分组前面的值赋给后面的</span></span><br><span class="line">                    arr[j] = arr[j - step];</span><br><span class="line">                    <span class="comment">//下标减去步长，来到分组前面的下标</span></span><br><span class="line">                    j -= step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果分组之间有过交换，那么将分组后面的值发给分组前面的值</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        shellSort(array);</span><br><span class="line">        <span class="comment">//打印快速排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，</p><p>但在不同的插入排序过程中，<strong>相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱</strong>。</p><p>所以 希尔shell排序是<strong>不稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有<strong>快速排序</strong>O(n㏒n)快；</p></li><li><p>Shell排序在大量数据面前不是一个好的算法，但是，中小型规模的数据完全可以使用它；</p></li><li><p>希尔排序只是适用于<strong>线性表为顺序存储</strong>的i情况，<strong>不适用于链表</strong>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;希尔排序（Shell-Sort）&quot;&gt;&lt;a href=&quot;#希尔排序（Shell-Sort）&quot; class=&quot;headerlink&quot; title=&quot;希尔排序（Shell Sort）&quot;&gt;&lt;/a&gt;希尔排序（Shell Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下希尔排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;希尔排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：当增量（&lt;strong&gt;gap&lt;/strong&gt; ）为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为&lt;code&gt;O(N²)&lt;/code&gt;，而Hibbard增量的希尔排序的时间复杂度为&lt;code&gt;O(N3/2)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;插入排序是效率低下是因为其移动元素每次只能移动一位，当排序元素的规模较大时，需要将元素一位一位地从一端移动到另一端。希尔排序正是基于此原理来优化、提高插入排序的效率。通过指定步长step，将原数组分为step个互相独立子数组，然后通过插入排序对这些子数组分别进行排序(即分组排序)，这时我们称其为&lt;strong&gt;step有序数组&lt;/strong&gt;。当step最终为&lt;strong&gt;1&lt;/strong&gt;做最后一次step有序时，就是我们平常所熟悉的插入排序了，由于该数组已经多次被较大的step进行分组排序了，此时只需要较少次数的元素移动就可以实现整个数组全局有序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;希尔排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="插入排序" scheme="https://codeyg.top/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--插入排序</title>
    <link href="https://codeyg.top/2021/06/06/%E6%8E%92%E5%BA%8F--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/06/%E6%8E%92%E5%BA%8F--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-06T13:58:58.000Z</published>
    <updated>2021-06-08T18:12:53.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序（Insert-Sort）"><a href="#插入排序（Insert-Sort）" class="headerlink" title="插入排序（Insert Sort）"></a>插入排序（Insert Sort）</h2><blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下插入排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>插入排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即：每次确定要排序的元素并将其与之前<strong>已排好序的元素</strong>进行插入。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" target="_blank" rel="noopener">插入排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>把待排序的数组分成<strong>已排序</strong>和<strong>未排序</strong>两部分，初始的时候把第一个元素认为是已排好序的；</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置；</li><li>重复上述过程直到最后一个元素被插入有序子数组中。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序:外层循环控制每次索要插入的元素（定义一个待插入的数），再定义一个待插入数的前一个数的下标，内层循环比较插入数字</span></span><br><span class="line"><span class="comment"> * 与前一个数字之间的大小比较，如果待插入数的前一个数大于本次索要插入的元素，那么将前一个元素的值赋值给本次插入值的位置，</span></span><br><span class="line"><span class="comment"> * 继续向前比较，知道找到前面的元素之都比插入元素值小的位置，在跳出内层循环，执行外层循环。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">            <span class="comment">//找到待插入数的前一个数的下标</span></span><br><span class="line">            <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; arr[insertIndex] &gt; insertVal) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是<strong>稳定的</strong>排序方法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>插入排序由于O( n2 )的复杂度，在<strong>数组较大</strong>的时候不适用。</p><p>但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;插入排序（Insert-Sort）&quot;&gt;&lt;a href=&quot;#插入排序（Insert-Sort）&quot; class=&quot;headerlink&quot; title=&quot;插入排序（Insert Sort）&quot;&gt;&lt;/a&gt;插入排序（Insert Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下插入排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;插入排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即：每次确定要排序的元素并将其与之前&lt;strong&gt;已排好序的元素&lt;/strong&gt;进行插入。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插入排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="插入排序" scheme="https://codeyg.top/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--快速排序</title>
    <link href="https://codeyg.top/2021/06/05/%E6%8E%92%E5%BA%8F--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/05/%E6%8E%92%E5%BA%8F--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-05T13:58:58.000Z</published>
    <updated>2021-06-08T18:12:47.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><blockquote><p>每天一篇排序算法（Java版）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下快速排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>快速排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(logn)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p><strong>快排</strong>的性能在所有排序算法里面是<strong>最好</strong>的排序算法。数据规模越大快速排序的性能越优。快排在极端情况下会退化成 <code>O(n2)</code> 的算法，因此假如在提前得知处理数据可能会出现极端情况的前提下，可以选择使用较为稳定的<strong>归并排序</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" target="_blank" rel="noopener">快速排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>快排运用了二分的思想:</p><ul><li>首先从数列中挑出一个元素基准<code>pivot</code>；</li><li>定义左右两端指针。先从右往左进行扫描，如果 R[right] &lt; pivot，将R[right]移动至left所在位置，从左往右进行扫描，否则right前移；如果 R[left] &gt; pivot，将R[left]移动到right所在位置上，否则left后移。左右端指针在排序过程中从数组的两端往中间进行靠近；</li><li>直到 right == left （重合），该基准<code>pivot</code>就处于数列的中间位置，这个称为分区（partition）操作；</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。直到划分的区间最后长度仅为1。</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</span></span><br><span class="line"><span class="comment"> * 从数列中挑出一个元素，称为 “基准”（pivot）；</span></span><br><span class="line"><span class="comment"> * 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</span></span><br><span class="line"><span class="comment"> * 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果左边指针小于右边指针</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * i:表示左边指针</span></span><br><span class="line"><span class="comment">             * j:表示右边指针</span></span><br><span class="line"><span class="comment">             * pivot:表示基准值（一般取分区的首个值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> i = left, j = right, pivot = arr[left];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="comment">// 从右向左找第一个小于x的数，如果右侧指针所指向的值大于基准pivot，指针前移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果右侧指针所指向的值小于基准pivot，交换右侧指针所指向的值与左侧指针所指向的值，并且左侧指针后移</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    arr[i++] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从左向右找第一个大于等于x的数，如果左侧指针所指向的值小于基准pivot，指针后移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; pivot) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左侧指针所指向的值大于基准pivot，交换左侧指针所指向的值与右侧指针所指向的值，并且右侧指针前移</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    arr[j--] = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = pivot;</span><br><span class="line">            <span class="comment">// 递归调用左子数组</span></span><br><span class="line">            quick_sort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归调用右子数组</span></span><br><span class="line">            quick_sort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        quick_sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//打印快速排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>快速排序并<strong>不是稳定的</strong>。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>快速排序在大多数情况下都是适用的，尤其在<strong>数据量大</strong>的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>最差情况：O(n2)</li></ul><p>最差情况是，每次我们在划分时，所取的基准总是数组中最小的，因此我们总共会进行n-1次划分，且在第i次划分时，区间长度为：n-i+1 ,需要进行n-i比较。</p><p>故：</p><p><img src="https://www.zhihu.com/equation?tex=C_%7Bmax%7D%3D%5Csum_%7Bi+%3D1%7D%5E%7Bn-1%7D%7Bn-i%7D%3D%5Cfrac%7Bn%28n-1%29%7D%7B2%7D%3DO%28n%5E%7B2%7D%29" alt="[公式]"></p><ul><li>最好情况：O(nlog2n)</li></ul><p>最好的情况是，每次所取的基准就是该数组的中点，因此一共需要进行n次划分，对于 长度为n的划分空间，需要进行n-1次比较。剩下的两个无序子区间需要进行2C(n/2)的比较次数。设n=2k</p><p>故：</p><p><img src="https://www.zhihu.com/equation?tex=C%28n%29%5Cleq+n%2B2C%28%5Cfrac%7Bn%7D%7B2%7D%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleq+n%2B2%28%5Cfrac%7Bn%7D%7B2%7D%2B2C%28%5Cfrac%7Bn%7D%7B2%5E%7B2%7D%7D%29%29%3D2n%2B4C%28%5Cfrac%7Bn%7D%7B2%5E%7B2%7D%7D%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleq+kn%2BnC%281%29+%3D+%5Cleq+n%5C%3Blog_%7B2%7Dn%5C%3B%2B%5C%3BnC%281%29%3DO%28nlog_%7B2%7Dn%29" alt="[公式]"></p><ul><li>平均情况：</li></ul><p>随机进行切割，最好算出复杂度还是O(nlog2n)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;快速排序（Quick-Sort）&quot;&gt;&lt;a href=&quot;#快速排序（Quick-Sort）&quot; class=&quot;headerlink&quot; title=&quot;快速排序（Quick Sort）&quot;&gt;&lt;/a&gt;快速排序（Quick Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(logn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快排&lt;/strong&gt;的性能在所有排序算法里面是&lt;strong&gt;最好&lt;/strong&gt;的排序算法。数据规模越大快速排序的性能越优。快排在极端情况下会退化成 &lt;code&gt;O(n2)&lt;/code&gt; 的算法，因此假如在提前得知处理数据可能会出现极端情况的前提下，可以选择使用较为稳定的&lt;strong&gt;归并排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="交换排序" scheme="https://codeyg.top/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--冒泡排序</title>
    <link href="https://codeyg.top/2021/06/04/%E6%8E%92%E5%BA%8F--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/04/%E6%8E%92%E5%BA%8F--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-04T14:58:58.000Z</published>
    <updated>2021-06-08T18:12:32.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><blockquote><p>每天一篇排序算法（Java版）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下冒泡排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>快速排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。可以理解为<strong>每次都能够将最大的数字找到</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" target="_blank" rel="noopener">冒泡排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><p>第一种，也是最为常见的一种（双重循环）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外层循环来控制所需找到最大值的次数，内层循环用来比较相邻的两个值之间的大小，若前面的值大于后面的值，则两个元素之间进行位置交换。</span></span><br><span class="line"><span class="comment"> * 每次外层循环所得到的都是最大元素的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        System.out.println("startTime = " + startTime);</span></span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        System.out.println("endTime = " + endTime);</span></span><br><span class="line">        System.out.println(<span class="string">"time = "</span> + (endTime-startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是<strong>稳定排序</strong>。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>冒泡排序思路简单，代码也简单，特别<strong>适合小数据</strong>的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p><hr><blockquote><p>第二种，对于外层循环的一种优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time2 = "</span> + (endTime - startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">36</span>, <span class="number">73</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">85</span>, <span class="number">94</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在内层循环添加一个flag默认为true（也就是默认本次不会发生元素交换），当在外层循环某次执行后，数组元素已经有序，但是外层还有循环次数的时候，flag可以跳出外层循环，缩短排序时间。</p><hr><blockquote><p>第三种，基于第二种优化方式对于内层循环的次数优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time3 = "</span> + (endTime-startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在外层循环添加一个标记用来–记录最后一次交换的位置，基于对内层循环的优化基础，外层循环每次确定无序数列的边界位置，这样可以减少在无需情况下内层循环的时间。</p><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><font color=#FF8C00>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O(n^2 )</font></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;冒泡排序（Bubble-Sort）&quot;&gt;&lt;a href=&quot;#冒泡排序（Bubble-Sort）&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序（Bubble Sort）&quot;&gt;&lt;/a&gt;冒泡排序（Bubble Sort）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。可以理解为&lt;strong&gt;每次都能够将最大的数字找到&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冒泡排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="交换排序" scheme="https://codeyg.top/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题（Java基础）</title>
    <link href="https://codeyg.top/2021/05/29/%E9%9D%A2%E8%AF%95%E9%A2%98ing/"/>
    <id>https://codeyg.top/2021/05/29/%E9%9D%A2%E8%AF%95%E9%A2%98ing/</id>
    <published>2021-05-29T03:58:58.000Z</published>
    <updated>2021-06-08T18:45:28.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><p><strong>1. JDK 和 JRE 有什么区别？</strong></p><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p><hr><p><strong>2. == 和 equals 的区别是什么？</strong></p><a id="more"></a><p><strong>== 解读</strong></p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p></blockquote><p><strong>equals 解读</strong></p><p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><hr><p><strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong></p><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p><hr><p><strong>4. final 在 java 中有什么作用？</strong></p><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><hr><p><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong></p><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><hr><p><strong>6. String 属于基础的数据类型吗？</strong></p><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><hr><p><strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong></p><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><hr><p><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></p><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><hr><p><strong>9. 如何将字符串反转？</strong></p><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.println(stringBuffer.reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.println(stringBuilder.reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><hr><p><strong>10. String 类的常用方法都有那些？</strong></p><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><hr><p><strong>11. 普通类和抽象类有哪些区别？</strong></p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><hr><p><strong>12. 抽象类能使用 final 修饰吗？</strong></p><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><hr><p><strong>13. 接口和抽象类有什么区别？</strong></p><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><hr><p><strong>14. java 中 IO 流分为几种？</strong></p><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><hr><p><strong>15. BIO、NIO、AIO 有什么区别？</strong></p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;h3 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. JDK 和 JRE 有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。&lt;/li&gt;
&lt;li&gt;JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;2. == 和 equals 的区别是什么？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="奋斗篇" scheme="https://codeyg.top/categories/%E5%A5%8B%E6%96%97%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="面试心得" scheme="https://codeyg.top/tags/%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://codeyg.top/2021/05/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://codeyg.top/2021/05/20/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-05-20T14:29:58.000Z</published>
    <updated>2021-06-11T16:43:49.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote><p>因为在日常工作中会遇到远程控制、部署程序的问题，总会使用到 linux 的相关命令，所以在此总结一些常用的 linux 命令。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/linux_logo1.png" style="zoom:67%;" /><a id="more"></a><h4 id="Linux-的系统目录结构"><a href="#Linux-的系统目录结构" class="headerlink" title="Linux 的系统目录结构"></a>Linux 的系统目录结构</h4><p><strong>如下图</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/d0c50-linux2bfile2bsystem2bhierarchy.jpg" style="zoom: 50%;" /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /bin        <span class="comment">## 二进制文件，系统常规命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /boot       <span class="comment">## 系统启动分区，系统启动时读取的文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /dev        <span class="comment">## 设备文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc        <span class="comment">## 大多数配置文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /home       <span class="comment">## 普通用户的家目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /lib        <span class="comment">## 32位函数库</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /lib64      <span class="comment">## 64位库</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /media      <span class="comment">## 手动临时挂载点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /mnt        <span class="comment">## 手动临时挂载点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /opt        <span class="comment">## 第三方软件安装位置</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /proc       <span class="comment">## 进程信息及硬件信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /root       <span class="comment">## 临时设备的默认挂载点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /sbin       <span class="comment">## 系统管理命令</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /srv        <span class="comment">## 数据</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /var        <span class="comment">## 数据</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /sys        <span class="comment">## 内核相关信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /tmp        <span class="comment">## 临时文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /usr        <span class="comment">## 用户相关设定</span></span></span><br></pre></td></tr></table></figure><hr><h4 id="命令的组成"><a href="#命令的组成" class="headerlink" title="命令的组成"></a>命令的组成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 示例：命令 参数名 参数值</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>【作用】：列出目录内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls</span><br><span class="line">[root@localhost ~]# ll</span><br></pre></td></tr></table></figure><hr><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>【作用】：显示树形目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tree</span><br></pre></td></tr></table></figure><blockquote><p>需要 yum install -y tree 安装</p></blockquote><hr><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><p>【作用】：更改当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd ..</span><br><span class="line">[root@localhost ~]# cd /</span><br></pre></td></tr></table></figure><hr><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>【作用】：在当前目录下创建下一级目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir test</span><br></pre></td></tr></table></figure><hr><h5 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h5><p>【作用】：仅可以删除空白目录（不可以删除包含内容的目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rmdir test</span><br></pre></td></tr></table></figure><hr><h5 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h5><p>【作用】：创建空白文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch test.txt</span><br></pre></td></tr></table></figure><hr><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>【作用】：删除文件</p><ul><li>删除文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm [文件名]（删除时会询问是否删除）</span><br><span class="line">[root@localhost ~]# rm -f [文件名]（强制删除）</span><br><span class="line">[root@localhost ~]# rm -v [文件名]（可视化删除）</span><br></pre></td></tr></table></figure></li></ul><ul><li>删除目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm -r [文件名]（删除时会询问是否删除）</span><br><span class="line">[root@localhost ~]# rm -rf [文件名]（强制删除，若目录不存在，此命令依旧可以执行，不报错）</span><br><span class="line">[root@localhost ~]# rm -rv [文件名]（可视化强制）</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>删除目录和文件时，先删除文件在删除目录</p></blockquote><hr><h5 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h5><p>【作用】：源文件始终不变，仅仅是对目标文件进行改变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp [源文件] [目标文件]</span><br></pre></td></tr></table></figure><hr><h5 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h5><p>【作用】：mv命令使源文件的状态发生改变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv [源文件] [目标文件]</span><br></pre></td></tr></table></figure><blockquote><p>若果目录存在，则会将原目录移动到目标目录下；如果目录不存在，则相当于移动并重命名</p></blockquote><hr><h5 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h5><p>【作用】：正序查看文件内容</p><ul><li>参数-A 查看所有内容，$代表每行的结尾</li><li>参数-n 显示行号</li></ul><p><strong>全文搜索</strong></p><p>从前往后搜索：可以输入 <code>/</code>（其中代表要搜索的内容），搜索到的内容会高亮度显示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat -An /etc/passwd</span><br></pre></td></tr></table></figure><hr><h5 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h5><p>【作用】：用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail [参数] [文件]</span><br></pre></td></tr></table></figure><hr><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>【作用】：更改当前目录权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod 777 [文件]</span><br></pre></td></tr></table></figure><hr><h5 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h5><p>【作用】：打包与解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar -zcvf 打包压缩后的文件名 要打包的文件</span><br><span class="line">[root@localhost ~]# tar -zxvf a.tar       //解包至当前目录</span><br></pre></td></tr></table></figure><hr><h5 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h5><p>【作用】：查看网络地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br></pre></td></tr></table></figure><hr><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>【作用】：查看进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef         //查看所有正在运行的进程</span><br></pre></td></tr></table></figure><hr><h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p>【作用】：结束进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill pid       //杀死该pid的进程 </span><br><span class="line">[root@localhost ~]# kill -9 pid    //强制杀死该进程</span><br></pre></td></tr></table></figure><hr><h5 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h5><p>【作用】：查看与此IP地址的连接情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ping www.baidu.com</span><br></pre></td></tr></table></figure><hr><h5 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h5><p>【作用】：快速清屏</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# clear</span><br></pre></td></tr></table></figure><hr><h5 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h5><h6 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl status firewalld</span><br></pre></td></tr></table></figure><h6 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl start firewalld</span><br></pre></td></tr></table></figure><h6 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl stop firewalld</span><br></pre></td></tr></table></figure><h6 id="设置对外开放访问的端口"><a href="#设置对外开放访问的端口" class="headerlink" title="设置对外开放访问的端口"></a>设置对外开放访问的端口</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --add-service=http –permanent </span><br><span class="line">[root@localhost ~]# firewall-cmd --add-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><h6 id="重新载入"><a href="#重新载入" class="headerlink" title="重新载入"></a>重新载入</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd –reload</span><br></pre></td></tr></table></figure><h6 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure><h6 id="查看已开放的端口号"><a href="#查看已开放的端口号" class="headerlink" title="查看已开放的端口号"></a>查看已开放的端口号</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firewall-cmd --list-all</span><br></pre></td></tr></table></figure><hr><h5 id="vim-编译"><a href="#vim-编译" class="headerlink" title="vim 编译"></a>vim 编译</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> number    --vim显示行号 （一次性）</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux常用命令&quot;&gt;&lt;a href=&quot;#Linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;Linux常用命令&quot;&gt;&lt;/a&gt;Linux常用命令&lt;/h2&gt;&lt;h4 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;因为在日常工作中会遇到远程控制、部署程序的问题，总会使用到 linux 的相关命令，所以在此总结一些常用的 linux 命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/linux_logo1.png&quot; style=&quot;zoom:67%;&quot; /&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://codeyg.top/categories/Linux/"/>
    
    
    <category term="linux" scheme="https://codeyg.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--单例模式</title>
    <link href="https://codeyg.top/2021/05/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://codeyg.top/2021/05/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-12T03:58:58.000Z</published>
    <updated>2021-06-08T18:13:11.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote><p>每天一篇重点设计模式（Java版）</p></blockquote><p><strong>总体来说设计模式分为三大类：</strong></p><p><strong>创建型模式（5种）</strong>：<font color=#008000>工厂方法模式</font>、<font color=#008000>抽象工厂模式</font>、<font color=#008000>单例模式</font>、建造者模式、原型模式</p><p><strong>结构型模式（7种）</strong>：<font color=#0000FF>适配器模式</font>、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p><p><strong>行为型模式（17种）</strong>：<font color=#FF8C00>观察者模式</font>、策略模式、模板方法模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p><strong>本篇着重介绍一下单例模式：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>设计模式的六大原则</strong></p><p>开闭原则、单一原则、 里式替换、依赖倒置、接口隔离、迪米特法则</p><hr><a id="more"></a><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p> <strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><hr><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 五种单例模式：</span></span><br><span class="line"><span class="comment"> * 1、懒汉式</span></span><br><span class="line"><span class="comment"> * 2、饿汉式</span></span><br><span class="line"><span class="comment"> * 3、双重检查模式 (DCL)</span></span><br><span class="line"><span class="comment"> * 4、静态内部类</span></span><br><span class="line"><span class="comment"> * 5、枚举类</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h3><h4 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h4><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。</p><p><strong>步骤 1</strong></p><p>创建一个 Singleton 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"懒汉式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2</strong></p><p>从 singleton 类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 懒汉式</span></span><br><span class="line">     Singleton1 instance1 = Singleton1.getInstance();</span><br><span class="line">    System.out.println(instance1);   </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2、饿汉式"><a href="#2、饿汉式" class="headerlink" title="2、饿汉式"></a>2、饿汉式</h4><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>描述：</strong>这种方式比较常用，但容易产生垃圾对象。<br> 优点：没有加锁，执行效率会提高。<br> 缺点：类加载时就初始化，浪费内存。<br> 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p><p><strong>步骤 1</strong></p><p>创建一个 Singleton 2类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"饿汉式"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2</strong></p><p>从 singleton2 类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 饿汉式</span></span><br><span class="line">       Singleton2 instance2 = Singleton2.getInstance();</span><br><span class="line">       System.out.println(instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3、双检锁-双重校验锁（DCL）"><a href="#3、双检锁-双重校验锁（DCL）" class="headerlink" title="3、双检锁/双重校验锁（DCL）"></a>3、双检锁/双重校验锁（DCL）</h4><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><p><strong>描述：</strong>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><p><strong>步骤 1</strong></p><p>创建一个 Singleton3 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"双重检查模式 (DCL)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2</strong></p><p>从 singleton3 类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 双重检查模式 (DCL)</span></span><br><span class="line">        Singleton3 instance3 = Singleton3.getInstance();</span><br><span class="line">        System.out.println(instance3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4、静态内部类"><a href="#4、静态内部类" class="headerlink" title="4、静态内部类"></a>4、静态内部类</h4><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>一般</p><p><strong>步骤 1</strong></p><p>创建一个 Singleton4 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态内部类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 INSTANCE = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2</strong></p><p>从 singleton4 类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类</span></span><br><span class="line">        Singleton4 instance4 = Singleton4.getInstance();</span><br><span class="line">        System.out.println(instance4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h4><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><p><strong>步骤 1</strong></p><p>创建一个 Singleton5 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton5 &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE(<span class="string">"枚举类"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    Singleton5(String msg) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        System.out.println(getMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherSomeThing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤 2</strong></p><p>从 singleton5类获取唯一的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 枚举</span></span><br><span class="line">        Singleton5 instance5 = Singleton5.INSTANCE;</span><br><span class="line">        System.out.println(instance5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;每天一篇重点设计模式（Java版）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;总体来说设计模式分为三大类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建型模式（5种）&lt;/strong&gt;：&lt;font color=#008000&gt;工厂方法模式&lt;/font&gt;、&lt;font color=#008000&gt;抽象工厂模式&lt;/font&gt;、&lt;font color=#008000&gt;单例模式&lt;/font&gt;、建造者模式、原型模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构型模式（7种）&lt;/strong&gt;：&lt;font color=#0000FF&gt;适配器模式&lt;/font&gt;、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行为型模式（17种）&lt;/strong&gt;：&lt;font color=#FF8C00&gt;观察者模式&lt;/font&gt;、策略模式、模板方法模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下单例模式：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;设计模式的六大原则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开闭原则、单一原则、 里式替换、依赖倒置、接口隔离、迪米特法则&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://codeyg.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="创建者模式" scheme="https://codeyg.top/tags/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="https://codeyg.top/2021/04/18/Nginx/"/>
    <id>https://codeyg.top/2021/04/18/Nginx/</id>
    <published>2021-04-18T14:18:30.000Z</published>
    <updated>2021-06-06T18:18:03.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/nginx_logo.jpg" style="zoom: 50%;" /><h4 id="初识Nginx"><a href="#初识Nginx" class="headerlink" title="初识Nginx:"></a>初识Nginx:</h4><p><strong>作用</strong></p><blockquote><p>简单来说就是真实的服务器不能直接被外部网络访问,想要访问必须通过代理</p></blockquote><h4 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -v</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="Nginx的启动、停止与重启"><a href="#Nginx的启动、停止与重启" class="headerlink" title="Nginx的启动、停止与重启"></a>Nginx的启动、停止与重启</h4><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><strong>启动代码格式：nginx安装目录地址 -c nginx配置文件地址</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx</span></span><br></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><h4 id="关闭-Nginx"><a href="#关闭-Nginx" class="headerlink" title="关闭 Nginx"></a>关闭 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost sbin]<span class="comment"># ./nginx -s stop</span></span><br></pre></td></tr></table></figure><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p><strong>nginx的停止有三种方式</strong></p><h4 id="从容停止"><a href="#从容停止" class="headerlink" title="从容停止"></a>从容停止</h4><p><strong>1、查看进程号</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p><strong>2、杀死进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -QUIT 29321</span><br></pre></td></tr></table></figure><h4 id="快速停止"><a href="#快速停止" class="headerlink" title="快速停止"></a>快速停止</h4><p><strong>1、查看进程号</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef|grep nginx</span><br></pre></td></tr></table></figure><p><strong>2、杀死进程</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -TERM 29321 </span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# kill -INT 29321</span><br></pre></td></tr></table></figure><h4 id="强制停止"><a href="#强制停止" class="headerlink" title="强制停止"></a>强制停止</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pkill -9 nginx</span><br></pre></td></tr></table></figure><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><p><strong>1、验证nginx配置文件是否正确</strong></p><p><strong>进入nginx安装目录sbin下，输入命令./nginx -t</strong></p><p><strong>2、重启Nginx服务</strong></p><p><strong>进入nginx可执行目录sbin下，输入命令  <code>./nginx -s reload</code>  即可</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ./nginx -s reload</span></span><br></pre></td></tr></table></figure><hr><h4 id="Nginx-文件结构"><a href="#Nginx-文件结构" class="headerlink" title="Nginx 文件结构"></a>Nginx 文件结构</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;         <span class="comment">#events块</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">http</span>      <span class="comment">#http块</span></span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    <span class="attribute">server</span>        <span class="comment">#server块</span></span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        <span class="attribute">location</span> [PATTERN]   <span class="comment">#location块</span></span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>1、<strong>全局块</strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>2、<strong>events块</strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>3、<strong>http块</strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>4、<strong>server块</strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>5、<strong>location块</strong>：配置请求的路由，以及各种页面的处理情况。</li></ul><hr><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########### 每个指令必须有分号结束。#################</span></span><br><span class="line"><span class="comment">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span></span><br><span class="line"><span class="comment">#worker_processes 2;  #允许生成的进程数，默认为1</span></span><br><span class="line"><span class="comment">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="attribute">error_log</span> log/error.log <span class="literal">debug</span>;  <span class="comment">#制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">accept_mutex</span> <span class="literal">on</span>;   <span class="comment">#设置网路连接序列化，防止惊群现象发生，默认为on</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;  <span class="comment">#设置一个进程是否同时接受多个网络连接，默认为off</span></span><br><span class="line">    <span class="comment">#use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;    <span class="comment">#最大连接数，默认为512</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;   <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream; <span class="comment">#默认文件类型，默认为text/plain</span></span><br><span class="line">    <span class="comment">#access_log off; #取消服务日志    </span></span><br><span class="line">    <span class="attribute">log_format</span> myFormat <span class="string">'<span class="variable">$remote_addr</span>–<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] <span class="variable">$request</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> <span class="variable">$http_referer</span> <span class="variable">$http_user_agent</span> <span class="variable">$http_x_forwarded_for</span>'</span>; <span class="comment">#自定义格式</span></span><br><span class="line">    <span class="attribute">access_log</span> log/access.log myFormat;  <span class="comment">#combined为日志格式的默认值</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;   <span class="comment">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span></span><br><span class="line">    <span class="attribute">sendfile_max_chunk</span> <span class="number">100k</span>;  <span class="comment">#每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;  <span class="comment">#连接超时时间，默认为75s，可以在http，server，location块。</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> mysvr &#123;   </span><br><span class="line">      <span class="attribute">server</span> <span class="number">127.0.0.1:7878</span>;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.10.121:3333</span> backup;  <span class="comment">#热备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> https://www.baidu.com; <span class="comment">#错误页</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">keepalive_requests</span> <span class="number">120</span>; <span class="comment">#单连接请求上限次数。</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">4545</span>;   <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">127.0.0.1</span>;   <span class="comment">#监听地址       </span></span><br><span class="line">        <span class="attribute">location</span>  ~*^.+$ &#123;       <span class="comment">#请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span></span><br><span class="line">           <span class="comment">#root path;  #根目录</span></span><br><span class="line">           <span class="comment">#index vv.txt;  #设置默认页</span></span><br><span class="line">           <span class="attribute">proxy_pass</span>  http://mysvr;  <span class="comment">#请求转向mysvr 定义的服务器列表</span></span><br><span class="line">           <span class="attribute">deny</span> <span class="number">127.0.0.1</span>;  <span class="comment">#拒绝的ip</span></span><br><span class="line">           <span class="attribute">allow</span> <span class="number">172.18.5.54</span>; <span class="comment">#允许的ip           </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是nginx的基本配置，需要注意的有以下几点：</p><p>1、几个常见配置项：</p><ul><li>1.$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</li><li>2.$remote_user ：用来记录客户端用户名称；</li><li>3.$time_local ： 用来记录访问时间与时区；</li><li>4.$request ： 用来记录请求的url与http协议；</li><li>5.$status ： 用来记录请求状态；成功是200；</li><li>6.$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</li><li>7.$http_referer ：用来记录从那个页面链接访问过来的；</li><li>8.$http_user_agent ：记录客户端浏览器的相关信息；</li></ul><p>2、惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能</p><p>3、<font color=#FF8C00>每个指令必须有分号结束</font></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h2&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/nginx_logo.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;h4 id=&quot;初识Nginx&quot;&gt;&lt;a href=&quot;#初识Nginx&quot; class=&quot;headerlink&quot; title=&quot;初识Nginx:&quot;&gt;&lt;/a&gt;初识Nginx:&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单来说就是真实的服务器不能直接被外部网络访问,想要访问必须通过代理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;查看版本号&quot;&gt;&lt;a href=&quot;#查看版本号&quot; class=&quot;headerlink&quot; title=&quot;查看版本号&quot;&gt;&lt;/a&gt;查看版本号&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost sbin]&lt;span class=&quot;comment&quot;&gt;# ./nginx -v&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="服务器" scheme="https://codeyg.top/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="反向代理" scheme="https://codeyg.top/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://codeyg.top/2021/04/05/RabbitMQ/"/>
    <id>https://codeyg.top/2021/04/05/RabbitMQ/</id>
    <published>2021-04-05T14:29:58.000Z</published>
    <updated>2021-06-06T18:29:20.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/rabbitMQ.jpg" style="zoom:67%;" /><a id="more"></a><h3 id="一、什么是消息队列"><a href="#一、什么是消息队列" class="headerlink" title="一、什么是消息队列"></a>一、什么是消息队列</h3><p><strong>消息</strong>指的是两个应用间传递的数据。数据的类型有很多种形式，可能只包含文本字符串，也可能包含嵌入对象。</p><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。在消息队列中，通常有生产者和消费者两个角色。生产者只负责发送数据到消息队列，谁从消息队列中取出数据处理，他不管。消费者只负责从消息队列中取出数据处理，他不管这是谁发送的数据。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/rabbitmq.png" style="zoom:67%;" /><h3 id="二、为什么使用消息队列"><a href="#二、为什么使用消息队列" class="headerlink" title="二、为什么使用消息队列"></a>二、为什么使用消息队列</h3><p>主要有三个作用：</p><ul><li>解耦</li><li>异步</li><li>削峰</li></ul><hr><h4 id="RabbitMQ几种典型模式"><a href="#RabbitMQ几种典型模式" class="headerlink" title="RabbitMQ几种典型模式"></a>RabbitMQ几种典型模式</h4><ul><li><strong>单模式Simple</strong></li><li><strong>工作模式Work</strong></li><li><strong>发布订阅模式Publish/Subscribe</strong></li><li><strong>路由模式Routing</strong></li><li><strong>通配符模式Topics</strong></li><li><strong>远程调用模式RPC</strong></li></ul><h4 id="模式1：简单模式（Simple-HelloWorld-单生产单消费）"><a href="#模式1：简单模式（Simple-HelloWorld-单生产单消费）" class="headerlink" title="模式1：简单模式（Simple / HelloWorld 单生产单消费）"></a>模式1：简单模式（Simple / HelloWorld 单生产单消费）</h4><p>简单的发送与接收，没有特别的处理。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/20181113170451647.png" alt=""></p><hr><h4 id="模式2：工作模式（Work单发送多接收，拿到消息即销毁）"><a href="#模式2：工作模式（Work单发送多接收，拿到消息即销毁）" class="headerlink" title="模式2：工作模式（Work单发送多接收，拿到消息即销毁）"></a>模式2：工作模式（Work单发送多接收，拿到消息即销毁）</h4><p>一个生产者端，多个消费者端。示例中为了保证消息发送的可靠性，不丢失消息，使消息持久化了。同时为了防止接收端在处理消息时down掉，只有在消息处理完成后才发送消息确认。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/20181113170522132.png" alt=""></p><hr><h4 id="模式3：发布、订阅模式-Publish-Subscribe"><a href="#模式3：发布、订阅模式-Publish-Subscribe" class="headerlink" title="模式3：发布、订阅模式(Publish/Subscribe)"></a>模式3：发布、订阅模式(Publish/Subscribe)</h4><p>使用场景：发布、订阅模式，生产者端发送消息，多个消费者同时接收所有的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/20181113170540476.png" alt=""></p><hr><h4 id="模式4：路由模式（Routing）"><a href="#模式4：路由模式（Routing）" class="headerlink" title="模式4：路由模式（Routing）"></a>模式4：路由模式（Routing）</h4><p>生产者按routing key发送消息，不同的消费者端按不同的routing key接收消息。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/20181113170555287.png" alt=""></p><hr><h4 id="模式5：通配符（或主题）模式（Topics-，按topic发送接收"><a href="#模式5：通配符（或主题）模式（Topics-，按topic发送接收" class="headerlink" title="模式5：通配符（或主题）模式（Topics ，按topic发送接收)"></a>模式5：通配符（或主题）模式（Topics ，按topic发送接收)</h4><p>生产者端不只按固定的routing key发送消息，而是按字符串“匹配”发送，消费者端同样如此。<br>与之前的路由模式相比，它将信息的传输类型的key更加细化，以“key1.key2.keyN…”的模式来指定信息传输的key的大类型和大类型下面的小类型，让消费者端可以更加精细的确认自己想要获取的信息类型。而在消费者端，不用精确的指定具体到哪一个大类型下的小类型的key，而是可以使用类似正则表达式(但与正则表达式规则完全不同)的通配符在指定一定范围或符合某一个字符串匹配规则的key，来获取想要的信息。“通配符交换机”（Topic Exchange）将路由键和某模式进行匹配。此时队列需要绑定在一个模式上。符号“#”匹配一个或多个词，符号“*”仅匹配一个词。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/20181113170631174.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RabbitMQ&quot;&gt;&lt;a href=&quot;#RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ&quot;&gt;&lt;/a&gt;RabbitMQ&lt;/h2&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/rabbitMQ.jpg&quot; style=&quot;zoom:67%;&quot; /&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://codeyg.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息队列" scheme="https://codeyg.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="https://codeyg.top/2021/04/03/Kafka/"/>
    <id>https://codeyg.top/2021/04/03/Kafka/</id>
    <published>2021-04-03T14:29:58.000Z</published>
    <updated>2021-06-11T15:10:01.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka-卡夫卡"><a href="#Kafka-卡夫卡" class="headerlink" title="Kafka (卡夫卡)"></a>Kafka (卡夫卡)</h2><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka.png" style="zoom: 50%;" /><a id="more"></a><h3 id="一、Kafka-是什么？"><a href="#一、Kafka-是什么？" class="headerlink" title="一、Kafka 是什么？"></a>一、Kafka 是什么？</h3><p>Kafka。在流式计算中，Kafka 一般用来缓存数据，例如 Flink 通过消费 Kafka 的数据进行计算。</p><p><strong>kafka是什么？</strong></p><ol><li>Apache Kafka 是一个开源 <strong>「消息」</strong> 系统，由 Scala 写成。是由 Apache 软件基金会开发的 一个开源消息系统项目。</li><li>Kafka 最初是由 LinkedIn 公司开发，用作 LinkedIn 的活动流（Activity Stream）和运营数据处理管道（Pipeline）的基础，现在它已被多家不同类型的公司作为多种类型的数据管道和消息系统使用。</li><li><strong>「Kafka 是一个分布式消息队列」</strong>。Kafka 对消息保存时根据 Topic 进行归类，发送消息 者称为 Producer，消息接受者称为 Consumer，此外 kafka 集群有多个 kafka 实例组成，每个 实例(server)称为 broker。</li><li>无论是 kafka 集群，还是 consumer 都依赖于 <strong>「Zookeeper」</strong> 集群保存一些 meta 信息， 来保证系统可用性。</li></ol><h3 id="二、为什么要有-Kafka"><a href="#二、为什么要有-Kafka" class="headerlink" title="二、为什么要有 Kafka?"></a>二、为什么要有 Kafka?</h3><p><strong>「kafka」</strong> 之所以受到越来越多的青睐，与它所扮演的三大角色是分不开的的：</p><ul><li><strong>「消息系统」</strong>：kafka与传统的消息中间件都具备系统解耦、冗余存储、流量削峰、缓冲、异步通信、扩展性、可恢复性等功能。与此同时，kafka还提供了大多数消息系统难以实现的消息顺序性保障及回溯性消费的功能。</li><li><strong>「存储系统」</strong>：kafka把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效的降低了消息丢失的风险。这得益于其消息持久化和多副本机制。也可以将kafka作为长期的存储系统来使用，只需要把对应的数据保留策略设置为“永久”或启用主题日志压缩功能。</li><li><strong>「流式处理平台」</strong>：kafka为流行的流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理框架，比如窗口、连接、变换和聚合等各类操作。</li></ul><table><thead><tr><th align="left">Kafka</th><th align="left">特性</th></tr></thead><tbody><tr><td align="left">分布式</td><td align="left">具备经济、快速、可靠、易扩充、数据共享、设备共享、通讯方便、灵活等，分布式所具备的特性</td></tr><tr><td align="left">高吞吐量</td><td align="left">同时为数据生产者和消费者提高吞吐量</td></tr><tr><td align="left">高可靠性</td><td align="left">支持多个消费者，当某个消费者失败的时候，能够自动负载均衡</td></tr><tr><td align="left">离线</td><td align="left">能将消息持久化，进行批量处理</td></tr><tr><td align="left">解耦</td><td align="left">作为各个系统连接的桥梁，避免系统之间的耦合</td></tr></tbody></table><h3 id="三、Kafka-基本概念"><a href="#三、Kafka-基本概念" class="headerlink" title="三、Kafka 基本概念"></a>三、Kafka 基本概念</h3><p>在深入理解 Kafka 之前，可以先了解下 Kafka 的基本概念。</p><p>一个典型的 Kafka 包含若干Producer、若干 Broker、若干 Consumer 以及一个 Zookeeper 集群。Zookeeper 是 Kafka 用来负责集群元数据管理、控制器选举等操作的。Producer 是负责将消息发送到 Broker 的，Broker 负责将消息持久化到磁盘，而 Consumer 是负责从Broker 订阅并消费消息。Kafka体系结构如下所示：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka_1.png" style="zoom:67%;" /><h4 id="概念一：生产者（Producer）与消费者（Consumer）"><a href="#概念一：生产者（Producer）与消费者（Consumer）" class="headerlink" title="概念一：生产者（Producer）与消费者（Consumer）"></a>概念一：生产者（Producer）与消费者（Consumer）</h4><p>对于 Kafka 来说客户端有两种基本类型：<strong>「生产者」</strong>（Producer）和 <strong>「消费者」</strong>（Consumer）。除此之外，还有用来做数据集成的 Kafka Connect API 和流式处理的 <strong>「Kafka Streams」</strong> 等高阶客户端，但这些高阶客户端底层仍然是生产者和消费者API，只不过是在上层做了封装。</p><ul><li><strong>「Producer」</strong> ：消息生产者，就是向 Kafka broker 发消息的客户端；</li><li><strong>「Consumer」</strong> ：消息消费者，向 Kafka broker 取消息的客户端；</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka_2.png" style="zoom:67%;" /><h4 id="概念二：Broker-和集群（Cluster）"><a href="#概念二：Broker-和集群（Cluster）" class="headerlink" title="概念二：Broker 和集群（Cluster）"></a>概念二：Broker 和集群（Cluster）</h4><p>一个 Kafka 服务器也称为 <strong>「Broker」</strong>，它接受生产者发送的消息并存入磁盘；Broker 同时服务消费者拉取分区消息的请求，返回目前已经提交的消息。使用特定的机器硬件，一个 Broker 每秒可以处理成千上万的分区和百万量级的消息。</p><p>若干个 Broker 组成一个 <strong>「集群」</strong>（<strong>「Cluster」</strong>），其中集群内某个 Broker 会成为集群控制器（Cluster Controller），它负责管理集群，包括分配分区到 Broker、监控 Broker 故障等。在集群内，一个分区由一个 Broker 负责，这个 Broker 也称为这个分区的 Leader；当然一个分区可以被复制到多个 Broker 上来实现冗余，这样当存在 Broker 故障时可以将其分区重新分配到其他 Broker 来负责。下图是一个样例：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka_3.png" style="zoom:67%;" /><h4 id="概念三：主题（Topic）与分区（Partition）"><a href="#概念三：主题（Topic）与分区（Partition）" class="headerlink" title="概念三：主题（Topic）与分区（Partition）"></a>概念三：主题（Topic）与分区（Partition）</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka_4.png" style="zoom:67%;" /><p>在 Kafka 中，消息以 <strong>「主题」</strong>（<strong>「Topic」</strong>）来分类，每一个主题都对应一个「<strong>「消息队列」</strong>」，这有点儿类似于数据库中的表。但是如果我们把所有同类的消息都塞入到一个“中心”队列中，势必缺少可伸缩性，无论是生产者/消费者数目的增加，还是消息数量的增加，都可能耗尽系统的性能或存储。</p><p>我们使用一个生活中的例子来说明：现在 A 城市生产的某商品需要运输到 B 城市，走的是公路，那么单通道的高速公路不论是在「A 城市商品增多」还是「现在 C 城市也要往 B 城市运输东西」这样的情况下都会出现「吞吐量不足」的问题。所以我们现在引入 <strong>「分区」</strong>（<strong>「Partition」</strong>）的概念，类似“允许多修几条道”的方式对我们的主题完成了水平扩展。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Kafka-卡夫卡&quot;&gt;&lt;a href=&quot;#Kafka-卡夫卡&quot; class=&quot;headerlink&quot; title=&quot;Kafka (卡夫卡)&quot;&gt;&lt;/a&gt;Kafka (卡夫卡)&lt;/h2&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img1/kafka.png&quot; style=&quot;zoom: 50%;&quot; /&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://codeyg.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息队列" scheme="https://codeyg.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>PageHelper</title>
    <link href="https://codeyg.top/2021/03/15/PageHelper/"/>
    <id>https://codeyg.top/2021/03/15/PageHelper/</id>
    <published>2021-03-15T11:41:13.000Z</published>
    <updated>2021-06-06T18:16:05.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PageHelper"><a href="#PageHelper" class="headerlink" title="PageHelper"></a>PageHelper</h2><p><strong>PageHelper是一款好用的开源免费的Mybatis第三方物理分页插件</strong></p><ul><li>Github地址:<a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper</a></li><li>官方地址：<a href="https://pagehelper.github.io/" target="_blank" rel="noopener">https://pagehelper.github.io/</a>**</li></ul><h4 id="如何使用分页插件"><a href="#如何使用分页插件" class="headerlink" title="如何使用分页插件"></a>如何使用分页插件</h4><h4 id="使用-Maven"><a href="#使用-Maven" class="headerlink" title="使用 Maven"></a>使用 Maven</h4><ul><li><strong>在 pom.xml 中添加如下依赖：</strong></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入PageHelper依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>配置PageHelper相关属性</strong></li></ul><h4 id="方法一：在application-yml文件中配置"><a href="#方法一：在application-yml文件中配置" class="headerlink" title="方法一：在application.yml文件中配置"></a>方法一：在application.yml文件中配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置pagehelper参数</span></span><br><span class="line"><span class="attr">pagehelper:</span></span><br><span class="line">    <span class="attr">helperDialect:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">reasonable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">supportMethodsArguments:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">params:</span> <span class="string">count=countSql</span></span><br></pre></td></tr></table></figure><h4 id="方法二：创建一个配置类配置-PageHelper"><a href="#方法二：创建一个配置类配置-PageHelper" class="headerlink" title="方法二：创建一个配置类配置 PageHelper"></a>方法二：创建一个配置类配置 PageHelper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHelperConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageHelper <span class="title">getPageHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PageHelper pageHelper=<span class="keyword">new</span> PageHelper();</span><br><span class="line">        Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">"helperDialect"</span>,<span class="string">"mysql"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"reasonable"</span>,<span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"supportMethodsArguments"</span>,<span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"params"</span>,<span class="string">"count=countSql"</span>);</span><br><span class="line">        pageHelper.setProperties(properties);</span><br><span class="line">        <span class="keyword">return</span> pageHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>PageInfo类源码的属性如下：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageInfo</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">//当前页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageNum;</span><br><span class="line">    <span class="comment">//每页的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pageSize;</span><br><span class="line">    <span class="comment">//当前页的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//由于startRow和endRow不常用，这里说个具体的用法</span></span><br><span class="line">    <span class="comment">//可以在页面中"显示startRow到endRow 共size条数据"</span></span><br><span class="line">    <span class="comment">//当前页面第一个元素在数据库中的行号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> startRow;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前页面最后一个元素在数据库中的行号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> endRow;</span><br><span class="line">    <span class="comment">//总记录数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="comment">//总页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="comment">//结果集</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//前一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> prePage;</span><br><span class="line">    <span class="comment">//下一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextPage;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//是否为第一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstPage = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否为最后一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLastPage = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否有前一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasPreviousPage = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//是否有下一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNextPage = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//导航页码数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> navigatePages;</span><br><span class="line">    <span class="comment">//所有导航页号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] navigatepageNums;</span><br><span class="line">    <span class="comment">//导航条上的第一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> navigateFirstPage;</span><br><span class="line">    <span class="comment">//导航条上的最后一页</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> navigateLastPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>前端请求接口方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getPerson"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;TbPersonPO&gt; <span class="title">getSomePerson</span><span class="params">(@RequestParam(value = <span class="string">"pageNum"</span>,defaultValue=<span class="string">"1"</span>)</span> <span class="keyword">int</span> pageNum )</span>&#123;</span><br><span class="line">       <span class="comment">//pageNum:表示第几页  pageSize:表示一页展示的数据</span></span><br><span class="line">       PageHelper.startPage(pageNum,<span class="number">3</span>);</span><br><span class="line">       List&lt;TbPersonPO&gt; list=tbPersonDao.queryPerosn();</span><br><span class="line">       <span class="comment">//将查询到的数据封装到PageInfo对象</span></span><br><span class="line">       PageInfo&lt;TbPersonPO&gt; pageInfo=<span class="keyword">new</span> PageInfo(list,<span class="number">3</span>);</span><br><span class="line">       <span class="comment">//分割数据成功</span></span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>PageHelper是不是用起来感觉为我们节省了不少的时间呢？</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;PageHelper&quot;&gt;&lt;a href=&quot;#PageHelper&quot; class=&quot;headerlink&quot; title=&quot;PageHelper&quot;&gt;&lt;/a&gt;PageHelper&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;PageHelper是一款好用的开源免费的Mybatis第三方物理分页插件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Github地址:&lt;a href=&quot;https://github.com/pagehelper/Mybatis-PageHelper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/pagehelper/Mybatis-PageHelper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;官方地址：&lt;a href=&quot;https://pagehelper.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pagehelper.github.io/&lt;/a&gt;**&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;如何使用分页插件&quot;&gt;&lt;a href=&quot;#如何使用分页插件&quot; class=&quot;headerlink&quot; title=&quot;如何使用分页插件&quot;&gt;&lt;/a&gt;如何使用分页插件&lt;/h4&gt;&lt;h4 id=&quot;使用-Maven&quot;&gt;&lt;a href=&quot;#使用-Maven&quot; class=&quot;headerlink&quot; title=&quot;使用 Maven&quot;&gt;&lt;/a&gt;使用 Maven&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在 pom.xml 中添加如下依赖：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 引入PageHelper依赖 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.github.pagehelper&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;pagehelper&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.1.2&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.github.pagehelper&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;pagehelper-spring-boot-autoconfigure&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.github.pagehelper&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;pagehelper-spring-boot-starter&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="工具" scheme="https://codeyg.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="分页插件" scheme="https://codeyg.top/tags/%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>整理项目</title>
    <link href="https://codeyg.top/2021/02/26/%E6%95%B4%E7%90%86%E9%A1%B9%E7%9B%AE/"/>
    <id>https://codeyg.top/2021/02/26/%E6%95%B4%E7%90%86%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-02-26T14:58:30.000Z</published>
    <updated>2021-06-06T18:14:19.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整理项目"><a href="#整理项目" class="headerlink" title="整理项目"></a>整理项目</h2><p>​    这两天闲着没事（其实是不知道干啥）想整理一下GitHub上的项目说明（readme.md） </p><p>​    发现需要将一些项目结构，所涉及到的技术栈……什么的整理好所以就效仿着其他大佬的项目说明进行的整        理，经过一番整理就算是总结一下过去的经历吧~</p><ul><li><p>首先运行项目，嗯要不然咋能有相应的截图呢</p></li><li><p>然后再把截好的图上传到图床上（我用的免费版的GitHub的图床，通过CDN加速加载也没有那么慢）</p><a id="more"></a><h4 id="管理系统"><a href="#管理系统" class="headerlink" title="管理系统"></a>管理系统</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img_yg/image-20210530023521804.png" alt=""></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img_yg/image-20210530023849721.png" alt=""></p><hr></li></ul><blockquote><p>其实做这个此项目的意义就在于，我在学习相应的技术后能不能够在实际操作中运用好，当然在实际操作的过程中还是遇到了或多或少的问题，感谢前人把之前遇到的问题+解决方案整理出来，使得我走了不少捷径，哈哈哈~</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;整理项目&quot;&gt;&lt;a href=&quot;#整理项目&quot; class=&quot;headerlink&quot; title=&quot;整理项目&quot;&gt;&lt;/a&gt;整理项目&lt;/h2&gt;&lt;p&gt;​    这两天闲着没事（其实是不知道干啥）想整理一下GitHub上的项目说明（readme.md） &lt;/p&gt;
&lt;p&gt;​    发现需要将一些项目结构，所涉及到的技术栈……什么的整理好所以就效仿着其他大佬的项目说明进行的整        理，经过一番整理就算是总结一下过去的经历吧~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先运行项目，嗯要不然咋能有相应的截图呢&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后再把截好的图上传到图床上（我用的免费版的GitHub的图床，通过CDN加速加载也没有那么慢）&lt;/p&gt;</summary>
    
    
    
    <category term="生活篇" scheme="https://codeyg.top/categories/%E7%94%9F%E6%B4%BB%E7%AF%87/"/>
    
    
    <category term="折腾" scheme="https://codeyg.top/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title>Sass</title>
    <link href="https://codeyg.top/2021/02/18/Sass/"/>
    <id>https://codeyg.top/2021/02/18/Sass/</id>
    <published>2021-02-18T11:57:30.000Z</published>
    <updated>2021-06-06T18:15:45.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何将Sass编译成CSS"><a href="#如何将Sass编译成CSS" class="headerlink" title="如何将Sass编译成CSS"></a>如何将Sass编译成CSS</h2><h4 id="命令编译"><a href="#命令编译" class="headerlink" title="命令编译"></a>命令编译</h4><p>命令编译就是在终端中输入 <code>sass</code> 命令来编译 Sass 代码，这种编译方式使用起来很简单。</p><p><strong>示例：</strong></p><p>假设现在有一个Sass文件，文件名为 <code>style.scss</code> （Sass 文件的扩展名名 <code>.scss</code>），我们需要将这个文件中的代码编译成 CSS 代码，可以执行如下命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span> <span class="selector-tag">style</span><span class="selector-class">.css</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>命令执行成功后，会自动创建一个 <code>style.css</code> 文件。但是这样有一个问题，就是每次更改了 <code>style.scss</code> 文件中的内容，都需要执行一次编译命令，就会很麻烦。</p><p>如果要解决上述问题，可以使用监听命令 <code>--watch</code> ，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">--watch</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span><span class="selector-pseudo">:style.css</span></span><br></pre></td></tr></table></figure><p>如果项目中有很多的 sass 文件，可以监听整个目录：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure><h4 id="Sass四种输出格式"><a href="#Sass四种输出格式" class="headerlink" title="Sass四种输出格式"></a>Sass四种输出格式</h4><p>在编译 Sass 代码时，我们可以指定 Sass 的编译输出格式，这需要用到 <code>--style</code> 指令，这个指定后面可接如下四种 Sass 输出格式：</p><ul><li><code>nested</code>：嵌套输出格式，默认格式。</li><li><code>expanded</code>：展开输出方式。</li><li><code>compact</code>：紧凑输出方式 。</li><li><code>compressed</code>：压缩输出方式 。</li></ul><p><strong>示例：</strong></p><p>例如以 <code>style.scss</code> 文件为例，内容如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xkd</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="selector-class">.box</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一种：使用-nested-编译排版格式输出，可以执行如下命令："><a href="#第一种：使用-nested-编译排版格式输出，可以执行如下命令：" class="headerlink" title="第一种：使用 nested 编译排版格式输出，可以执行如下命令："></a>第一种：使用 <strong><code>nested</code></strong> 编译排版格式输出，可以执行如下命令：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span><span class="selector-pseudo">:style.css</span> <span class="selector-tag">--style</span> <span class="selector-tag">nested</span></span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xkd</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>; &#125;</span><br><span class="line">  <span class="selector-class">.xkd</span> <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="第二种：使用-expanded-编译排版格式输出，可以执行如下命令："><a href="#第二种：使用-expanded-编译排版格式输出，可以执行如下命令：" class="headerlink" title="第二种：使用 expanded 编译排版格式输出，可以执行如下命令："></a>第二种：使用 <strong><code>expanded</code></strong> 编译排版格式输出，可以执行如下命令：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span><span class="selector-pseudo">:style.css</span> <span class="selector-tag">--style</span> <span class="selector-tag">expanded</span></span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xkd</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.xkd</span> <span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第三种：使用-compact-编译排版格式输出，可以执行如下命令："><a href="#第三种：使用-compact-编译排版格式输出，可以执行如下命令：" class="headerlink" title="第三种：使用 compact 编译排版格式输出，可以执行如下命令："></a>第三种：使用 <strong><code>compact</code></strong> 编译排版格式输出，可以执行如下命令：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span><span class="selector-pseudo">:style.css</span> <span class="selector-tag">--style</span> <span class="selector-tag">compact</span></span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xkd</span> &#123; <span class="attribute">font-size</span>: <span class="number">14px</span>; <span class="attribute">color</span>: <span class="number">#ccc</span>; &#125;</span><br><span class="line"><span class="selector-class">.xkd</span> <span class="selector-class">.box</span> &#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>; <span class="attribute">border-radius</span>: <span class="number">5px</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="第四种：使用-compressed-编译排版格式输出，可以执行如下命令："><a href="#第四种：使用-compressed-编译排版格式输出，可以执行如下命令：" class="headerlink" title="第四种：使用 compressed 编译排版格式输出，可以执行如下命令："></a>第四种：使用 <strong><code>compressed</code></strong> 编译排版格式输出，可以执行如下命令：</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sass</span> <span class="selector-tag">style</span><span class="selector-class">.scss</span><span class="selector-pseudo">:style.css</span> <span class="selector-tag">--style</span> <span class="selector-tag">compressed</span></span><br></pre></td></tr></table></figure><p>编译后的 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.xkd</span>&#123;<span class="attribute">font-size</span>:<span class="number">14px</span>;<span class="attribute">color</span>:<span class="number">#ccc</span>&#125;<span class="selector-class">.xkd</span> <span class="selector-class">.box</span>&#123;<span class="attribute">width</span>:<span class="number">100px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>;<span class="attribute">border-radius</span>:<span class="number">5px</span>&#125;</span><br></pre></td></tr></table></figure><hr><p>这四种输出格式中，一般我会选择使用第二种输出格式，也就是 <code>expanded</code> 格式。这种格式和我们手写的 CSS 样式差不多，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何将Sass编译成CSS&quot;&gt;&lt;a href=&quot;#如何将Sass编译成CSS&quot; class=&quot;headerlink&quot; title=&quot;如何将Sass编译成CSS&quot;&gt;&lt;/a&gt;如何将Sass编译成CSS&lt;/h2&gt;&lt;h4 id=&quot;命令编译&quot;&gt;&lt;a href=&quot;#命令编译&quot; class=&quot;headerlink&quot; title=&quot;命令编译&quot;&gt;&lt;/a&gt;命令编译&lt;/h4&gt;&lt;p&gt;命令编译就是在终端中输入 &lt;code&gt;sass&lt;/code&gt; 命令来编译 Sass 代码，这种编译方式使用起来很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设现在有一个Sass文件，文件名为 &lt;code&gt;style.scss&lt;/code&gt; （Sass 文件的扩展名名 &lt;code&gt;.scss&lt;/code&gt;），我们需要将这个文件中的代码编译成 CSS 代码，可以执行如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;sass&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.scss&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.css&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://codeyg.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Web" scheme="https://codeyg.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Vue系列--Webpack</title>
    <link href="https://codeyg.top/2021/01/16/Vue%E7%B3%BB%E5%88%97--Webpack/"/>
    <id>https://codeyg.top/2021/01/16/Vue%E7%B3%BB%E5%88%97--Webpack/</id>
    <published>2021-01-16T11:58:58.000Z</published>
    <updated>2021-06-06T17:51:32.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h4 id="Webpack是什么、为什么要使用它"><a href="#Webpack是什么、为什么要使用它" class="headerlink" title="Webpack是什么、为什么要使用它"></a>Webpack是什么、为什么要使用它</h4><p>简单来说，Webpack是一个打包工具</p><p>成为一个优秀的前端工程师，除了要会写页面样式和动态效果之外，还需要会用主流的单页面框架、Node.js、简单的前端的性能优化等等。加上现在一部分服务器的逻辑移到了前端上，所以实际上前端的复杂度也是提升了很多。</p><p>而Webpack可以帮助我们完成一些任务。比如js压缩、css压缩、编译模板文件等等，从而减少前端的工作量。当然，Webpack功能很强大</p><h4 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h4><p><strong>安装:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure><a id="more"></a><hr><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20200223141638666.png" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20200223141758667.png" style="zoom:67%;" /><p><strong>测试安装成功:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack -v</span><br><span class="line">webpack-cli -v</span><br></pre></td></tr></table></figure> <img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20200223141858668.png" style="zoom:67%;" /><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>创建 <code>webpack.config.js</code> 配置文件</strong></p><ul><li>entry：入口文件，指定 WebPack 用哪个文件作为项目的入口</li><li>output：输出，指定 WebPack 把处理完成的文件放置到指定路径</li><li>module：模块，用于处理各种类型的文件</li><li>plugins：插件，如：热更新、代码重用等</li><li>resolve：设置路径指向</li><li>watch：监听，用于设置文件改动后直接打包</li></ul><h4 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h4><ol><li><p><strong>创建项目</strong></p></li><li><p><strong>创建一个名为 modules 的目录，用于放置 JS 模块等资源文件</strong></p></li><li><p><strong>在modules下创建模块文件，如 hello.js，用于编写 JS 模块相关代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴露一个方法:sayHi</span></span><br><span class="line">exports.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"&lt;div&gt;Hello WebPack&lt;/div&gt;"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在modules下创建一个名为 main.js 的入口文件，用于打包时设置 entry 属性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//require 导入一个模块,就可以调用这个模块中的方法了</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">"./hello"</span>);</span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure></li><li><p><strong>在项目目录下创建 webpack.config.js 配置文件，使用 webpack 命令打包</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">"./modules/main.js"</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">"./js/bundle.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>在项目目录下创建 HTML 页面，如 index.html，导入 WebPack 打包后的 JS 文件</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"dist/js/bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>在IDEA控制台中直接执行webpack;如果失败的话,就使用管理员权限运行即可</strong></p></li><li><p><strong>运行 HTML 看效果</strong></p></li></ol><p><strong>说明:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 --watch 用于监听变化</span></span><br><span class="line">webpack --watch</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Webpack&quot;&gt;&lt;a href=&quot;#Webpack&quot; class=&quot;headerlink&quot; title=&quot;Webpack&quot;&gt;&lt;/a&gt;Webpack&lt;/h2&gt;&lt;h4 id=&quot;Webpack是什么、为什么要使用它&quot;&gt;&lt;a href=&quot;#Webpack是什么、为什么要使用它&quot; class=&quot;headerlink&quot; title=&quot;Webpack是什么、为什么要使用它&quot;&gt;&lt;/a&gt;Webpack是什么、为什么要使用它&lt;/h4&gt;&lt;p&gt;简单来说，Webpack是一个打包工具&lt;/p&gt;
&lt;p&gt;成为一个优秀的前端工程师，除了要会写页面样式和动态效果之外，还需要会用主流的单页面框架、Node.js、简单的前端的性能优化等等。加上现在一部分服务器的逻辑移到了前端上，所以实际上前端的复杂度也是提升了很多。&lt;/p&gt;
&lt;p&gt;而Webpack可以帮助我们完成一些任务。比如js压缩、css压缩、编译模板文件等等，从而减少前端的工作量。当然，Webpack功能很强大&lt;/p&gt;
&lt;h4 id=&quot;安装Webpack&quot;&gt;&lt;a href=&quot;#安装Webpack&quot; class=&quot;headerlink&quot; title=&quot;安装Webpack&quot;&gt;&lt;/a&gt;安装Webpack&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;安装:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install webpack -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install webpack-cli -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="前端" scheme="https://codeyg.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vue" scheme="https://codeyg.top/tags/vue/"/>
    
  </entry>
  
</feed>
