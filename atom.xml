<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>宇航员不会飞</title>
  
  <subtitle>里面的人想出去，外面的人想进来</subtitle>
  <link href="https://codeyg.top/atom.xml" rel="self"/>
  
  <link href="https://codeyg.top/"/>
  <updated>2021-06-20T17:01:17.082Z</updated>
  <id>https://codeyg.top/</id>
  
  <author>
    <name>白日梦想家</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日一面--Spring入门</title>
    <link href="https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/"/>
    <id>https://codeyg.top/2021/06/19/%E9%9D%A2%E8%AF%95--Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2021-06-19T13:58:58.000Z</published>
    <updated>2021-06-20T17:01:17.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇Java小知识</p></blockquote><p><strong>本篇着重介绍一下 Spring 框架</strong></p><hr><br><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png" style="zoom:50%;" /><br><br><p><strong>写在前面</strong></p><p>百度百科：</p><p>Spring 框架是由于软件开发的复杂性而创建的。</p><p>Spring 使用的是基本的<code>JavaBean</code>来完成以前只可能由<code>EJB</code>完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。</p><a id="more"></a><h3 id="Spring-的整体架构"><a href="#Spring-的整体架构" class="headerlink" title="Spring 的整体架构"></a>Spring 的整体架构</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1555451-20200715233519469-2015600342.png" style="zoom:90%;" /><hr><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>A 表现层  <code>web</code>层 、 <code>MVC</code>是表现层的一个设计模型 </li><li>B 业务层 <code>service</code>层</li><li>C 持久层 <code>dao</code>层</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>要与 SPringMVC 的三层架构区分开。</p><h4 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h4><ul><li><strong>spring-core</strong> 模块提供了框架的基本组成部分，包括 <code>IoC</code> 和依赖注入功能。</li><li><strong>spring-beans</strong> 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</li><li><strong>context</strong> 模块建立在由 <strong>core</strong>和 <strong>beans</strong> 模块的基础上建立起来的，它以一种类似于 JNDI 注册的方式访问对象。Context 模块继承自 Bean 模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过 Servelet 容器）等功能。Context 模块也支持 Java EE 的功能，比如 EJB、JMX 和远程调用等。<strong>ApplicationContext</strong> 接口是 Context 模块的焦点。<strong>spring-context-support</strong> 提供了对第三方集成到 Spring 上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</li><li><strong>spring-expression</strong> 模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是 JSP2.1 规范中定义的统一表达式语言的扩展，支持 set 和 get 属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从 Spring IoC 容器检索对象，还支持列表的投影、选择以及聚合等。</li></ul><h4 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h4><p><font color=#FF0000>注：JDBC【Java Data Base Connectivity】，ORM【Object Relational Mapping】，OXM【Object XML Mapping】，JMS【Java Message Service】</font></p><ul><li><strong>JDBC</strong> 模块提供了 JDBC 抽象层，它消除了冗长的 JDBC 编码和对数据库供应商特定错误代码的解析。</li><li><strong>ORM</strong> 模块提供了对流行的对象关系映射 API 的集成，包括 JPA、JDO 和 Hibernate 等。通过此模块可以让这些 ORM 框架和 spring的其它功能整合，比如前面提及的事务管理。</li><li><strong>OXM</strong> 模块提供了对 OXM 实现的支持，比如 JAXB、Castor、XML Beans、JiBX、XStream 等。</li><li><strong>JMS</strong> 模块包含生产（produce）和消费（consume）消息的功能。从 Spring 4.1 开始，集成了 spring-messaging 模块。</li><li><strong>事务</strong>模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写 beginTransaction()、commit()、rollback() 等事务管理方法，声明式事务是通过注解或配置由 spring 自动处理，编程式事务粒度更细）</li></ul><h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p><ul><li><strong>Web</strong> 模块提供面向 web 的基本功能和面向 web 的应用上下文，比如多部分（multipart）文件上传功能、使用 Servlet 监听器初始化 IoC 容器等。它还包括 HTTP 客户端以及 Spring 远程调用中与 web 相关的部分。</li><li><strong>Web-MVC</strong> 模块为 web 应用提供了模型视图控制（MVC）和 REST Web服务的实现。Spring 的 MVC 框架可以使领域模型代码和 web 表单完全地分离，且可以与 Spring 框架的其它所有功能进行集成。</li><li><strong>Web-Socket</strong> 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</li><li><strong>Web-Portlet</strong> 模块提供了用于 Portlet 环境的 MVC 实现，并反映了 spring-webmvc 模块的功能。</li></ul><hr><h3 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h3><h4 id="Spring-框架的优点"><a href="#Spring-框架的优点" class="headerlink" title="Spring 框架的优点"></a>Spring 框架的优点</h4><ol><li>非侵入式设计</li><li>方便解耦、简化开发</li><li>支持AOP</li><li>支持声明式事务处理</li><li>方便程序的测试</li><li>方便集成各种优秀框架</li><li>降低Jave EE API的使用难度。</li></ol><p><font color=#008000>说到 spring 的容器管理就不得不先提一下 bean 的概念</font></p><h4 id="Bean-的概念"><a href="#Bean-的概念" class="headerlink" title="Bean 的概念"></a>Bean 的概念</h4><ol><li>在 Java 中，“Bean”是对“可重用组件”的惯用叫法。组件本身就是一个抽象概念，Bean 作为其代称，也是一个抽象概念，当我们将一个类或一个对象作为组件来考虑时，就可以称它为 Bean。</li><li>在 Spring 中，Bean 的概念同上，它有时也被称为 Component。由 Spring 容器管理的 Bean 则称为 Spring Bean。</li></ol><p><strong>扩展：</strong></p><ul><li><p><em>Java Bean</em> 的概念不同于 Bean，Java Bean 是指符合 <em>JavaBeans</em> 规范的一类特殊的 Bean，即：所有属性均为 private，提供 getter 和 setter，提供默认构造方法。JavaBean 也可以认为是遵循特定约定的 POJO。</p></li><li><p>POJO（Plain Ordinary Java Object）是指简单且普通的 Java 对象。严格来说，它不继承类，不实现接口，不处理业务逻辑，仅用于封装数据。</p></li></ul><p><font color=#008000>说到 spring 就不得不提到两个重要的概念</font></p><ul><li>IoC 【控制反转】</li><li>DI 【依赖注入】</li></ul><h4 id="IOC-与-DI"><a href="#IOC-与-DI" class="headerlink" title="IOC 与 DI"></a>IOC 与 DI</h4><h5 id="IOC-定义"><a href="#IOC-定义" class="headerlink" title="IOC 定义"></a>IOC 定义</h5><p>IoC（Inverse Of Control，控制反转）是一种设计思想，所谓控制反转，指的是对资源的控制方式进行反转。</p><p><strong>IOC 容器</strong>具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</p><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>【控制权在自己】：在 OOP 中，对象之间往往存在某种依赖关系，当一个对象依赖另一个对象时，传统 OOP 的做法是在它内部直接 <strong>new</strong> 一个出来，这种做法是由对象自己主动创建并管理依赖资源。</p><p>【控制权在 Spring 容器】：”控制反转”是指 <strong>new</strong> 实例工作不由程序员来做而是交给 Spring 容器来做。使得对象不再主动控制依赖资源，而是被动接受资源，IoC 要求将资源的控制权下放给 <strong>Ioc</strong> 容器，它将对资源进行集中管理，对象需要什么资源就从容器中取，或者让容器主动将资源注入进来。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><p>在 IoC 之后，对象与依赖资源之间不再具有强耦合性，资源可以被直接替换，而无需改动需求方的代码。</p><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>在 Spring 中 <strong>BeanFactory</strong> 是 IOC 容器的实际代表者。【工厂模式】</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_20-38-32.png" alt=""></p><hr><h5 id="Spring-的两种-IoC-容器"><a href="#Spring-的两种-IoC-容器" class="headerlink" title="Spring 的两种 IoC 容器"></a>Spring 的两种 IoC 容器</h5><p>Spring 提供了两种 IoC 容器： BeanFactory 和 ApplicationContext </p><ul><li>BeanFactory 提供基本的 IoC 服务支持。</li><li>ApplicationContext 对 BeanFactory 进行了扩展与增强，除了拥有 BeanFactory 的所有能力外，还提供了许多高级特性，如事件发布、资源加载、国际化消息等。ApplicationContext 接口继承自 BeanFactory 接口，它的实现也是直接复用了 BeanFactory 的实现，因此可以说，ApplicationContext 是 BeanFactory 的增强版。</li></ul><p>两者在核心功能上的区别主要是默认的加载策略不同，这点区别几乎可以忽略不计，通常情况下，我们总是使用更为强大的 ApplicationContext，很少会直接使用 BeanFactory。</p><h5 id="IoC-的两种实现方式"><a href="#IoC-的两种实现方式" class="headerlink" title="IoC 的两种实现方式"></a>IoC 的两种实现方式</h5><ul><li>DI（Dependency Injection，依赖注入）<br>所谓依赖注入，是指对象所依赖的资源将通过被动注入的方式得到，换言之，容器会主动地根据预先配置的依赖关系将资源注入进来。</li><li>DL（Dependency Lookup，依赖查找）<br>依赖查找是早先提出的一种 IoC 实现方式，它要求对象主动查找依赖资源，这种方式已经不再使用。</li></ul><h5 id="DI-定义"><a href="#DI-定义" class="headerlink" title="DI 定义"></a>DI 定义</h5><p>Spring 容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过 Spring 容器获得被调用者实例，这称为依赖注入。</p><h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p>依赖注入主要有两种实现方式，分别是属性 setter 注入和构造方法注入</p><ol><li><strong>属性 setter 注入</strong></li></ol><p>指 IoC 容器使用 setter 方法注入被依赖的实例。通过调用无参构造器或无参 static 工厂方法实例化 bean 后，调用该 bean 的 setter 方法，即可实现基于 setter 的 DI。</p><ol start="2"><li><strong>构造方法注入</strong></li></ol><p>指 IoC 容器使用构造方法注入被依赖的实例。基于构造器的 DI 通过调用带参数的构造方法实现，每个参数代表一个依赖。</p><h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇Java小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Spring 框架&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;br&gt;

&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-20_17-58-03.png&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;br&gt;

&lt;br&gt;

&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;百度百科：&lt;/p&gt;
&lt;p&gt;Spring 框架是由于软件开发的复杂性而创建的。&lt;/p&gt;
&lt;p&gt;Spring 使用的是基本的&lt;code&gt;JavaBean&lt;/code&gt;来完成以前只可能由&lt;code&gt;EJB&lt;/code&gt;完成的事情。然而，Spring 的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分 Java 应用都可以从 Spring 中受益。&lt;/p&gt;</summary>
    
    
    
    <category term="框架" scheme="https://codeyg.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://codeyg.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--TCP 3次挥手与4次握手</title>
    <link href="https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://codeyg.top/2021/06/16/%E9%9D%A2%E8%AF%95--HTTP3%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8E4%E6%AC%A1%E6%8F%A1%E6%89%8B/</id>
    <published>2021-06-16T13:58:58.000Z</published>
    <updated>2021-06-20T17:26:20.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇面试小知识</p></blockquote><p><strong>本篇着重介绍一下 TCP 3次挥手与4次握手 ：</strong> 但不局限于介绍 TCP~</p><hr><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><strong>划重点</strong></p><p><font color=#008000><code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议</font></p><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。</p><p>那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。</p><a id="more"></a><h4 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1612150605-NindRH-image.png" style="zoom:67%;" /><hr><p>由上至下依次为：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP-头部包含哪些信息"><a href="#HTTP-头部包含哪些信息" class="headerlink" title="HTTP 头部包含哪些信息"></a>HTTP 头部包含哪些信息</h4><p>HTTP 头部本质上是一个传递额外重要信息的键值对。主要分为：通用头部，请求头部，响应头部和实体头部。</p><p>下面重点来说一下我们熟悉的 “实体头部” </p><table><thead><tr><th>协议头</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Content-encoding</td><td>返回内容的编码方式</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Length</td><td>返回内容的字节长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: /index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021/47022</td></tr><tr><td><strong>Content-Type</strong></td><td><strong>返回内容的MIME类型</strong></td><td><strong>Content-Type: text/html; charset=utf-8</strong></td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr></tbody></table><hr><h4 id="POST-和-Get-的区别"><a href="#POST-和-Get-的区别" class="headerlink" title="POST 和 Get 的区别"></a>POST 和 Get 的区别</h4><p>我们知道，HTTP定义了与服务器进行交互的不同方法，常见的有四种：GET、POST、PUT、DELETE。其中，GET 和 POST 最常用。</p><ul><li><code>GET</code> 用来获取资源，它只是获取、查询数据，不会修改服务器的数据。</li><li><code>POST</code> 则是可以向服务器发送修改请求，进行数据的修改的。</li></ul><h5 id="从性能角度"><a href="#从性能角度" class="headerlink" title="从性能角度"></a>从性能角度</h5><ol><li>post 携带的请求头更多；</li><li>握手次数 post：get （6 : 4）；</li><li>get 保存数据（Ajax），post则不会；</li></ol><h5 id="从安全角度"><a href="#从安全角度" class="headerlink" title="从安全角度"></a>从安全角度</h5><ol><li>post 更加的安全（请求数据不会作为 url 的一部分，缓存、日志等）</li><li>post 发送的数据量更大，get 有 url 的长度限制；</li><li>post 发送的更多的数据类型 ， get 只能是 ASCLL；</li></ol><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>我们常说的一些区别都是一些表面上的。</p><p>比如：<code>GET</code>没有<code>POST</code>安全；<code>GET</code>请求时<code>URL</code>的长度是有限制的；<code>GET</code>没有<code>body</code>而<code>POST</code>有<code>body</code>等等。</p><p>这些都是针对浏览器中的要求， 在使用<code>HTTP</code>作为接口进行传输时，就没有这么多条条框框了。</p><p>此时<code>GET</code>和<code>POST</code>只是<code>HTTP</code>协议中的两种请求方式，而<code>HTTP</code>协议是基于<code>TCP/IP</code>的应用层协议， 无论<code>GET</code>还是<code>POST</code>，用的都是同一个传输层协议，所以在传输上没有区别。</p><p><code>GET</code>也可以有<code>body</code>，<code>POST</code>也不一定非要使用<code>body</code></p><hr><h4 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h4><p><font color=#008000>HTTP 和 HTTPS 的区别有哪些？</font></p><p>最明显直观的就是在网页上访问网址，地址栏位的 url 显示区别</p><ul><li>如果是 http 请求，则显示为不安全</li><li>如果是 https 请求，则显示为安全</li></ul><h5 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP?"></a>什么是HTTP?</h5><p>超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。</p><p><strong>HTTP报文格式</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/http_get_post.png" style="zoom:67%;" /><h5 id="什么是HTTPS"><a href="#什么是HTTPS" class="headerlink" title="什么是HTTPS?"></a>什么是HTTPS?</h5><p><strong>HTTPS = SSL + HTTP</strong></p><p>HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p><strong>Http：</strong></p><ul><li>无状态 【是指协议对于交互性场景没有记忆能力、cookie / session 让服务器有记忆能力】</li><li>无连接 【限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接】</li><li>基于请求和响应</li><li>简单快速</li><li>使用明文通信（不会确认通信方）</li></ul><p><strong>Https:</strong></p><ul><li>通过 SSL / TLS 提供加密</li></ul><h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><ol><li>Https更加的安全</li><li>Https需要申请证书</li><li>端口不同：http =&gt; 80； https =&gt; 443；</li><li>状态不同：http =&gt; 无状态； https =&gt; 协议加密；</li></ol><h5 id="HTTP通信传输"><a href="#HTTP通信传输" class="headerlink" title="HTTP通信传输"></a>HTTP通信传输</h5><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_00-36-54.png" alt=""></p><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>三次握手经典图例（客户端请求服务端获取数据）</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-13-48.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【seq】序号</p><p>【ack】确认序号</p><p>【SYN】同步                                                        </p><p>【ACK】确认</p><p><strong>三次握手</strong></p><ul><li><p>第一次握手：客户端首先向服务端发送请求，tcp 报文头中发送标识 SYN=1 (SYN表示客户端请求跟服务端建立连接),序号 Seq=x。</p></li><li><p>第二次握手：服务端在接收到客户端发送的请求之后，需要告诉客户端已收到请求，tcp 报文头中发送标识SYN=1,ACK=1(SYN表示服务端请求跟客户端建立连接，ACK 表示对客户端的连接请求进行应答),序号 Seq=y,确认号=x+1（表示对客户端发送的序号Seq=x的请求进行确认）。</p></li><li><p>第三次握手：客户端在接收到服务端发送的请求和确认信息之后，同样需要告诉服务端已收到信息，tcp 报文头中发送标识 ACK=1(ACK表示对服务端的连接请求进行应答),序号 Seq=x+1，确认号 Ack=y+1（表示对服务端发送的序号 Seq=y 的请求进行确认）</p><p>当三次握手都成功的时候，我们发现此时客户端发送的信息服务端能够收到并且服务端发送的信息客户端也能收到，通信双方<strong>连接成功</strong>。</p></li></ul><p><strong>注意</strong></p><ol><li>发送请求中的发送标识SYN、ACK表示的是发送报文中两个标识位！而Seq和Ack分别代表发送序号和确认号。</li><li>服务端在接收到了客户端的连接请求后，回复中同时发送了SYN、ACK两个标识位，将建立连接的请求和对客户端的确认应答在同一个数据包中发送了，这也是为什么只需要三次握手，就能建立连接</li></ol><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><font color=#008000>当客户端和服务端之间的数据传输完毕之后，我们就需要释放连接（一直建立连接会浪费资源），那为啥需要四次挥手呢？</font></p><p>四次挥手经典图例</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_01-35-29.png" alt=""></p><p><strong>图中单词解释：</strong></p><p>【MSL】报文最大生存时间 （它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃）</p><p><strong>四次挥手</strong></p><ul><li><p>第一次挥手：客户端向服务端发送断开连接的请求，告诉服务端我这边不需要再请求你的数据了，tcp报文头中发送标识FIN=1（表示客户端请求跟服务端断开连接）,序号Seq=u</p></li><li><p>第二次挥手：服务端在接收到客户端发送的断开请求后，需告诉客户端已收到请求，tcp报文头中发送标识ACK=1(ACK表示对客户端的断开连接的请求进行应答),序号Seq=v,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）。</p></li><li><p>第三次挥手：当服务端数据传输完毕之后，向客户端发起断开连接的请求，告诉客户端我这边也不需要再发送数据了，tcp报文头中发送标识FIN=1，ACK=1(FIN表示服务端请求跟客户端断开连接，ACK表示对上一次客户端的断开连接的请求进行应答),序号Seq=w,确认号Ack=u+1（表示对客户端发送的序号Seq=u的请求进行确认）</p></li><li><p>第四次挥手：客户端接收到服务发送的断开连接请求后，需告诉服务端已收到信息，作出应答，tcp报文头中发送标识ACK=1(ACK表示对服务端的断开连接的请求进行应答),序号Seq=u+1,确认号Ack=w+1（表示对服务端发送的序号Seq=w的请求进行确认）</p></li></ul><p><font color=#008000>1. 为什么不能像握手的时候一样三次握手，为啥需要四次挥手呢？</font></p><p>答：在实际的网络中，服务端在接收到客户端断开连接的请求的时候，此时服务端可能还有数据没有传输完毕，不能立即向客户端发送断开连接的请求！</p><p>当客户端主动发起断开请求的时候，服务器先回应一个确认，等所有数据传输完毕后再发送服务器断开的请求。</p><p><font color=#008000>2. 为什么需要维持2MSL呢？</font></p><p>答：第4次挥手的时候客户端向服务端发送断开连接的请求的确认ACK，如果客户端发送完成后就直接就关闭连接，如果由于网络原因服务端没有收到ACK，那服务端就没法关闭连接了！</p><p>因此客户端在回复确认后，还需要等待，万一服务端没有收到应答还会继续发送断开连接的请求；</p><hr><h4 id="TCP-长连接和短连接"><a href="#TCP-长连接和短连接" class="headerlink" title="TCP 长连接和短连接"></a>TCP 长连接和短连接</h4><p><strong>长连接</strong>：</p><p> 所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）。 </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-09-20.png" alt=""></p><p><strong>短连接</strong>：</p><p>短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-08-13.png" alt=""></p><p><strong>应用场景：</strong></p><p> 长连接多用于操作频繁（读写），点对点的通讯，而且连接数不能太多情况。</p><p>例如：</p><ul><li>数据库的连接用长连接（如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费）</li><li>微信，QQ 之类的即时通讯（文本消息、语音消息、视频消息、图片消息）。</li></ul><p>短连接多用于 WEB 网站的 http 服务。</p><p>因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源。</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>IP协议（Internet Protocol，互联网协议），是TCP/IP协议栈中最核心的协议之一，通过IP地址，保证了联网设备的唯一性，实现了网络通信的面向无连接和不可靠的传输功能。</p><ul><li><p>IP 就是一张身份证，存在于电脑、手机、监控摄像头、汽车等任何需要联网的设备上面；</p></li><li><p>IP 是可以被追踪到和定位的；</p></li></ul><p>面试的时候有面试官聊到关于网络相关考点，于是问道：</p><p><font color=#008000>能说出访问一个网页的全过程？</font></p><p>答：打开浏览器，在地址栏输入URL，回车，出现网页内容。</p><p>太笼统了，要具体！</p><p><font color=#008000>在地址栏输入URL后，整个过程发生了什么？其中的原理是什么？</font></p><p>答：整个过程可以概括为几下几个部分：</p><ol><li>通过解析域名找到 IP，如果缓存里没有就要请求 DNS 服务器得到 IP 地址；</li><li>与目的主机进行 TCP 连接（三次握手）构建 HTTP 请求；</li><li>发送与收取数据（浏览器与目的主机开始HTTP访问过程）；</li><li>与目的主机断开 TCP 连接（四次挥手）；</li></ol><h5 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h5><p><font color=#008000>能简单说说域名解析？并且一个域名可以对应多个IP地址吗？</font></p><p>域名通过 <code>DNS</code> 解析 得到 <code>IP</code> </p><p>首先得知道啥是 DNS ？</p><p>DNS（Domain Name System）是因特网的一项服务，它作为域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>解析域名</li></ul><p>人们在通过浏览器访问网站时只需要记住网站的域名即可，而不需要记住那些不太容易理解的IP地址。</p><p>在DNS系统中有一个比较重要的的资源类型叫做主机记录也称为A记录，A记录是用于名称解析的重要记录，它将特定的主机名映射到对应主机的IP地址上。</p><ul><li>负载均衡</li></ul><p>DNS除了能解析域名之外还具有负载均衡的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-17_02-49-29.png" alt=""></p><hr><p>由上图可以看出，在 DNS 服务器中应该配置了多个A记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www.apusapp.com IN A 114.100.20.201;</span><br><span class="line">www.apusapp.com IN A 114.100.20.202;</span><br><span class="line">www.apusapp.com IN A 114.100.20.203;</span><br></pre></td></tr></table></figure><p>每次域名解析请求都会根据对应的负载均衡算法计算出一个不同的IP地址并返回，这样A记录中配置多个服务器就可以构成一个集群，并可以实现负载均衡。</p><p>一个域名可以对应多个IP地址。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇面试小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 TCP 3次挥手与4次握手 ：&lt;/strong&gt; 但不局限于介绍 TCP~&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;划重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;&lt;code&gt;HTTP&lt;/code&gt;协议是基于&lt;code&gt;TCP/IP&lt;/code&gt;的应用层协议&lt;/font&gt;&lt;/p&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;无论是 Java、PHP 开发者，还是运维人员，只要从事互联网行业，面试时都可能被问到 HTTP 协议相关知识。&lt;/p&gt;
&lt;p&gt;那么要弄清楚 http 的相关知识必需要先来了解一下 http 的 7 层模型。&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="计算机网络" scheme="https://codeyg.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--锁（Lock）</title>
    <link href="https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/"/>
    <id>https://codeyg.top/2021/06/15/%E9%9D%A2%E8%AF%95--%E9%94%81/</id>
    <published>2021-06-15T13:58:58.000Z</published>
    <updated>2021-06-20T18:07:51.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 Java 中的锁：</strong></p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>面试中我们都会遇到一个场景：</p><p><font color=#008000>在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？</font></p><p>很多人脑海里最先想到的一定是“加锁”。</p><p>提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。</p><p><font color=#008000>除了使用 sychronized 关键字，还有其他的解决方案吗？</font></p><p>JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。</p><p>JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。</p><p>下面我们来详细的介绍一下 “锁”</p><hr><a id="more"></a><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-13-50.png"  /><hr><h3 id="Java-的主流锁都有哪些"><a href="#Java-的主流锁都有哪些" class="headerlink" title="Java 的主流锁都有哪些"></a>Java 的主流锁都有哪些</h3><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/lock.png" style="zoom: 67%;" /><p>悲观锁、乐观锁、自旋锁、偏向锁、轻量级锁、重量级锁、公平锁、非公平锁、可重入锁、非可重入锁。</p><h4 id="1、乐观锁-VS-悲观锁"><a href="#1、乐观锁-VS-悲观锁" class="headerlink" title="1、乐观锁 VS 悲观锁"></a>1、乐观锁 VS 悲观锁</h4><p>顾名思义，两种锁的名字分别体现了看待线程同步的不同角度。</p><p>对于同一个数据的并发操作：</p><ul><li>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/optimistic_pessimistic.png" style="zoom:50%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>看下乐观锁和悲观锁的调用方式示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 1、synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 操作同步资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、ReentrantLock</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//防止因为没有获取到锁的情况，finally中lock.unlock()去释放锁，导致出错！</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 操作同步资源</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line">    <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">optimistic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        atomicInteger.incrementAndGet();  <span class="comment">//执行自增1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。</p><p><font color=#008000>为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？</font></p><p>答：乐观锁的主要实现方式 “CAS” 的技术原理实现。</p><h5 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h5><p>CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p><p>java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。</p><p>CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V。</li><li>进行比较的值 A。</li><li>要写入的新值 B。</li></ul><p>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。所以对于乐观锁，“更新”是一个不断重试的操作。</p><p>那么我们进入原子类 AtomicInteger 的源码，看一下 AtomicInteger 的定义：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-15_23-27-12.png" alt=""></p><p>根据定义我们可以看出各属性的作用：</p><ul><li>unsafe： 获取并操作内存的数据。</li><li>valueOffset： 存储 value 在 AtomicInteger 中的偏移量。</li><li>value： 存储 AtomicInteger 的 int 值，该属性需要借助 volatile 关键字保证其在线程间是可见的。</li></ul><h6 id="CAS虽然很高效，但是它也存在三大问题"><a href="#CAS虽然很高效，但是它也存在三大问题" class="headerlink" title="CAS虽然很高效，但是它也存在三大问题"></a>CAS虽然很高效，但是它也存在三大问题</h6><ol><li>ABA问题</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作</li></ol><h6 id="解决ABA问题"><a href="#解决ABA问题" class="headerlink" title="解决ABA问题"></a>解决ABA问题</h6><p>加标志位，例如搞个⾃增的字段，操作⼀次就⾃增加⼀，或者搞个时间戳，⽐较时间戳的值。</p><p> 举个栗⼦：现在我们去要求操作数据库，根据CAS的原则我们本来只需要查询原本的值就好了，现在我 们⼀同查出他的标志位版本字段vision。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue where value &#x3D; #&#123;oldValue&#125;</span><br><span class="line"># oldValue就是我们执⾏前查询出来的值</span><br></pre></td></tr></table></figure><p>带版本号能防⽌ABA的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update table set value &#x3D; newValue ，vision &#x3D; vision + 1 where value &#x3D; #</span><br><span class="line">&#123;oldValue&#125; and vision &#x3D; #&#123;vision&#125;</span><br><span class="line"># 判断原来的值和版本号是否匹配，中间有别的线程修改，值可能相等，但是版本号100%不⼀样</span><br></pre></td></tr></table></figure><hr><h4 id="2、自旋锁-VS-适应性自旋锁"><a href="#2、自旋锁-VS-适应性自旋锁" class="headerlink" title="2、自旋锁 VS 适应性自旋锁"></a>2、自旋锁 VS 适应性自旋锁</h4><p><font color=#008000>为什么要有自旋锁和适应性自旋锁？</font></p><p>首先，阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/spinlocks.png" style="zoom:50%;" /><p>虽然自旋锁有效的避免了因线程之间的切换而产生的开销，但是也并非没有缺点。</p><p>缺点就是它不能代替阻塞。而且它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好。</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次）没有成功获得锁，就应当挂起线程。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-09-40.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-11-25.png" alt=""></p><hr><p>自旋锁的实现原理同样也是CAS。</p><p>AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><h5 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h5><p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><ul><li><p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。</p></li><li><p>如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。、</p></li></ul><hr><h4 id="3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#3、无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>3、无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h4><p>这四种锁是指锁的状态，专门针对synchronized的。</p><p><strong>无锁</strong></p><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。</p><p><strong>偏向锁</strong></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。</p><p><strong>轻量级锁</strong></p><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p><p><strong>重量级锁</strong></p><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/8afdf6f2.png" style="zoom:50%;" /><hr><h4 id="4、公平锁-VS-非公平锁"><a href="#4、公平锁-VS-非公平锁" class="headerlink" title="4、公平锁 VS 非公平锁"></a>4、公平锁 VS 非公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</p><ul><li><p>优点：等待锁的线程不会饿死。</p></li><li><p>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p></li></ul><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</p><ul><li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/fair_lock.png" style="zoom:50%;" /><hr><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/not_fair_lock.png" style="zoom: 67%;" /><hr><p>ReentrantLock的源码来看一下公平锁和非公平锁</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-32-49.png" alt=""></p><hr><h4 id="5、可重入锁-VS-非可重入锁"><a href="#5、可重入锁-VS-非可重入锁" class="headerlink" title="5、可重入锁 VS 非可重入锁"></a>5、可重入锁 VS 非可重入锁</h4><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。</p><p>Java中ReentrantLock和synchronized都是可重入锁。</p><p>可重入锁的一个优点是可一定程度避免死锁。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------- 可重入锁 -------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法1执行..."</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法2执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。 </p><p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><p><font color=#008000>为什么可重入锁就可以在嵌套调用时可以自动获得锁呢？</font></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/reentrant_lock.png" style="zoom:50%;" /><p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/no_reentrant_lock.png" style="zoom:50%;" /><p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><hr><h4 id="6、独享锁-VS-共享锁"><a href="#6、独享锁-VS-共享锁" class="headerlink" title="6、独享锁 VS 共享锁"></a>6、独享锁 VS 共享锁</h4><p>独享锁（排他锁）和共享锁同样是一种概念。</p><ul><li>独享锁是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。</li><li>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_00-58-22.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-00-45.png" alt=""></p><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-16_01-02-36.png" alt=""></p><hr><p>ReentrantReadWriteLock 有两把锁：</p><ul><li><p>ReadLock</p></li><li><p>WriteLock</p></li></ul><p>由词知意，一个读锁一个写锁，合称“读写锁”</p><p>最终发现在 ReentrantLock 虽然有公平锁和非公平锁两种，但是它们添加的都是独享锁。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 Java 中的锁：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;面试中我们都会遇到一个场景：&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;在某某某并发场景下，我们为了保证线程的安全性，应该如何处理呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;很多人脑海里最先想到的一定是“加锁”。&lt;/p&gt;
&lt;p&gt;提到锁，大家肯定想到的是 sychronized 关键字，用它可以解决一切并发问题。&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;除了使用 sychronized 关键字，还有其他的解决方案吗？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;JDK 1.5 之前，使用 synchronized 关键字，拿到 Java 对象的锁，保护锁定的代码块。JVM 保证同一时刻只有一个线程可以拿到这个 Java 对象的锁，执行对应的代码块。&lt;/p&gt;
&lt;p&gt;JDK 1.5 开始，引入了并发工具包 java.util.concurrent.locks.Lock，让锁的功能更加丰富。&lt;/p&gt;
&lt;p&gt;下面我们来详细的介绍一下 “锁”&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="锁" scheme="https://codeyg.top/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM垃圾回收机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T15:58:58.000Z</published>
    <updated>2021-06-20T18:32:48.750Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面</strong></p><p>为啥要写这篇文章呢？还要从很久之前的一次问答说起！</p><p><font color=#008000>什么是 Java 垃圾回收机制？（ JC 哥问我）</font></p><p>我：就是收集一些不被用到的对象，然后集中销毁吧~</p><p><font color=#008000>那应该如何来判断那些对象不被用到呢？</font></p><p>我：好像是 … … 我真的不知道</p><p><font color=#008000>仔细想想</font></p><p>我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？</p><p><font color=#008000>我就说嘛，想想能知道的，继续</font></p><p>我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？</p><p><font color=#008000>是个办法，具体呢？</font></p><p>我：xxx xxx</p><p>…</p><p>…</p><p>最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）</p><p><strong>本篇着重介绍一下JVM垃圾回收机制：</strong></p><hr><a id="more"></a><h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h3><p>在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。</p><p>在<code>JVM</code>中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。</p><p><font color=#008000>回去好好看一下什么是 GC ，那GC 是什么？</font></p><h3 id="GC-是什么？为什么要-GC"><a href="#GC-是什么？为什么要-GC" class="headerlink" title="GC 是什么？为什么要 GC"></a>GC 是什么？为什么要 GC</h3><p>GC 垃圾收集（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存。</p><p>不当的回收可能会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。</p><p><font color=#008000>首先来看一下 Java 中都有哪些引用类型吧</font></p><h3 id="Java-中的引用类型"><a href="#Java-中的引用类型" class="headerlink" title="Java 中的引用类型"></a>Java 中的引用类型</h3><ol><li>强引用：发生 gc 的时候不会被回收。</li><li>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</li><li>弱引用：有用但不是必须的对象，在下一次GC时会被回收。</li><li>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</li></ol><p><font color=#008000>我之前说通过标记位（flag）来判断对象是否被引用，算是说对了一点点吧</font></p><h3 id="如何判断对象是否可以被回收？什么时候被回收？"><a href="#如何判断对象是否可以被回收？什么时候被回收？" class="headerlink" title="如何判断对象是否可以被回收？什么时候被回收？"></a>如何判断对象是否可以被回收？什么时候被回收？</h3><p><strong>一般有两种方法来判断：</strong></p><ol><li><strong>引用计数器法</strong><br>为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。但是他有一个缺点是不能解决循环引用的问题。</li></ol><ol start="2"><li><strong>可达性分析算法</strong><br>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</li></ol><blockquote><p>当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。</p></blockquote><p><font color=#008000>说了这么多，既然是算法都分别有哪些呢？</font></p><h3 id="JVM-的垃圾回收算法？"><a href="#JVM-的垃圾回收算法？" class="headerlink" title="JVM 的垃圾回收算法？"></a>JVM 的垃圾回收算法？</h3><ul><li><p>标记-清除算法</p></li><li><p>标记-复制算法</p></li><li><p>标记-整理算法</p></li><li><p>分代-收集算法</p></li></ul><h4 id="标记-清除算法（mark-sweep）"><a href="#标记-清除算法（mark-sweep）" class="headerlink" title="标记-清除算法（mark-sweep）"></a>标记-清除算法（mark-sweep）</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>该算法分为两个阶段，<strong>标记和清除</strong>。</p><p>标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>执行速度快</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>执行效率不稳定，大量的标记、清除</li><li>内存碎片严重化，后续可能发生对象不能找到利用空间的问题</li></ol><h4 id="标记-复制算法（mark-cope）"><a href="#标记-复制算法（mark-cope）" class="headerlink" title="标记-复制算法（mark-cope）"></a>标记-复制算法（mark-cope）</h4><p>标记-复制算法也称为【半区复制】</p><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>按内存容量将内存划分为等大小的两块。</p><p>每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>内存连续</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>内存使用率不高，只有原来的一半，浪费内存空间</p><h4 id="标记-整理算法（mark-compact）"><a href="#标记-整理算法（mark-compact）" class="headerlink" title="标记-整理算法（mark-compact）"></a>标记-整理算法（mark-compact）</h4><h5 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h5><p>改进于标记-标记-清除算法，通过标记后将存活的对象移动向内存的一端，然后清除端边界外的对象。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>保证了内存的连续性，不会浪费内存。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ol><li><p>效率低（需要移动内存对象）</p></li><li><p>移动时会有并发问题。</p></li></ol><p><font color=#008000>重点说一下分代-收集算法</font></p><h4 id="分代-收集算法（generation-collect）"><a href="#分代-收集算法（generation-collect）" class="headerlink" title="分代-收集算法（generation-collect）"></a>分代-收集算法（generation-collect）</h4><h5 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h5><p>根据对象存活周期的不同将内存划分为几块，一般是<strong>新生代</strong>和<strong>老年代</strong>，新生代基本采用标记-复制算法，老年代采用标记-整理算法和标记-清除算法。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_02-26-58.png" alt=""></p><p>新生代每次垃圾回收大偶会后大批的对象死去，每次回收存活后的少量对象在阈值将去到老年代。</p><h5 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h5><p><strong>对象优先在 Eden 区分配：</strong></p><p>多数情况，对象都在新生代 Eden 区分配。</p><p>当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。</p><p>如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p><ul><li><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</li><li><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</li></ul><p><strong>大对象直接进入老年代</strong></p><p>新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。</p><p>所谓大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><p>大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来 “安置” 它们。<br>        虚拟机提供了一个<code>XX:PretenureSizeThreshold</code>参数，令大于这个设置值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用的是复制算法）。</p><p><strong>长期存活对象将进入老年代</strong></p><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。</p><p>因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。</p><p>对象在 Survivor 区中每过一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为啥要写这篇文章呢？还要从很久之前的一次问答说起！&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;什么是 Java 垃圾回收机制？（ JC 哥问我）&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：就是收集一些不被用到的对象，然后集中销毁吧~&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;那应该如何来判断那些对象不被用到呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：好像是 … … 我真的不知道&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;仔细想想&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：莫非是判断此对象有没有它的引用？或者说有没有指针指向它？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;我就说嘛，想想能知道的，继续&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：继续不下去了，按照我做前端的经验，难道是通过价格标志位来判断的？&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;是个办法，具体呢？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我：xxx xxx&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;最后，我还是决定回去好好看一下相关的知识吧！（算是感谢他对于我的帮助）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM垃圾回收机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- JVM内存结构</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-13T14:58:58.000Z</published>
    <updated>2021-06-20T17:15:14.091Z</updated>
    
    <content type="html"><![CDATA[<p><font color=#008000>什么是JVM？</font></p><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下JVM内存结构：</strong></p><hr><a id="more"></a><h4 id="JVM内存结构图"><a href="#JVM内存结构图" class="headerlink" title="JVM内存结构图"></a>JVM内存结构图</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png" style="zoom:67%;" /><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储<strong>类信息、常量、静态变</strong>量等数据，是<strong>线程共享</strong>的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p><strong>线程与进程：</strong></p><ul><li>同步于线程：程序计数器、虚拟机栈、本地方法栈</li><li>同步于进程：方法区、堆</li></ul><hr><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<strong>唯一一个不会出现Stack Overflow Error 的地方。</strong></p><h4 id="JVM栈"><a href="#JVM栈" class="headerlink" title="JVM栈"></a>JVM栈</h4><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong></p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>1、对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>2、Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。</p><p><strong>控制参数</strong></p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><h4 id="内存结构相关包含"><a href="#内存结构相关包含" class="headerlink" title="内存结构相关包含"></a>内存结构相关包含</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Snipaste_2021-06-21_01-13-25.png" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font color=#008000&gt;什么是JVM？&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下JVM内存结构：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>【JVM系列】-- Java的类加载机制</title>
    <link href="https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://codeyg.top/2021/06/13/JVM%E7%B3%BB%E5%88%97--Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-06-14T17:08:29.989Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是JVM？"><a href="#什么是JVM？" class="headerlink" title="什么是JVM？"></a>什么是JVM？</h4><p><strong>百度词条：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line"></span><br><span class="line">引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</span><br></pre></td></tr></table></figure><p><strong>本篇着重介绍一下Java的类加载机制：</strong></p><hr><a id="more"></a><h4 id="什么是类的加载"><a href="#什么是类的加载" class="headerlink" title="什么是类的加载"></a>什么是类的加载</h4><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 <code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的 <code>Class</code>对象， <code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p><p><strong>加载.class文件的方式</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>加载的过程包括了<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。</p><p><strong>加载</strong></p><p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段获取类的二进制字节流的动作是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p><p><strong>验证：确保被加载的类的正确性</strong></p><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong>准备：为类的 <code>静态变量分</code>配内存，并将其初始化为默认值</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p><strong>解析：把类中的符号引用转换为直接引用</strong></p><p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li>①声明类变量是指定初始值</li><li>②使用静态代码块为类变量指定初始值</li></ul><p><strong>结束生命周期</strong></p><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li>执行了 <code>System.exit()</code>方法</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><strong>定义</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;什么是JVM？&quot;&gt;&lt;a href=&quot;#什么是JVM？&quot; class=&quot;headerlink&quot; title=&quot;什么是JVM？&quot;&gt;&lt;/a&gt;什么是JVM？&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;百度词条：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机)，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;本篇着重介绍一下Java的类加载机制：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://codeyg.top/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://codeyg.top/tags/Java/"/>
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--HashMap红黑树</title>
    <link href="https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://codeyg.top/2021/06/13/%E9%9D%A2%E8%AF%95--HashMap%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2021-06-13T13:58:58.000Z</published>
    <updated>2021-06-14T17:06:03.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 HashMap为什么用红黑树：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>上文说到，HashMap的扩容原理。</p><p>JDK1.7 使用的是 <strong>数组 + 单链表</strong> 的数据结构。</p><p>JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。</p><p>当阈值是默认阈值 <strong>0.75</strong>，链表的深度大于等于 <strong>8</strong>，数组容量大于等于 <strong>64</strong> 时，扩容的时候会把链表转成红黑树，时间复杂度从 <strong>O(n)</strong> 变成 <strong>O(logN)</strong>；当红黑树的节点深度小于等于 <strong>6</strong> 时，红黑树会转为<strong>链表结构</strong>。</p><p><strong><font color=#008000>在Java8中为什么要使用红黑树来实现的HashMap？</font></strong></p><p>答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）</p><a id="more"></a><h4 id="什么是红黑树呢？"><a href="#什么是红黑树呢？" class="headerlink" title="什么是红黑树呢？"></a>什么是红黑树呢？</h4><p>别急，先来回顾一下什么是二叉树！</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>简单地理解，满足以下两个条件的树就是二叉树：</p><ol><li>本身是有序树；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><blockquote><p>二叉树还可以继续分类，衍生出<strong>满二叉树</strong>和<strong>完全二叉树</strong>。</p></blockquote><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为<strong>满二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-34-34.898Z.png" alt=""></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为<strong>完全二叉树</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-35-38.517Z.png" alt=""></p><center>完全二叉树</center><hr><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T15-36-27.077Z.png" alt=""></p><center>非完全二叉树</center><hr><p>好了说完二叉树相关的知识后，还没有引入红黑树，因为在不断优化的过程中还是需要慢慢来，回顾一下平衡二叉树（AVL Tree）。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T12-57-32.630Z.png" style="zoom:67%;" /><p>对二叉树的节点进行查找发现深度为 1 的节点的查找次数为 1，深度为2的查找次数为 2，深度为n的节点的查找次数为n，因此其平均查找次数为  (1+2+2+3+3+3) / 6 = 2.3 次</p><p>当然上面是理想的情况，因为二叉查找树可以任意地构造，同样是 2,3,5,6,7,8 这六个数字，也可以按照下图的方式来构造。</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-03-36.302Z.png" style="zoom:67%;" /><p>但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树，或称 AVL 树。</p><h4 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h4><p>平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。</p><p>AVL树，它的任何节点的两个子树的高度差&lt;=1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-13-21.964Z.png" style="zoom: 67%;" /><center>AVL树</center><p>不是AVL树，其根节点的左子树高度为3，而右子树高度为1；</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T13-15-54.465Z.png" style="zoom:67%;" /><center>非AVL树</center><p>至此，引出红黑树(弱平衡二叉树)</p><h4 id="红黑树-弱平衡二叉树"><a href="#红黑树-弱平衡二叉树" class="headerlink" title="红黑树(弱平衡二叉树)"></a>红黑树(弱平衡二叉树)</h4><p>红黑树也属于平衡二叉树，但在每个节点增加一个存储位表示节点的颜色，非红即黑。</p><p>红黑树的英文是“Red-Black Tree”，简称R-B Tree。它是一种不严格的平衡二叉查找树，我前面说了，它的定义是不严格符合平衡二叉查找树的定义的。</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>从性质5又可以推出：<strong>如果一个结点存在黑子结点，那么该结点肯定有两个子结点</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-37-06.560Z.png" style="zoom:80%;" /><hr><h4 id="B树（Balance-Tree）"><a href="#B树（Balance-Tree）" class="headerlink" title="B树（Balance-Tree）"></a>B树（Balance-Tree）</h4><p><strong>B树是一颗多路平衡查找树</strong></p><p>它类似普通的平衡二叉树，不同的一点是B 树允许每个节点有更多的子节点。</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T14-44-46.777Z.png" alt=""></p><p>B 树有如下特点:</p><ol><li>所有键值分布在整颗树中（索引值和具体data都在每个节点里）；</li><li>任何一个关键字出现且只出现在一个结点中；</li><li>搜索有可能在非叶子结点结束（最好情况 O(1) 就能找到数据）；</li><li>在关键字全集内做一次查找,性能逼近二分查找；</li></ol><p><strong>B 树是专门为外部存储器设计的</strong>。如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。</p><p><strong>B 树允许每个节点有更多的子节点即可（多叉树）</strong>。子节点数量一般在上千，具体数量依赖外部存储器的特性。</p><h4 id="B-树（-Balance-Tree）"><a href="#B-树（-Balance-Tree）" class="headerlink" title="B+树（ Balance+Tree）"></a>B+树（ Balance+Tree）</h4><p><strong>B+Tree是在B Tree基础上的一种优化</strong>，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p><p>B+Tree相对于B Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li><strong>数据记录都存放在叶子节点中</strong>；（查询时间复杂度固定为 log n）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-14T16-41-28.142Z.png" alt=""></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种<strong>链式环结构</strong>。</p><p>咋一看 B+ 树好像查询要比 B 树慢一些（同样的数据，查询【IO】次数变多了），但是是事实如此吗？</p><p>根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。</p><p>B+ 树可以很好的利用局部性原理，若我们访问节点 key为 80，则 key 为 79、83、87的节点将来也可能被访问，<strong>磁盘预读原理</strong>就会提前把这些数据都读进内存，使得范围查询和排序都很快，从而减少了磁盘 IO 的次数。</p><p>由于B树的节点都存了 key 和 data ，而 B+ 树只有叶子节点存 data，非叶子节点都只是索引值，没有实际的数据，这就时 B+ 树在一次IO里面，能读出的索引值更多。从而减少查询时候需要的IO次数！</p><p>B+ 树优势：</p><ol><li>B+ 树叶节点两两相连可大大增加区间访问性；</li><li>B+ 树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确；</li></ol><h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p><strong><font color=#008000>MySQL 为什么使用 B Tree（B+Tree）存储？</font></strong></p><p>这就是下篇博客要着重介绍的东西咯~</p><p>我好像发现通过一个 hashmap 能够牵扯出一连串的知识啊！</p><p>这可能就是它的知识体系吧，正如我们在面试的过程中，面试官通过一个”点“，问着问着就问出来一个“面”。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 HashMap为什么用红黑树：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;上文说到，HashMap的扩容原理。&lt;/p&gt;
&lt;p&gt;JDK1.7 使用的是 &lt;strong&gt;数组 + 单链表&lt;/strong&gt; 的数据结构。&lt;/p&gt;
&lt;p&gt;JDK1.8 及之后时，使用的是数组+链表+红黑树的数据结构。&lt;/p&gt;
&lt;p&gt;当阈值是默认阈值 &lt;strong&gt;0.75&lt;/strong&gt;，链表的深度大于等于 &lt;strong&gt;8&lt;/strong&gt;，数组容量大于等于 &lt;strong&gt;64&lt;/strong&gt; 时，扩容的时候会把链表转成红黑树，时间复杂度从 &lt;strong&gt;O(n)&lt;/strong&gt; 变成 &lt;strong&gt;O(logN)&lt;/strong&gt;；当红黑树的节点深度小于等于 &lt;strong&gt;6&lt;/strong&gt; 时，红黑树会转为&lt;strong&gt;链表结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;font color=#008000&gt;在Java8中为什么要使用红黑树来实现的HashMap？&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答：好处就是避免在最极端的情况下冲突链表变得很长很长，在查询的时候，效率会非常慢。（单向链表）&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="HashMap" scheme="https://codeyg.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>排序总结（Sort Algorithm）</title>
    <link href="https://codeyg.top/2021/06/12/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/"/>
    <id>https://codeyg.top/2021/06/12/%E6%8E%92%E5%BA%8F--%E6%80%BB%E7%BB%93/</id>
    <published>2021-06-12T15:58:58.000Z</published>
    <updated>2021-06-14T17:10:34.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重为排序做个总结：</strong></p><hr><h4 id="什么是排序算法？"><a href="#什么是排序算法？" class="headerlink" title="什么是排序算法？"></a>什么是排序算法？</h4><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。</p><a id="more"></a><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_conclusion.jpg" style="zoom:67%;" /><h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/sort_all_photo.png" style="zoom: 67%;" /><h4 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h4><ul><li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面 （相等不交换位置）；</li><li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面（相等交换位置）；</li><li><strong>内排序</strong>：所有排序操作都在内存中完成；</li><li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间；</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小；</li></ul><h4 id="比较和非比较的区别"><a href="#比较和非比较的区别" class="headerlink" title="比较和非比较的区别"></a>比较和非比较的区别</h4><p><font color=#FF8C00>快速排序、归并排序、堆排序、冒泡排序  </font>等属于 <font color=#008000>比较排序</font></p><p><font color=#FF8C00>计数排序、基数排序、桶排序 </font> 则属于  <font color=#FF0000>非比较排序</font></p><p>比较排序：在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置</p><p>非比较排序：非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置</p><h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><ul><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3)</li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1691302-20191103200642835-1582365806.png" alt=""></p><p>常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜ Ο(2n) ，随着问题规模 n 的不断增大，上述<strong>时间复杂度不断增大，算法的执行效率越低</strong></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重为排序做个总结：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;什么是排序算法？&quot;&gt;&lt;a href=&quot;#什么是排序算法？&quot; class=&quot;headerlink&quot; title=&quot;什么是排序算法？&quot;&gt;&lt;/a&gt;什么是排序算法？&lt;/h4&gt;&lt;p&gt;排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="排序总结" scheme="https://codeyg.top/tags/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>每日一面--HashMap原理</title>
    <link href="https://codeyg.top/2021/06/12/%E9%9D%A2%E8%AF%95--HashMap/"/>
    <id>https://codeyg.top/2021/06/12/%E9%9D%A2%E8%AF%95--HashMap/</id>
    <published>2021-06-12T13:58:58.000Z</published>
    <updated>2021-06-14T17:06:45.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇 Java 小知识</p></blockquote><p><strong>本篇着重介绍一下 HashMap：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>众所周知，HashMap 是一个用于存储 <strong>Key-Value</strong> 键值对的集合，每一个键值对也叫做 <strong>Entry</strong>。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是 HashMap 的主干。</p><p><strong>画个重点：</strong></p><p><font color=#008000><strong>Hash的公式 —&gt;  index = HashCode（Key） &amp; （Length - 1）</strong></font></p><p><strong>HashMap 的数据结构两种：数组 + 链表</strong></p><ul><li>数组：查询速度快，可以根据索引查询；但插入和删除比较困难；</li><li>链表：查询速度慢，需要遍历整个链表，但插入和删除操作比较容易;</li><li>HashMap 是数组和链表组成的，数据结构中又叫“链表散列”;</li></ul><a id="more"></a><h4 id="HashMap特点"><a href="#HashMap特点" class="headerlink" title="HashMap特点"></a>HashMap特点</h4><ol><li>快速存储 ：比如当我们对 hashmap 进行 get 和 put 的时候速度非常快</li><li>快速查找（时间复杂度o(1)）当我们通过key去get一个 value 的时候时间复杂度非常的低，<strong>效率非常高</strong></li><li>可伸缩：(1) 数组扩容，边长；(2) 单线列表如果长度超过 <strong>8</strong> 的话会变成红黑树</li></ol><h4 id="HashMap的扩容原理"><a href="#HashMap的扩容原理" class="headerlink" title="HashMap的扩容原理"></a>HashMap的扩容原理</h4><p>HashMap 数组每一个元素的初始值都是 Null；</p><p>对于 HashMap，我们最常使用的是两个方法：<strong>Get</strong> 和 <strong>Put</strong> （获取和添加）</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614000934162.png" alt=""></p><h5 id="1-Put方法的原理"><a href="#1-Put方法的原理" class="headerlink" title="1.Put方法的原理"></a>1.Put方法的原理</h5><p>调用 Put 方法的时候发生了什么呢？</p><p>比如调用 hashMap.put(“apple”, 0) ，插入一个 Key 为 “apple” 的元素。这时候我们需要利用一个哈希函数来确定Entry的插入位置（index）：</p><p><strong>index = Hash（“apple”）</strong></p><p>假定最后计算出的index是2，那么结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-10-29.609Z.png" alt=""></p><p>但是，因为 HashMap 的长度是有限的，当插入的 Entry 越来越多时，再完美的 Hash 函数也难免会出现 <strong>index冲突</strong>的情况。比如下面这样：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T17-26-02.319Z.png" alt=""></p><p>HashMap数组的每一个元素不止是一个 <strong>Entry 对象</strong>，也是一个链表的<strong>头节点</strong>。每一个Entry对象通过 <strong>Next指针</strong>指向它的下一个 <strong>Entry节点</strong>。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表即可：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T17-26-37.073Z.png" alt=""></p><blockquote><p>当前采用的是 jdk 7 默认方法，也就是头插法</p></blockquote><h5 id="2-Get方法的原理"><a href="#2-Get方法的原理" class="headerlink" title="2.Get方法的原理"></a>2.Get方法的原理</h5><p><font color=#008000>使用Get方法根据Key来查找Value的时候，发生了什么呢？</font></p><p>首先会把输入的 Key 做一次 Hash 映射，得到对应的 index：</p><p><strong>index = Hash（“apple”）</strong>  <strong>=&gt;</strong>   <strong>index = 2</strong></p><p>由于刚才所说的 Hash 冲突，同一个位置有可能匹配到多个 Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的 Key 是 <strong>“apple”</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-02-40.117Z.png" alt=""></p><ul><li>第一步，我们查看的是头节点 Entry6，<strong>Entry6</strong> 的 Key 是 <strong>banana</strong>，显然不是我们要找的结果。</li><li>第二步，我们查看的是 Next 节点 Entry1，<strong>Entry1</strong> 的 Key 是 <strong>apple</strong>，正是我们要找的结果。</li></ul><blockquote><p>之所以把 Entry6 放在头节点，是因为 HashMap 的发明者认为，<strong>后插入的 Entry 被查找的可能性更大</strong>。</p></blockquote><hr><h5 id="HashMap-尾插法"><a href="#HashMap-尾插法" class="headerlink" title="HashMap 尾插法"></a>HashMap 尾插法</h5><p>上面提到过 hashmap 添加采用的是 jdk 7 默认方法（头插法），那一定时有原因的呀！</p><p>当来到 jdk 8 的时候改成尾插法了，why？</p><p><font color=#008000>来看看Node的源码</font></p><p>每一个节点都会保存自身的 <strong>hash</strong>、<strong>key</strong>、<strong>value</strong> 以及下个<strong>Next</strong>（节点）</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/carbon_node6-14.png" style="zoom: 50%;" /><p><strong>java8之前是头插法</strong>，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。</p><p>但是，<strong>在java8之后，都是所用尾部插入了。</strong></p><p><font color=#008000>为啥改为尾部插入呢？</font></p><p>答：数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。</p><p><font color=#008000>什么时候resize呢？</font></p><p>答：</p><ol><li>有两个因素：</li></ol><ul><li>Capacity：HashMap当前长度 【list.length()】</li><li>LoadFactor：负载因子，默认值0.75f 【3/4】</li></ul><blockquote><p>比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容</p></blockquote><ol start="2"><li>分为两步：</li></ol><ul><li>扩容：创建一个新的 Entry 空数组，长度是原数组的 2 倍。</li><li>ReHash：遍历原 Entry 数组，把所有的Entry重新 Hash 到新数组。</li></ul><p><font color=#008000>为什么不直接复制过去？</font></p><p>答：是因为长度扩大以后，Hash的规则也随之改变。</p><p>（原来长度（Length）是 8 你位运算出来的值是 2 ，新的长度是 16 你位运算出来的值明显不一样了）</p><blockquote><p>Hash的公式 —&gt;  index = HashCode（Key） &amp; （Length - 1）</p></blockquote><p>扩容前：</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-29-38.438Z.png" alt=""></p><p>扩容后： </p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-30-05.405Z.png" alt=""></p><p>现在我们要在容量为2的容器里面<strong>用不同线程</strong>插入 A，B，C</p><p>我们可以看到链表的指向 A =&gt; B =&gt; C</p><p><strong>Tip：A的下一个指针是指向B的</strong></p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-41-18.300Z.png" style="zoom:80%;" /><p>因为resize的赋值方式，也就是使用了<strong>单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置</strong>，在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p><p>所以：可能会出现 B 的下一个指针指向了 A</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-47-33.913Z.png" style="zoom:80%;" /><p>一旦几个线程都调整完成，就可能出现<strong>环形链表</strong>！</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T18-49-53.769Z.png" style="zoom:80%;" /><p>这个时候去取值,会出现 <strong>Infinite Loop</strong></p><hr><p>来到 jdk 8 链表有红黑树代码已经多了很多if else的逻辑判断了，红黑树的引入巧妙的将原本 O(n) 的时间复杂度降低到了 O(logn)。</p><p>好处：如果<strong>使用尾插</strong>，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了。</p><p>就是说原本是 A =&gt; B ，在扩容后那个链表还是 A =&gt; B </p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/%E7%81%AB%E7%8B%90%E6%88%AA%E5%9B%BE_2021-06-13T19-42-46.501Z.png" style="zoom: 80%;" /><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><p>Java 7 在多线程操作 HashMap 时可能引起死循环，原因是扩容转移后前后链表顺序倒置，在转移过程中修改了原来链表中节点的引用关系。</p></li><li><p>Java 8 在同样的前提下并不会引起死循环，原因是扩容转移后前后链表顺序不变，保持之前节点的引用关系。</p></li></ul><p>即使如此 Java 8 也是不建议把 HashMap 用在多线程中。</p><p>因为无法保证上一秒 put 的值，下一秒 get 的时候还是原值，所以线程安全还是无法保证。</p><hr><h5 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h5><p><font color=#008000>HashMap的默认初始化长度是多少？</font></p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614031720500.png" alt=""></p><p>走，源码中找答案去</p><p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/image-20210614031914998.png" alt=""></p><p><strong>在 JDK1.8 的 236 行有 1&lt;&lt;4 就是 16</strong> （逻辑左移 4 位）</p><p>现在回过头来再看一下，重写 equals 方法的时候需要重写 hashCode 方法</p><ul><li>如果两个对象的 hash 值相同，那么这两个对象并不一定是相同；</li><li>如果两个对象的相同，那么这两个对象的 hash 值一定是相同；</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇 Java 小知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下 HashMap：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;众所周知，HashMap 是一个用于存储 &lt;strong&gt;Key-Value&lt;/strong&gt; 键值对的集合，每一个键值对也叫做 &lt;strong&gt;Entry&lt;/strong&gt;。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是 HashMap 的主干。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;画个重点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=#008000&gt;&lt;strong&gt;Hash的公式 —&amp;gt;  index = HashCode（Key） &amp;amp; （Length - 1）&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HashMap 的数据结构两种：数组 + 链表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组：查询速度快，可以根据索引查询；但插入和删除比较困难；&lt;/li&gt;
&lt;li&gt;链表：查询速度慢，需要遍历整个链表，但插入和删除操作比较容易;&lt;/li&gt;
&lt;li&gt;HashMap 是数组和链表组成的，数据结构中又叫“链表散列”;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="HashMap" scheme="https://codeyg.top/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--桶排序（Bucket Sort）</title>
    <link href="https://codeyg.top/2021/06/11/%E6%8E%92%E5%BA%8F--%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/11/%E6%8E%92%E5%BA%8F--%E6%A1%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-11T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:42.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下桶排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>桶排序：</strong></p><ul><li>时间复杂度：<code>O(n)</code></li><li>空间复杂度：<code>O(n)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的<strong>桶子</strong>里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。就像是分不同的桶，在桶内再排序。</p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>找出待排序数组中的最大值<strong>max</strong>、最小值<strong>min</strong>;</li><li>我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1;</li><li>遍历数组 arr，计算每个元素 arr[i] 放的桶;</li><li>每个桶各自排序;</li><li>遍历桶数组，把排序好的元素放进输出数组;</li></ol><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/firefox-2021-06-13T06-30-18.291Z.png" style="zoom: 80%;" /><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分别定义 arr 的最大值和最小值 (默认 arr 中首个元素为最小值)</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过遍历数组寻找到最大值和最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//桶数 (最大值-最小值)/数组长度+1</span></span><br><span class="line">        <span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据计算出来桶子个数来创建桶子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">            bucketArr.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据桶子数值范围，将每个元素放入相应的桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">            bucketArr.get(num).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            Collections.sort(bucketArr.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新数组</span></span><br><span class="line">        ArrayList&lt;Integer&gt; newArr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++) &#123;</span><br><span class="line">                newArr.add(bucketArr.get(i).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"每个桶内："</span> + bucketArr.toString());</span><br><span class="line">        System.out.println(<span class="string">"新数组："</span> + newArr.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        bucketSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个桶内：[[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>], [<span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>], [<span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>], [<span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]]</span><br><span class="line">新数组：[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>可以看出，在<strong>分桶</strong>和<strong>从桶</strong>依次输出的过程是稳定的。但是，由于我们在对每个桶进行排序时使用了其他算法，所以，桶排序的稳定性依赖于这一步。如果我们使用了快排，显然，算法是<strong>不稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>桶排序可用于最大最小值相差较大的数据情况，但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。</p><p>最差的情况就是数据过于集中从而导致都放在一个或者某几个桶中。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下桶排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;桶排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的&lt;strong&gt;桶子&lt;/strong&gt;里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。就像是分不同的桶，在桶内再排序。&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="桶排序" scheme="https://codeyg.top/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--归并排序（Merge Sort）</title>
    <link href="https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/10/%E6%8E%92%E5%BA%8F--%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-10T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:19.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下归并排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>归并排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(n)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于<strong>快速排序</strong>，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif" target="_blank" rel="noopener">归并排序动图演示</a></p><p><a href="https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp" target="_blank" rel="noopener">递归法动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p><strong>归并排序是用分治思想</strong></p><ol><li><strong>分解（Divide）</strong>：将n个元素分成个含n/2个元素的子序列。</li><li><strong>解决（Conquer）</strong>：用合并排序法对两个子序列递归的排序。</li><li><strong>合并（Combine）</strong>：合并两个已排序的子序列已得到排序结果。</li></ol><p><strong>递归法</strong></p><ul><li>① 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li><li>② 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li><li>③ 重复步骤②，直到所有元素排序完毕</li></ul><p><strong>总结：</strong>先分组，再归并</p><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/1557906108-5066-20161218163120151-452283750.png" style="zoom: 33%;" /><hr><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp =<span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        internalMergeSort(arr, temp, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalMergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当left==right的时，已经不需要再划分了</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左子数组</span></span><br><span class="line">            internalMergeSort(arr, temp, left, middle);</span><br><span class="line">            <span class="comment">//右子数组</span></span><br><span class="line">            internalMergeSort(arr, temp, middle+<span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">//合并两个子数组</span></span><br><span class="line">            mergeSortedArray(arr, temp, left, middle, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序子序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortedArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] temp, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=left;</span><br><span class="line">        <span class="keyword">int</span> j=middle+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=middle &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;=middle)&#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( j&lt;=right)&#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把数据复制回原数组</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;k; ++i)&#123;</span><br><span class="line">            arr[left+i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        merge_sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>因为我们在遇到相等的数据的时候必然是按顺序“复刻”到辅助数组temp[]上的，所以，归并排序同样是<strong>稳定</strong>算法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>归并排序在数据量比较大的时候也有较为出色的表现（效率上），但是，其空间复杂度O(n)使得在数据量特别大的时候（例如，1千万数据）几乎不可接受。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;归并排序，是创建在归并操作上的一种有效的排序算法。算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。归并排序思路简单，速度仅次于&lt;strong&gt;快速排序&lt;/strong&gt;，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/mergeSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;归并排序动图演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic4.zhimg.com/v2-a29c0dd0186d1f8cef3c5ebdedf3e5a3_b.webp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;递归法动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="归并排序" scheme="https://codeyg.top/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--堆排序（Heap Sort）</title>
    <link href="https://codeyg.top/2021/06/09/%E6%8E%92%E5%BA%8F--%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/09/%E6%8E%92%E5%BA%8F--%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-09T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:11.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下堆排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>堆排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code><ul><li>初始化建堆：<code>O(n)</code></li><li>排序重建堆: <code>nlog(n)</code></li></ul></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示，每一个结点对应数组中的一个元素。利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" target="_blank" rel="noopener">堆排序动图演示1</a></p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" target="_blank" rel="noopener">堆排序动图演示2</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点；</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆；</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变；</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="什么是堆？"><a href="#什么是堆？" class="headerlink" title="什么是堆？"></a>什么是堆？</h5><p>堆一般指的是二叉堆，顾名思义，二叉堆是完全二叉树或者近似完全二叉树</p><h5 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h5><ul><li>是一棵完全二叉树</li><li>每个节点的值都大于或等于其子节点的值，为最大堆；反之为最小堆。</li></ul><h5 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h5><p>一般用数组来表示堆，下标为 i 的结点的父结点下标为(i-1)/2；其左右子结点分别为 (2i + 1)、(2i + 2)</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  第一步：将数组堆化</span></span><br><span class="line"><span class="comment">         *  beginIndex = 第一个非叶子节点。</span></span><br><span class="line"><span class="comment">         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeapify(i, len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二步：对堆化数据排序</span></span><br><span class="line"><span class="comment">         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">         * 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(<span class="number">0</span>, i);</span><br><span class="line">            maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len   未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点索引</span></span><br><span class="line">        <span class="keyword">int</span> ri = li + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line">        <span class="keyword">int</span> cMax = li;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (li &gt; len) &#123;</span><br><span class="line">            <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">        <span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) &#123;</span><br><span class="line">            cMax = ri;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">            <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">            swap(cMax, index);</span><br><span class="line">            <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">            maxHeapify(cMax, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试用例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> HeapSort(arr).sort();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>堆排序存在大量的筛选和移动过程，属于<strong>不稳定</strong>的排序算法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。</p><p>堆排序操作过程中其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下堆排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;堆排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;初始化建堆：&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;排序重建堆: &lt;code&gt;nlog(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;堆是一种特殊的完全二叉树（complete binary tree）。完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示，每一个结点对应数组中的一个元素。利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;堆排序动图演示1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;堆排序动图演示2&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="选择排序" scheme="https://codeyg.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--选择排序（Selection Sort）</title>
    <link href="https://codeyg.top/2021/06/08/%E6%8E%92%E5%BA%8F--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/08/%E6%8E%92%E5%BA%8F--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-08T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:57.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下选择排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>选择排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif" target="_blank" rel="noopener">选择排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li><p>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</p></li><li><p>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p><p><strong>基本思路：</strong></p></li></ol><ul><li>外循环：循环每个位置（其实就是选择了这个位置，然后用内循环去选择一个合适的数，放到这个位置）；</li><li>内循环：在无序元素中选择一个合适的数；</li><li>把第二步选中的数据放到第一步选中的位置上就可以了；</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序法，外层循环控制所需找到最小值的次数，内层循环来寻找目标值后面比目标值小的元素，进行下标更新</span></span><br><span class="line"><span class="comment"> * 每次找到后，都将其放倒前面，与冒泡排序恰恰相反。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//外层循环控制所需找到最小值的次数,挖坑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = i;</span><br><span class="line">            <span class="comment">//内层循环来寻找目标值后面比目标值小的元素，准备填坑</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">//下标更新</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[index]) &#123;</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填坑</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">            arr[index] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        selectSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>用数组实现的选择排序是<strong>不稳定</strong>的，用链表实现的选择排序是<strong>稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是<strong>优于冒泡排序</strong>的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下选择排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;选择排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;选择排序是一种简单直观的排序算法，它也是一种交换排序算法，和冒泡排序有一定的相似度，可以认为选择排序是冒泡排序的一种改进。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;选择排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="选择排序" scheme="https://codeyg.top/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--希尔排序（Shell Sort）</title>
    <link href="https://codeyg.top/2021/06/07/%E6%8E%92%E5%BA%8F--%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/07/%E6%8E%92%E5%BA%8F--%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-07T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:49.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下希尔排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>希尔排序：</strong></p><ul><li>时间复杂度：当增量（<strong>gap</strong> ）为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为<code>O(N²)</code>，而Hibbard增量的希尔排序的时间复杂度为<code>O(N3/2)</code>。</li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>插入排序是效率低下是因为其移动元素每次只能移动一位，当排序元素的规模较大时，需要将元素一位一位地从一端移动到另一端。希尔排序正是基于此原理来优化、提高插入排序的效率。通过指定步长step，将原数组分为step个互相独立子数组，然后通过插入排序对这些子数组分别进行排序(即分组排序)，这时我们称其为<strong>step有序数组</strong>。当step最终为<strong>1</strong>做最后一次step有序时，就是我们平常所熟悉的插入排序了，由于该数组已经多次被较大的step进行分组排序了，此时只需要较少次数的元素移动就可以实现整个数组全局有序。</p><p><a href="https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp" target="_blank" rel="noopener">希尔排序动图演示</a></p><a id="more"></a><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/11ba6646605ae3996ede9ab2f0f6ae9b.jpg" style="zoom: 67%;" /><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>按照一定的<strong>增量 gap</strong> ，先将待排序表分割成若干个特殊子表，首个gap取值为数组长度一半（地板除）；</li><li>对于各个子表，进行<strong>直接插入排序</strong>；</li><li>随后 <strong>缩小 gap</strong> ，重复上述过程，直到 gap = 1 为止。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//增量每次都/2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> step = arr.length / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从增量那组开始进行插入排序，直至完毕</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = step; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//得到分组下标对应的值</span></span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="comment">//临时变量，用于保存步长下标值</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// j - step 就是代表与它同组隔壁的元素,如果分组前面大于后面的</span></span><br><span class="line">                <span class="keyword">while</span> (j - step &gt;= <span class="number">0</span> &amp;&amp; arr[j - step] &gt; temp) &#123;</span><br><span class="line">                    <span class="comment">//将分组前面的值赋给后面的</span></span><br><span class="line">                    arr[j] = arr[j - step];</span><br><span class="line">                    <span class="comment">//下标减去步长，来到分组前面的下标</span></span><br><span class="line">                    j -= step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果分组之间有过交换，那么将分组后面的值发给分组前面的值</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        shellSort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，</p><p>但在不同的插入排序过程中，<strong>相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱</strong>。</p><p>所以 希尔shell排序是<strong>不稳定</strong>的。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li><p>Shell排序虽然快，但是毕竟是插入排序，其数量级并没有<strong>快速排序</strong>O(n㏒n)快；</p></li><li><p>Shell排序在大量数据面前不是一个好的算法，但是，中小型规模的数据完全可以使用它；</p></li><li><p>希尔排序只是适用于<strong>线性表为顺序存储</strong>的i情况，<strong>不适用于链表</strong>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下希尔排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;希尔排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：当增量（&lt;strong&gt;gap&lt;/strong&gt; ）为1时，希尔排序退化成了直接插入排序，此时的时间复杂度为&lt;code&gt;O(N²)&lt;/code&gt;，而Hibbard增量的希尔排序的时间复杂度为&lt;code&gt;O(N3/2)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;插入排序是效率低下是因为其移动元素每次只能移动一位，当排序元素的规模较大时，需要将元素一位一位地从一端移动到另一端。希尔排序正是基于此原理来优化、提高插入排序的效率。通过指定步长step，将原数组分为step个互相独立子数组，然后通过插入排序对这些子数组分别进行排序(即分组排序)，这时我们称其为&lt;strong&gt;step有序数组&lt;/strong&gt;。当step最终为&lt;strong&gt;1&lt;/strong&gt;做最后一次step有序时，就是我们平常所熟悉的插入排序了，由于该数组已经多次被较大的step进行分组排序了，此时只需要较少次数的元素移动就可以实现整个数组全局有序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.webp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;希尔排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="插入排序" scheme="https://codeyg.top/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--插入排序（Insert Sort）</title>
    <link href="https://codeyg.top/2021/06/06/%E6%8E%92%E5%BA%8F--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/06/%E6%8E%92%E5%BA%8F--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-06T13:58:58.000Z</published>
    <updated>2021-06-14T17:11:08.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版本）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下插入排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>插入排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即：每次确定要排序的元素并将其与之前<strong>已排好序的元素</strong>进行插入。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif" target="_blank" rel="noopener">插入排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>把待排序的数组分成<strong>已排序</strong>和<strong>未排序</strong>两部分，初始的时候把第一个元素认为是已排好序的；</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置；</li><li>重复上述过程直到最后一个元素被插入有序子数组中。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序:外层循环控制每次索要插入的元素（定义一个待插入的数），再定义一个待插入数的前一个数的下标，内层循环比较插入数字</span></span><br><span class="line"><span class="comment"> * 与前一个数字之间的大小比较，如果待插入数的前一个数大于本次索要插入的元素，那么将前一个元素的值赋值给本次插入值的位置，</span></span><br><span class="line"><span class="comment"> * 继续向前比较，知道找到前面的元素之都比插入元素值小的位置，在跳出内层循环，执行外层循环。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//定义待插入的数</span></span><br><span class="line">            <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line">            <span class="comment">//找到待插入数的前一个数的下标</span></span><br><span class="line">            <span class="keyword">int</span> insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; arr[insertIndex] &gt; insertVal) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">36</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">50</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>由于只需要找到不大于当前数的位置而并不需要交换，因此，直接插入排序是<strong>稳定的</strong>排序方法。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>插入排序由于O( n2 )的复杂度，在<strong>数组较大</strong>的时候不适用。</p><p>但是，在数据比较少的时候，是一个不错的选择，一般做为快速排序的扩充。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版本）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下插入排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;插入排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。即：每次确定要排序的元素并将其与之前&lt;strong&gt;已排好序的元素&lt;/strong&gt;进行插入。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/insertionSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插入排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="插入排序" scheme="https://codeyg.top/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--快速排序（Quick Sort）</title>
    <link href="https://codeyg.top/2021/06/05/%E6%8E%92%E5%BA%8F--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/05/%E6%8E%92%E5%BA%8F--%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-05T13:58:58.000Z</published>
    <updated>2021-06-14T17:12:27.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下快速排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>快速排序：</strong></p><ul><li>时间复杂度：<code>O(nlogn)</code></li><li>空间复杂度：<code>O(logn)</code></li><li>稳定性：<font color=#FF0000>不稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p><strong>快排</strong>的性能在所有排序算法里面是<strong>最好</strong>的排序算法。数据规模越大快速排序的性能越优。快排在极端情况下会退化成 <code>O(n2)</code> 的算法，因此假如在提前得知处理数据可能会出现极端情况的前提下，可以选择使用较为稳定的<strong>归并排序</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" target="_blank" rel="noopener">快速排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>快排运用了二分的思想:</p><ul><li>首先从数列中挑出一个元素基准<code>pivot</code>；</li><li>定义左右两端指针。先从右往左进行扫描，如果 R[right] &lt; pivot，将R[right]移动至left所在位置，从左往右进行扫描，否则right前移；如果 R[left] &gt; pivot，将R[left]移动到right所在位置上，否则left后移。左右端指针在排序过程中从数组的两端往中间进行靠近；</li><li>直到 right == left （重合），该基准<code>pivot</code>就处于数列的中间位置，这个称为分区（partition）操作；</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。直到划分的区间最后长度仅为1。</li></ul><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</span></span><br><span class="line"><span class="comment"> * 从数列中挑出一个元素，称为 “基准”（pivot）；</span></span><br><span class="line"><span class="comment"> * 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</span></span><br><span class="line"><span class="comment"> * 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果左边指针小于右边指针</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * i:表示左边指针</span></span><br><span class="line"><span class="comment">             * j:表示右边指针</span></span><br><span class="line"><span class="comment">             * pivot:表示基准值（一般取分区的首个值）</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> i = left, j = right, pivot = arr[left];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="comment">// 从右向左找第一个小于x的数，如果右侧指针所指向的值大于基准pivot，指针前移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果右侧指针所指向的值小于基准pivot，交换右侧指针所指向的值与左侧指针所指向的值，并且左侧指针后移</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    arr[i++] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从左向右找第一个大于等于x的数，如果左侧指针所指向的值小于基准pivot，指针后移</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt; pivot) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果左侧指针所指向的值大于基准pivot，交换左侧指针所指向的值与右侧指针所指向的值，并且右侧指针前移</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    arr[j--] = arr[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = pivot;</span><br><span class="line">            <span class="comment">// 递归调用左子数组</span></span><br><span class="line">            quick_sort(arr, left, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归调用右子数组</span></span><br><span class="line">            quick_sort(arr, i + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        quick_sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//打印快速排序后的数组</span></span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>快速排序并<strong>不是稳定的</strong>。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>快速排序在大多数情况下都是适用的，尤其在<strong>数据量大</strong>的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>最差情况：O(n2)</li></ul><p>最差情况是，每次我们在划分时，所取的基准总是数组中最小的，因此我们总共会进行n-1次划分，且在第i次划分时，区间长度为：n-i+1 ,需要进行n-i比较。</p><p>故：</p><p><img src="https://www.zhihu.com/equation?tex=C_%7Bmax%7D%3D%5Csum_%7Bi+%3D1%7D%5E%7Bn-1%7D%7Bn-i%7D%3D%5Cfrac%7Bn%28n-1%29%7D%7B2%7D%3DO%28n%5E%7B2%7D%29" alt="[公式]"></p><ul><li>最好情况：O(nlog2n)</li></ul><p>最好的情况是，每次所取的基准就是该数组的中点，因此一共需要进行n次划分，对于 长度为n的划分空间，需要进行n-1次比较。剩下的两个无序子区间需要进行2C(n/2)的比较次数。设n=2k</p><p>故：</p><p><img src="https://www.zhihu.com/equation?tex=C%28n%29%5Cleq+n%2B2C%28%5Cfrac%7Bn%7D%7B2%7D%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleq+n%2B2%28%5Cfrac%7Bn%7D%7B2%7D%2B2C%28%5Cfrac%7Bn%7D%7B2%5E%7B2%7D%7D%29%29%3D2n%2B4C%28%5Cfrac%7Bn%7D%7B2%5E%7B2%7D%7D%29" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=%5Cleq+kn%2BnC%281%29+%3D+%5Cleq+n%5C%3Blog_%7B2%7Dn%5C%3B%2B%5C%3BnC%281%29%3DO%28nlog_%7B2%7Dn%29" alt="[公式]"></p><ul><li>平均情况：</li></ul><p>随机进行切割，最好算出复杂度还是O(nlog2n)</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(nlogn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(logn)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#FF0000&gt;不稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快排&lt;/strong&gt;的性能在所有排序算法里面是&lt;strong&gt;最好&lt;/strong&gt;的排序算法。数据规模越大快速排序的性能越优。快排在极端情况下会退化成 &lt;code&gt;O(n2)&lt;/code&gt; 的算法，因此假如在提前得知处理数据可能会出现极端情况的前提下，可以选择使用较为稳定的&lt;strong&gt;归并排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;快速排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="交换排序" scheme="https://codeyg.top/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>每日一练--冒泡排序（Bubble Sort）</title>
    <link href="https://codeyg.top/2021/06/04/%E6%8E%92%E5%BA%8F--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://codeyg.top/2021/06/04/%E6%8E%92%E5%BA%8F--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-06-04T14:58:58.000Z</published>
    <updated>2021-06-14T17:12:34.980Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每天一篇排序算法（Java版）</p></blockquote><p><strong>十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。</strong></p><p><strong>本篇着重介绍一下冒泡排序：</strong></p><hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p><strong>快速排序：</strong></p><ul><li>时间复杂度：<code>O(n²)</code></li><li>空间复杂度：<code>O(1)</code></li><li>稳定性：<font color=#008000>稳定</font></li></ul><h4 id="排序思想"><a href="#排序思想" class="headerlink" title="排序思想"></a>排序思想</h4><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。可以理解为<strong>每次都能够将最大的数字找到</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif" target="_blank" rel="noopener">冒泡排序动图演示</a></p><a id="more"></a><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><blockquote><p>第一种，也是最为常见的一种（双重循环）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外层循环来控制所需找到最大值的次数，内层循环用来比较相邻的两个值之间的大小，若前面的值大于后面的值，则两个元素之间进行位置交换。</span></span><br><span class="line"><span class="comment"> * 每次外层循环所得到的都是最大元素的位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        System.out.println("startTime = " + startTime);</span></span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//        System.out.println("endTime = " + endTime);</span></span><br><span class="line">        System.out.println(<span class="string">"time = "</span> + (endTime-startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>在相邻元素相等时，它们并不会交换位置，所以，冒泡排序是<strong>稳定排序</strong>。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>冒泡排序思路简单，代码也简单，特别<strong>适合小数据</strong>的排序。但是，由于算法复杂度较高，在数据量大的时候不适合使用。</p><hr><blockquote><p>第二种，对于外层循环的一种优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time2 = "</span> + (endTime - startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">36</span>, <span class="number">73</span>, <span class="number">82</span>, <span class="number">83</span>, <span class="number">85</span>, <span class="number">94</span>]</span><br></pre></td></tr></table></figure><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在内层循环添加一个flag默认为true（也就是默认本次不会发生元素交换），当在外层循环某次执行后，数组元素已经有序，但是外层还有循环次数的时候，flag可以跳出外层循环，缩短排序时间。</p><hr><blockquote><p>第三种，基于第二种优化方式对于内层循环的次数优化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">        <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮的初始是true</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                    <span class="comment">//有元素交换，所以不是有序，标记变为false</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//把无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    lastExchangeIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastExchangeIndex;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">15</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">73</span>, <span class="number">85</span>, <span class="number">82</span>&#125;;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        sort(array);</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time3 = "</span> + (endTime-startTime));</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在外层循环添加一个标记用来–记录最后一次交换的位置，基于对内层循环的优化基础，外层循环每次确定无序数列的边界位置，这样可以减少在无需情况下内层循环的时间。</p><hr><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p><font color=#FF8C00>在数据完全有序的时候展现出最优时间复杂度，为O(n)。其他情况下，几乎总是O(n^2 )</font></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;每天一篇排序算法（Java版）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;十种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇着重介绍一下冒泡排序：&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;快速排序：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：&lt;code&gt;O(n²)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;code&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定性：&lt;font color=#008000&gt;稳定&lt;/font&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;排序思想&quot;&gt;&lt;a href=&quot;#排序思想&quot; class=&quot;headerlink&quot; title=&quot;排序思想&quot;&gt;&lt;/a&gt;排序思想&lt;/h4&gt;&lt;p&gt;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。可以理解为&lt;strong&gt;每次都能够将最大的数字找到&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冒泡排序动图演示&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="排序算法" scheme="https://codeyg.top/categories/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="交换排序" scheme="https://codeyg.top/tags/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试题（Java基础）</title>
    <link href="https://codeyg.top/2021/05/29/%E9%9D%A2%E8%AF%95%E9%A2%98ing/"/>
    <id>https://codeyg.top/2021/05/29/%E9%9D%A2%E8%AF%95%E9%A2%98ing/</id>
    <published>2021-05-29T03:58:58.000Z</published>
    <updated>2021-06-14T17:06:36.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><p><strong>1. JDK 和 JRE 有什么区别？</strong></p><ul><li>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</li><li>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</li></ul><p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p><hr><p><strong>2. == 和 equals 的区别是什么？</strong></p><a id="more"></a><p><strong>== 解读</strong></p><p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p><ul><li>基本类型：比较的是值是否相同；</li><li>引用类型：比较的是引用是否相同；</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"string"</span>;</span><br><span class="line">String y = <span class="string">"string"</span>;</span><br><span class="line">String z = <span class="keyword">new</span> String(<span class="string">"string"</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p></blockquote><p><strong>equals 解读</strong></p><p><strong>总结</strong> ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p><hr><p><strong>3. 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</strong></p><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p><hr><p><strong>4. final 在 java 中有什么作用？</strong></p><ul><li>final 修饰的类叫最终类，该类不能被继承。</li><li>final 修饰的方法不能被重写。</li><li>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</li></ul><hr><p><strong>5. java 中的 Math.round(-1.5) 等于多少？</strong></p><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃。</p><hr><p><strong>6. String 属于基础的数据类型吗？</strong></p><p>String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。</p><hr><p><strong>7. java 中操作字符串都有哪些类？它们之间有什么区别？</strong></p><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p><hr><p><strong>8. String str=”i”与 String str=new String(“i”)一样吗？</strong></p><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p><hr><p><strong>9. 如何将字符串反转？</strong></p><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StringBuffer reverse</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">stringBuffer.append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.println(stringBuffer.reverse()); <span class="comment">// gfedcba</span></span><br><span class="line"><span class="comment">// StringBuilder reverse</span></span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">stringBuilder.append(<span class="string">"abcdefg"</span>);</span><br><span class="line">System.out.println(stringBuilder.reverse()); <span class="comment">// gfedcba</span></span><br></pre></td></tr></table></figure><hr><p><strong>10. String 类的常用方法都有那些？</strong></p><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><hr><p><strong>11. 普通类和抽象类有哪些区别？</strong></p><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><hr><p><strong>12. 抽象类能使用 final 修饰吗？</strong></p><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，如下图所示，编辑器也会提示错误信息：</p><hr><p><strong>13. 接口和抽象类有什么区别？</strong></p><ul><li>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。</li><li>构造函数：抽象类可以有构造函数；接口不能有。</li><li>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。</li><li>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。</li><li>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</li></ul><hr><p><strong>14. java 中 IO 流分为几种？</strong></p><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><hr><p><strong>15. BIO、NIO、AIO 有什么区别？</strong></p><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;1. JDK 和 JRE 有什么区别？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。&lt;/li&gt;
&lt;li&gt;JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;2. == 和 equals 的区别是什么？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试篇" scheme="https://codeyg.top/categories/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
    
    
    <category term="进阶" scheme="https://codeyg.top/tags/%E8%BF%9B%E9%98%B6/"/>
    
    <category term="面试" scheme="https://codeyg.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis--基本语句</title>
    <link href="https://codeyg.top/2021/05/21/Redis--%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/"/>
    <id>https://codeyg.top/2021/05/21/Redis--%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-05-21T15:29:58.000Z</published>
    <updated>2021-06-15T17:59:31.058Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Redis-Logo.wine.png" style="zoom: 18%;" /><a id="more"></a><h4 id="key–操作数据库"><a href="#key–操作数据库" class="headerlink" title="key–操作数据库"></a>key–操作数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ 插入数据/更新key的值 <span class="built_in">set</span> key_name value </span><br><span class="line"></span><br><span class="line">$ 查询数据 get key_name</span><br><span class="line"></span><br><span class="line">$ 删除键值 del key_name </span><br><span class="line"></span><br><span class="line">$ 验证键是否存在 exists key_name</span><br><span class="line"></span><br><span class="line">$ 返回所有 key  keys *       </span><br><span class="line"></span><br><span class="line">$ 返回所有 xxx开头的 key  keys xxx*</span><br><span class="line"></span><br><span class="line">$ 设置一个 key 的过期时间(单位:秒) expire key_name 10</span><br><span class="line"></span><br><span class="line">$ 移除给定 key 的过期时间 persist key_name </span><br><span class="line"></span><br><span class="line">$ 选择数据库[0..15] select index</span><br><span class="line"></span><br><span class="line">$ 将当前数据库中的 key 转移到其它数据库中 move key_name 1 </span><br><span class="line"></span><br><span class="line">$ 返回值的类型 <span class="built_in">type</span> key_name</span><br><span class="line"></span><br><span class="line">$ 更新key的值返回原来的值 getset key_name value</span><br><span class="line"></span><br><span class="line">$ 测试连接是否存活 ping</span><br><span class="line"></span><br><span class="line">$ 返回当前数据库中 key 的数目 dbsize</span><br><span class="line"></span><br><span class="line">$ 监视--实时转储收到的请求 monitor</span><br><span class="line"></span><br><span class="line">$ 删除当前选择数据库中的所有 key flushdb</span><br><span class="line"></span><br><span class="line">$ 删除所有数据库中的所有 key flushall</span><br></pre></td></tr></table></figure><hr><h4 id="Redis数据类型–string"><a href="#Redis数据类型–string" class="headerlink" title="Redis数据类型–string"></a>Redis数据类型–string</h4><ul><li><p>string 是最简单的类型 ，一个 key 对应一个value</p></li><li><p>redis 的 string 可以包含任何数据， 比如 jpg 图片或者序列化的对象，从内部实现来看其实 string 可以看作 byte 数组，最大上限是 1G 字节。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>:插入数据/更新key的值 <span class="built_in">set</span> name dhee</span><br><span class="line"></span><br><span class="line">get:查询数据 get key_name</span><br><span class="line"></span><br><span class="line">mset:一次设置多个 key 的值 mset key1 dhc key2 jhc</span><br><span class="line"></span><br><span class="line">mget :一次获取多个 key 的值 mget key1 key2 key3</span><br><span class="line"></span><br><span class="line">setnx:如果 key 已经存在，返回 0 ,setnx name dhee</span><br><span class="line"></span><br><span class="line">setex:指定此键值对应的有效期,时间单位为秒 ,setex name 120 dhee</span><br><span class="line"></span><br><span class="line">setrange:设置指定 key 的 value 值的子字符串 ，从指定的位置开始替换字符 ,setrange name 3 @dhc.com</span><br><span class="line"></span><br><span class="line">getrange:获取指定 key 的 value 值的子字符串 getrange name 0 6</span><br><span class="line"></span><br><span class="line">** expire:设置key失效时间 expire key_name 3</span><br></pre></td></tr></table></figure><hr><h4 id="Redis-哈希-Hash"><a href="#Redis-哈希-Hash" class="headerlink" title="Redis 哈希(Hash)"></a>Redis 哈希(Hash)</h4><ul><li><p>一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p></li><li><p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hset :设置 <span class="built_in">hash</span> field 为指定值,hset myhash name dhee</span><br><span class="line"></span><br><span class="line">hget :获取指定的 <span class="built_in">hash</span> field,hget myhash name</span><br><span class="line"></span><br><span class="line">** hmset:同时设置 <span class="built_in">hash</span> 的多个 field,hmset myhash name dhee age 20</span><br><span class="line"></span><br><span class="line">** hmget :获取全部指定的 <span class="built_in">hash</span> filed,hmget myhash name age password</span><br><span class="line"></span><br><span class="line">** hlen :返回指定 <span class="built_in">hash</span> 的 field 数量,hlen myhash</span><br><span class="line"></span><br><span class="line">hdel :删除一个或多个哈希表字段,hdel myhash age</span><br><span class="line"></span><br><span class="line">hkeys:返回 <span class="built_in">hash</span> 的所有 field,hkeys myhash</span><br><span class="line"></span><br><span class="line">hvals :返回 <span class="built_in">hash</span> 的所有 value:hvals myhash</span><br><span class="line"></span><br><span class="line">hgetall :获取某个 <span class="built_in">hash</span> 中全部的 filed及value,hgetall myhash</span><br></pre></td></tr></table></figure><hr><h4 id="Redis-列表-List"><a href="#Redis-列表-List" class="headerlink" title="Redis 列表(List)"></a>Redis 列表(List)</h4><ul><li><p>简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p></li><li><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lpush:在 key 对应 list 的头部添加字符串元素 ,lpush mylist world lpush mylist hello </span><br><span class="line"></span><br><span class="line">lrange: lrange mylist 0 1</span><br><span class="line"></span><br><span class="line">** rpush :在 key 对应 list 的尾部添加字符串元素 , rpush mylist world rpush mylist hello </span><br><span class="line"></span><br><span class="line">** linsert :在 key 对应 list 的特定位置前或后添加字符串 ,linsert mylist before world dhee</span><br><span class="line"></span><br><span class="line">** lset :设置 list 中指定下标的元素值(下标从 0 开始) ,lset mylist 0 dhc</span><br><span class="line"></span><br><span class="line">`lrem` :从 key 对应 list 中删除 count 个和 value 相同的元素,lrem mylist 2 hello</span><br><span class="line"></span><br><span class="line">** ltrim :保留指定 key 的值范围内的数据, ltrim mylist 1 3</span><br><span class="line"></span><br><span class="line">lpop :从 list 的头部删除元素，并返回删除元素, lpop mylist</span><br><span class="line"></span><br><span class="line">** rpop :从 list 的尾部删除元素，并返回删除元素, rpop mylist</span><br><span class="line"></span><br><span class="line">** lindex :返回名称为 key 的 list 中 index 位置的元素 ,lindex mylist 0</span><br><span class="line"></span><br><span class="line">** llen :返回 key 对应 list 的长度 ,llen mylist</span><br></pre></td></tr></table></figure><hr><h4 id="Redis-集合-Set"><a href="#Redis-集合-Set" class="headerlink" title="Redis 集合(Set)"></a>Redis 集合(Set)</h4><ul><li><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p></li><li><p>Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p></li><li><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">`sadd` ： sadd myset hello</span><br><span class="line"></span><br><span class="line">`smembers` ：查看 myset 中的所有元素 , smembers myset</span><br><span class="line"></span><br><span class="line">`srem` ：删除名称为 key 的 <span class="built_in">set</span> 中的元素 member, srem myset hello</span><br><span class="line"></span><br><span class="line">spop ：随机删除名称为 key 的 se t 中一个元素,spop myset</span><br><span class="line"></span><br><span class="line">sdiff:返回第一个 <span class="built_in">set</span>集合与第二个 <span class="built_in">set</span>集合的差集,sdiff myset2 myset1</span><br><span class="line"></span><br><span class="line">sdiffstore :返回第一个 <span class="built_in">set</span>集合与第二个 <span class="built_in">set</span>集合的差集 ，并将结果存为另一个 <span class="built_in">set</span>, sdiffstore</span><br><span class="line"></span><br><span class="line">myset3 myset2 myset1</span><br><span class="line"></span><br><span class="line">sinter:返回所有给定 key 的交集 ,sinter myset1 myset2</span><br><span class="line"></span><br><span class="line">sinterstore :返回所有给定 key 的交集，并将结果存为另一个 key ,sinterstore myset4 myset2 </span><br><span class="line"></span><br><span class="line">myset1</span><br><span class="line"></span><br><span class="line">`sunion`:返回所有给定 key 的并集 ,sunion myset2 myset1</span><br><span class="line"></span><br><span class="line">sunionstore :返回所有给定 key 的并集，并将结果存为另一个key </span><br><span class="line"></span><br><span class="line">sunionstore myset5 myset2 myset1</span><br><span class="line"></span><br><span class="line">`scard`:返回名称为 key 的 <span class="built_in">set</span> 的元素个数 ,scard myset2</span><br></pre></td></tr></table></figure><hr><h4 id="Redis-有序集合-sorted-set"><a href="#Redis-有序集合-sorted-set" class="headerlink" title="Redis 有序集合(sorted set)"></a>Redis 有序集合(sorted set)</h4><ul><li><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p></li><li><p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。</p></li><li><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p></li><li><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">`zadd`：向名称为 key 的 zset 中添加元素 member， score 用于设定分数。如果该元素已经存在，则根据</span><br><span class="line"></span><br><span class="line">`score` 更新该元素的分数。zadd key score member,zrange myzset 0 -1 withscores</span><br><span class="line"></span><br><span class="line">`zrem` :删除名称为 key 的 zset 中的元素 member ,zrem myzset two</span><br><span class="line"></span><br><span class="line">`zincrby`：给成员增加指定分数 zincrby myzset 1 one</span><br><span class="line"></span><br><span class="line">`zrank` ：返回zset 中名称为 key 的 member 元素的排名(按 score 从小到大排序)即下标 zrank myzset two</span><br><span class="line"></span><br><span class="line">`zrevrank`：返回zset 中名称为 key 的 member 元素的排名(按 score 从大到小排序)即下标 zrevrank myzset two</span><br><span class="line"></span><br><span class="line">`zrevrange` ：按 score 从大到小排序，再取出全部元素 ,zrevrange myzset 0 -1 withscores</span><br><span class="line"></span><br><span class="line">`zrangebyscore` ：返回集合中 score 在给定区间的元素,zrangebyscore myzset 2 3 withscores</span><br><span class="line"></span><br><span class="line">`zcount` ：返回集合中 score 在给定区间的数量 ,zcount myzset 2 3</span><br><span class="line"></span><br><span class="line">`zcard` ：返回集合中元素个数 zcard myzset (key 的个数)</span><br><span class="line"></span><br><span class="line">`zscore` ：返回给定元素对应的 score ,zscore myzset two (key 的 score 数量)</span><br><span class="line"></span><br><span class="line">zremrangebyrank ：删除集合中排名在给定区间的元素 ,zremrangebyrank myzset 3 3</span><br><span class="line"></span><br><span class="line">zremrangebyscore ：删除集合中 score 在给定区间的元素,zremrangebyscore myzset 1 2</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Redis-Logo.wine.png&quot; style=&quot;zoom: 18%;&quot; /&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://codeyg.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://codeyg.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB概念</title>
    <link href="https://codeyg.top/2021/05/21/MongoDB%E6%A6%82%E5%BF%B5/"/>
    <id>https://codeyg.top/2021/05/21/MongoDB%E6%A6%82%E5%BF%B5/</id>
    <published>2021-05-21T14:29:58.000Z</published>
    <updated>2021-06-15T17:58:24.455Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Rbed7d6f380416eaf9643a51d41748c6a.jfif" alt="MongoDB" style="zoom:15%;" /><a id="more"></a><p>不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。</p><p>下表将更容易理解Mongo中的一些概念：</p><table><thead><tr><th align="left">SQL术语/概念</th><th align="left">MongoDB术语/概念</th><th align="left">解释/说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表/集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行/文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段/域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接,MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>一个mongodb中可以建立多个数据库。</p><p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p><p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p><p><strong>“show dbs”</strong> 命令可以显示所有数据的列表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./mongo  MongoDB shell version: 3.0.6  connecting to: <span class="built_in">test</span>  &gt; show dbs  <span class="built_in">local</span>  0.078GB  <span class="built_in">test</span>   0.078GB  &gt;</span><br></pre></td></tr></table></figure><p>执行 <strong>“db”</strong> 命令可以显示当前数据库对象或集合。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./mongo  MongoDB shell version: 3.0.6  connecting to: <span class="built_in">test</span>  &gt; db  <span class="built_in">test</span>  &gt;</span><br></pre></td></tr></table></figure><p>运行”use”命令，可以连接到一个指定的数据库。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; use local  switched to db local  &gt; db  local  &gt;</span><br></pre></td></tr></table></figure><p>以上实例命令中，”local” 是你要链接的数据库。</p><p>在下一个章节我们将详细讲解MongoDB中命令的使用。</p><p>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、/、\和\0 (空宇符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><hr><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是一个键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><p>一个简单的文档例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;&#125;</span><br></pre></td></tr></table></figure><p>下表列出了 RDBMS 与 MongoDB 对应的术语：</p><table><thead><tr><th align="center">RDBMS</th><th align="left">MongoDB</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="left">数据库</td></tr><tr><td align="center">表格</td><td align="left">集合</td></tr><tr><td align="center">行</td><td align="left">文档</td></tr><tr><td align="center">列</td><td align="left">字段</td></tr><tr><td align="center">表联合</td><td align="left">嵌入文档</td></tr><tr><td align="center">主键</td><td align="left">主键 (MongoDB 提供了 key 为 _id )</td></tr><tr><td align="center">数据库服务和客户端</td><td align="left"></td></tr><tr><td align="center">Mysqld/Oracle</td><td align="left">mongod</td></tr><tr><td align="center">mysql/sqlplus</td><td align="left">mongo</td></tr></tbody></table><p>需要注意的是：</p><ol><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><hr><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p><p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><p>比如，我们可以将以下不同数据结构的文档插入到集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;  &#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;  &#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5&#125;</span><br></pre></td></tr></table></figure><p>当第一个文档插入时，集合就会被创建。</p><h5 id="合法的集合名"><a href="#合法的集合名" class="headerlink" title="合法的集合名"></a>合法的集合名</h5><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li></ul><p>如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.findOne()</span><br></pre></td></tr></table></figure><h5 id="capped-collections"><a href="#capped-collections" class="headerlink" title="capped collections"></a>capped collections</h5><p>Capped collections 就是固定大小的collection。</p><p>它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 “RRD” 概念类似。</p><p>Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。</p><p>要注意的是指定的存储大小包含了数据库的头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;mycoll&quot;, &#123;capped:true, size:100000&#125;)</span><br></pre></td></tr></table></figure><ul><li>在capped collection中，你能添加新的对象。</li><li>能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</li><li>数据库不允许进行删除。使用drop()方法删除collection所有的行。</li><li>注意: 删除之后，你必须显式的重新创建这个collection。</li><li>在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</li></ul><hr><h4 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h4><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbname.system.*</span><br></pre></td></tr></table></figure><p>在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:</p><table><thead><tr><th align="left">集合命名空间</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dbname.system.namespaces</td><td align="left">列出所有名字空间。</td></tr><tr><td align="left">dbname.system.indexes</td><td align="left">列出所有索引。</td></tr><tr><td align="left">dbname.system.profile</td><td align="left">包含数据库概要(profile)信息。</td></tr><tr><td align="left">dbname.system.users</td><td align="left">列出所有可访问数据库的用户。</td></tr><tr><td align="left">dbname.local.sources</td><td align="left">包含复制对端（slave）的服务器信息和状态。</td></tr></tbody></table><p>对于修改系统集合中的对象有如下限制。</p><p>在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</p>是可修改的。 是可删除的。<hr><h4 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h4><p>下表为MongoDB中常用的几种数据类型。</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">String</td><td align="left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td align="left">Integer</td><td align="left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td align="left">Boolean</td><td align="left">布尔值。用于存储布尔值（真/假）。</td></tr><tr><td align="left">Double</td><td align="left">双精度浮点值。用于存储浮点值。</td></tr><tr><td align="left">Min/Max keys</td><td align="left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td align="left">Arrays</td><td align="left">用于将数组或列表或多个值存储为一个键。</td></tr><tr><td align="left">Timestamp</td><td align="left">时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td align="left">Object</td><td align="left">用于内嵌文档。</td></tr><tr><td align="left">Null</td><td align="left">用于创建空值。</td></tr><tr><td align="left">Symbol</td><td align="left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td align="left">Date</td><td align="left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td align="left">Object ID</td><td align="left">对象 ID。用于创建文档的 ID。</td></tr><tr><td align="left">Binary Data</td><td align="left">二进制数据。用于存储二进制数据。</td></tr><tr><td align="left">Code</td><td align="left">代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td align="left">Regular expression</td><td align="left">正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><p>不管我们学习什么数据库都应该学习其中的基础概念，在mongodb中基本的概念是文档、集合、数据库，下面我们挨个介绍。</p><p>下表将帮助您更容易理解Mongo中的一些概念：</p><table><thead><tr><th align="left">SQL术语/概念</th><th align="left">MongoDB术语/概念</th><th align="left">解释/说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">table</td><td align="left">collection</td><td align="left">数据库表/集合</td></tr><tr><td align="left">row</td><td align="left">document</td><td align="left">数据记录行/文档</td></tr><tr><td align="left">column</td><td align="left">field</td><td align="left">数据字段/域</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">table joins</td><td align="left"></td><td align="left">表连接,MongoDB不支持</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h4 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h4><p>一个mongodb中可以建立多个数据库。</p><p>MongoDB的默认数据库为”db”，该数据库存储在data目录中。</p><p>MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。</p><p><strong>“show dbs”</strong> 命令可以显示所有数据的列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;mongo  MongoDB shell version: 3.0.6  connecting to: test  &gt; show dbs  local  0.078GB  test   0.078GB  &gt;</span><br></pre></td></tr></table></figure><p>执行 <strong>“db”</strong> 命令可以显示当前数据库对象或集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;mongo  MongoDB shell version: 3.0.6  connecting to: test  &gt; db  test  &gt;</span><br></pre></td></tr></table></figure><p>运行”use”命令，可以连接到一个指定的数据库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; use local  switched to db local  &gt; db  local  &gt;</span><br></pre></td></tr></table></figure><p>以上实例命令中，”local” 是你要链接的数据库。</p><p>在下一个章节我们将详细讲解MongoDB中命令的使用。</p><p>数据库也通过名字来标识。数据库名可以是满足以下条件的任意UTF-8字符串。</p><ul><li>不能是空字符串（””)。</li><li>不得含有’ ‘（空格)、.、$、/、\和\0 (空宇符)。</li><li>应全部小写。</li><li>最多64字节。</li></ul><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><ul><li><strong>admin</strong>： 从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li><strong>local:</strong> 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</li><li><strong>config</strong>: 当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。</li></ul><hr><h4 id="文档-1"><a href="#文档-1" class="headerlink" title="文档"></a>文档</h4><p>文档是一个键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。</p><p>一个简单的文档例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;site&quot;:&quot;www.runoob.com&quot;, &quot;name&quot;:&quot;菜鸟教程&quot;&#125;</span><br></pre></td></tr></table></figure><p>下表列出了 RDBMS 与 MongoDB 对应的术语：</p><table><thead><tr><th align="center">RDBMS</th><th align="left">MongoDB</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="left">数据库</td></tr><tr><td align="center">表格</td><td align="left">集合</td></tr><tr><td align="center">行</td><td align="left">文档</td></tr><tr><td align="center">列</td><td align="left">字段</td></tr><tr><td align="center">表联合</td><td align="left">嵌入文档</td></tr><tr><td align="center">主键</td><td align="left">主键 (MongoDB 提供了 key 为 _id )</td></tr><tr><td align="center">数据库服务和客户端</td><td align="left"></td></tr><tr><td align="center">Mysqld/Oracle</td><td align="left">mongod</td></tr><tr><td align="center">mysql/sqlplus</td><td align="left">mongo</td></tr></tbody></table><p>需要注意的是：</p><ol><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ol><p>文档键命名规范：</p><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul><hr><h4 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h4><p>集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表格。</p><p>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</p><p>比如，我们可以将以下不同数据结构的文档插入到集合中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;  &#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;  &#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜鸟教程&quot;,&quot;num&quot;:5&#125;</span><br></pre></td></tr></table></figure><p>当第一个文档插入时，集合就会被创建。</p><h5 id="合法的集合名-1"><a href="#合法的集合名-1" class="headerlink" title="合法的集合名"></a>合法的集合名</h5><ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　</li></ul><p>如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.col.findOne()</span><br></pre></td></tr></table></figure><h5 id="capped-collections-1"><a href="#capped-collections-1" class="headerlink" title="capped collections"></a>capped collections</h5><p>Capped collections 就是固定大小的collection。</p><p>它有很高的性能以及队列过期的特性(过期按照插入的顺序). 有点和 “RRD” 概念类似。</p><p>Capped collections是高性能自动的维护对象的插入顺序。它非常适合类似记录日志的功能 和标准的collection不同，你必须要显式的创建一个capped collection， 指定一个collection的大小，单位是字节。collection的数据存储空间值提前分配的。</p><p>要注意的是指定的存储大小包含了数据库的头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createCollection(&quot;mycoll&quot;, &#123;capped:true, size:100000&#125;)</span><br></pre></td></tr></table></figure><ul><li>在capped collection中，你能添加新的对象。</li><li>能进行更新，然而，对象不会增加存储空间。如果增加，更新就会失败 。</li><li>数据库不允许进行删除。使用drop()方法删除collection所有的行。</li><li>注意: 删除之后，你必须显式的重新创建这个collection。</li><li>在32bit机器中，capped collection最大存储为1e9( 1X109)个字节。</li></ul><hr><h4 id="元数据-1"><a href="#元数据-1" class="headerlink" title="元数据"></a>元数据</h4><p>数据库的信息是存储在集合中。它们使用了系统的命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbname.system.*</span><br></pre></td></tr></table></figure><p>在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:</p><table><thead><tr><th align="left">集合命名空间</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dbname.system.namespaces</td><td align="left">列出所有名字空间。</td></tr><tr><td align="left">dbname.system.indexes</td><td align="left">列出所有索引。</td></tr><tr><td align="left">dbname.system.profile</td><td align="left">包含数据库概要(profile)信息。</td></tr><tr><td align="left">dbname.system.users</td><td align="left">列出所有可访问数据库的用户。</td></tr><tr><td align="left">dbname.local.sources</td><td align="left">包含复制对端（slave）的服务器信息和状态。</td></tr></tbody></table><p>对于修改系统集合中的对象有如下限制。</p><p>在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</p>是可修改的。 是可删除的。<hr><h4 id="MongoDB-数据类型-1"><a href="#MongoDB-数据类型-1" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h4><p>下表为MongoDB中常用的几种数据类型。</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">String</td><td align="left">字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td align="left">Integer</td><td align="left">整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td align="left">Boolean</td><td align="left">布尔值。用于存储布尔值（真/假）。</td></tr><tr><td align="left">Double</td><td align="left">双精度浮点值。用于存储浮点值。</td></tr><tr><td align="left">Min/Max keys</td><td align="left">将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td align="left">Arrays</td><td align="left">用于将数组或列表或多个值存储为一个键。</td></tr><tr><td align="left">Timestamp</td><td align="left">时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td align="left">Object</td><td align="left">用于内嵌文档。</td></tr><tr><td align="left">Null</td><td align="left">用于创建空值。</td></tr><tr><td align="left">Symbol</td><td align="left">符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td align="left">Date</td><td align="left">日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td align="left">Object ID</td><td align="left">对象 ID。用于创建文档的 ID。</td></tr><tr><td align="left">Binary Data</td><td align="left">二进制数据。用于存储二进制数据。</td></tr><tr><td align="left">Code</td><td align="left">代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td align="left">Regular expression</td><td align="left">正则表达式类型。用于存储正则表达式。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://cdn.jsdelivr.net/gh/PaulGeorge123/cloudimg@master/img/all/Rbed7d6f380416eaf9643a51d41748c6a.jfif&quot; alt=&quot;MongoDB&quot; style=&quot;zoom:15%;&quot; /&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://codeyg.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MongoDB" scheme="https://codeyg.top/tags/MongoDB/"/>
    
  </entry>
  
</feed>
